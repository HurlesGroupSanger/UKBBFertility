---
title: "Phenotype Testing"
author: "Eugene Gardner"
date: "05 May 2020"
output: 
  html_document:
    toc: true
    toc_depth: 2
---

# 1. Startup and Introduction

This document contains UKBB data and comparisons between and within this data to the trait of interest, Fertility. If using data produced by this repo, please cite [our manuscript](https://www.biorxiv.org/content/10.1101/2020.05.26.116111v1).

**Big Note**: The first part of this document involves running scripts to generate text files required for downstream analysis. _PLEASE_ start there and make sure all scripts ran successfully. All scripts for this section are available in the folder `./scripts/` and _will not_ run as part of this document. There are two additional resources that you need to download -- the OMIM morbid map, which requires registration and DDG2P. See the section [on disease genes](#disease_genes) below.

**Big Note**: You also need to have access to UKBiobank, but this script is agnostic to the UKBiobank application number. You should be able to download a bulk phenotype file and, if it contains the correct phenotypes as referred to in the manuscript and in the file `rawdata/phenofiles/fields_to_extract.txt`, you should be able to reproduce our data and figures. 

You can view a compiled html version of this document with all code run either within this repository at `compiled_htmls/PhenotypeTesting.html` or on [github](https://htmlpreview.github.io/?https://github.com/eugenegardner/UKBBFertility/blob/master/compiled_html/PhenotypeTesting.html).

## 1A. Libraries

```{r setup}

knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE ## Warnings turned off to squelch unecessary ggplot noise in kintted document. Have checked all for accuracy.
)

## Quietly Load Libraries
load.package <- function(name) {
  suppressMessages(suppressWarnings(library(name, quietly = T, warn.conflicts = F, character.only = T)))
}

load.package("biomaRt") ## Get gene lists we need
load.package("readxl") ## Read Supplemental Excel tables
load.package("data.table") ## Better than data.frame
load.package("patchwork") ## Arranging ggplots
load.package("broom") ## Makes getting covars out of lm much tidier
load.package("meta") ## For doing meta analysis
load.package("mratios") ## Need this to calculate 95% CIs for ratios of two means
load.package("svglite") ## Need to create figure 3 properly (ggsave doesn't like anything with an alpha)
load.package("tidyverse") ## Takes care of ggplot, tidyr, dplyr, and stringr
load.package("rcompanion") ## For getting incremental pseudo-R2
```

## 1B. Themes

Set themes for internal figures just for testing purposes:

```{r Base Themes}
theme <- theme(panel.background=element_rect(fill="white"),line=element_line(size=1,colour="black",lineend="round"),axis.line=element_line(size=1),text=element_text(size=16,face="bold",colour="black"),axis.text=element_text(colour="black"),axis.ticks=element_line(size=1,colour="black"),axis.ticks.length=unit(.1,"cm"),strip.background=element_rect(fill="white"),axis.text.x=element_text(angle=45,hjust=1),legend.position="blank",panel.grid.major=element_line(colour="grey",size=0.5))

## Default theme w/legend
theme.legend <- theme + theme(legend.position="right")

del.line <- "#4F7942"
del.fill <- "#77DD77"
dup.line <- "#0000FF"
dup.fill <- "#AEC6CF"
```

Theme for main text/supplemental figures (making font size smaller):

```{r Figure Themes}
theme.figures <- theme(panel.background=element_rect(fill="white"),line=element_line(size=1,colour="black",lineend="round"),axis.line=element_line(size=1),text=element_text(size=10,face="bold",colour="black"),axis.text=element_text(colour="black"),axis.ticks=element_line(size=1,colour="black"),axis.ticks.length=unit(.1,"cm"),strip.background=element_rect(fill="white"),axis.text.x=element_text(angle=45,hjust=1),legend.position="blank",panel.grid.major=element_line(colour="grey",size=0.5))

## Default theme w/legend
theme.figures.legend <- theme.figures + theme(legend.position="right")

## Colour Scheme:
male <- "#38BCA0"
female <- "#7B06F8"

sex.colours <- c(male, female)
names(sex.colours) <- c("Male","Female")
sex.colours.fill <- scale_fill_manual(name = "Sex",values=sex.colours,guide=guide_legend(reverse=F))
sex.colours.colour <- scale_colour_manual(name = "Sex",values=sex.colours, guide=guide_legend(reverse=F))
sex.colours.fill.rev <- scale_fill_manual(name = "Sex",values=sex.colours,guide=guide_legend(reverse=T))
sex.colours.colour.rev <- scale_colour_manual(name = "Sex",values=sex.colours, guide=guide_legend(reverse=T))

alt.colours <- c("#75485E","#CB904D","#DFCC74")
```

## 1C. Prepping Storage Directories

This just unpacks the tarball of provided data resources at `rawdata.tar.gz`

```{bash Prepare Storage}

tar -zxf rawdata.tar.gz

```

# 2. Generating Required Text Files

Example code for downloading and initial processing UKBB phenotype file. None of the code in this section will actually be run.

## 2A. Creating Master Phenotype File:

This code chunk is not evaluated here but is provided for replication purposes. This code chunk assumes that the user has already gained access to, and [downloaded](http://biobank.ndph.ox.ac.uk/showcase/), relevant phenotype fields and has aquired the encoded phenotype file (like ukb00000.enc). The tools used below are also available via the [UKBiobank datashowcase website](http://biobank.ndph.ox.ac.uk/showcase/download.cgi). More information on downloading can be found [here](https://biobank.ctsu.ox.ac.uk/~bbdatan/Accessing_UKB_data_v2.1.pdf).

```{bash Get UKBB Phenotype File, eval = F}

## First step involves downloading and decoding individual phenotype data. Keyvalue is the key provided via email when you apply for bulk download. This will create a decoded file ukb00000.enc_ukb
ukbunpack ukb00000.enc <keyvalue>

## Next, convert the file to a tab-delimited format:
ukbconv ukb00000.enc_ukb txt

## Create a data dictionary (so we know where phenotypes are in the file!)
ukbconv ukb00000.enc_ukb docs

## This should result in 2 required files for further processing:
# ukb00000.txt
# ukb00000.html
```

**Note** the following processing data expects the "ukb00000.*" data to be in the unpacked `rawdata/phenofiles/` directory!

This code chunk extracts phenotypes of relevance from the master phenotype file that is downloaded and processed above. It is run with the script: `./scripts/extract_phenotypes.pl`.

This script is slower than it should be due to an issue with text format encoding of the UKBB-created TSV file on MacOS. If running this code on a UNIX system, would suggest switching the 'exec' call at the bottom of this script to use cut for additional speed. It should mean the script executes in ~30s rather than 5mins.

```{bash Extract Phenotypes, eval = F}

## First do most fields:
./scripts/extract_phenotypes.pl rawdata/phenofiles/fields_to_extract.txt rawdata/phenofiles/ukbb_phenotypes.txt

## Have to extract first incidence data seprately as it requires additional processing:
## P.S. Make sure you run the above command first!!!
./scripts/extract_phenotypes.pl rawdata/phenofiles/fi_fields_to_extract.txt rawdata/phenofiles/fi_phenotypes.txt
./scripts/process_first_incidence.pl

```

## 2B. Setting Unrelated Individuals:

Again, this is just an example on how relatedness information is accquired from UKBB, code does not actually run. It proceeds in two basic steps:

1. Download the relatedness file using the (ukbgene)[http://biobank.ndph.ox.ac.uk/showcase/refer.cgi?id=664] tool
2. Place the file in `./rawdata/phenofiles/`
3. Running the provided script to generate a list of individuals to filter - at: `./scripts/get_relateds.R`.

```{bash Process Relatedness, eval = F}

## 1. Run ukbgene rel. This will download a file like: ukbXXXXX_rel_sYYYYYY.dat, where X represents your application ID, and 488288 represents the file version
ukbgene rel

## 2. Get related individuals to filter (change the name of the .dat to your specific file):
./scripts/get_relateds.R ukbXXXXX_rel_sYYYYYY.dat > raw_data/phenofiles/relateds.out
## Format the output file to be readable by R
perl -ne 'if ($_ =~ /\"(\d{7})\"/) {print "$1\n";}' raw_data/phenofiles/relateds.out > raw_data/phenofiles/relateds.txt
```

# 3. Phenotype Data

Read in the master phenotype and related individuals file that was created in [the previous section](#2._generating_required_text_files)

```{r Load Master Phenotype File}

UKBB.raw.phenotypes <- fread("rawdata/phenofiles/ukbb_phenotypes.txt")
UKBB.raw.phenotypes[,eid:=as.character(eid)]

```

```{r Load Relatedness File}

related.individuals <- fread("rawdata/phenofiles/relateds.txt", header = F)
setnames(related.individuals,"V1","eid")
related.individuals[,eid:=as.character(eid)]

```

## 3A. Generic Phenotypes

Grabbing generic phenotypes age, sex, ancestry, European ancestry status and adding them to the main UKBB.phenotype.data table.

This also filters out individuals that are not broadly European.

```{r Process Generic Phenotypes}

## Data table of all UKBB population data:
PCAs<-c(1:30)
for (i in PCAs) {
  PCAs[i] <- paste("22009-0",i,sep=".")
}
fields <- c("eid","22006-0.0","31-0.0","21022-0.0","34-0.0","52-0.0",PCAs)
UKBB.phenotype.data <- UKBB.raw.phenotypes[,..fields]

setnames(UKBB.phenotype.data,c(fields),c("eid","white.british.ancestry","sexPulse","agePulse","birth.year","birth.month","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10","PC11","PC12","PC13","PC14","PC15","PC16","PC17","PC18","PC19","PC20","PC21","PC22","PC23","PC24","PC25","PC26","PC27","PC28","PC29","PC30"))

## Remove all non-white British (determined direct by UKBB and taken from the pheno file)
UKBB.phenotype.data <- UKBB.phenotype.data[!is.na(white.british.ancestry)]
paste0("Number of Broadly Euro Indiv: ", table(UKBB.raw.phenotypes[,`22006-0.0`]))

## Remove all related individuals:
UKBB.phenotype.data <- UKBB.phenotype.data[!eid %in% related.individuals[,eid]]

## Change sex to be 1 = male, 2 = female instead of 0,1. 
## This is a distinction made for an old project to keep it consistent.
UKBB.phenotype.data[,sexPulse:=ifelse(sexPulse == 0, 2, 1)]

## Add agePulse.squared covar:
UKBB.phenotype.data[,agePulse.squared:=agePulse^2]
paste0("Number of Individuals after filtering: ",nrow(UKBB.phenotype.data))

## Curate birthdays:
## Have to set everybody's birthday as the 15th since UKBB doesn't want to give specific days out. Should be a reasonable approximation as it's the closest possible day for all individuals...
UKBB.phenotype.data[,birthday:=paste(birth.year,sprintf("%02d",birth.month),"15",sep="-")]
UKBB.phenotype.data[,birthday:=as.Date(birthday, format = "%Y-%m-%d")]
UKBB.phenotype.data[,birth.year:=NULL]
UKBB.phenotype.data[,birth.month:=NULL]

rm(PCAs,fields,i)
```


## 3B. Fertility

```{r Fertility, fig.height=5, fig.width=4}

fertility.metrics <- UKBB.raw.phenotypes[,c("eid",
                                            "2405-0.0", ## Children Fathered
                                            "2734-0.0", ## Live Births
                                            "6141-0.0", ## Individuals in household
                                            "709-0.0", ## Number of individuals in household
                                            "2129-0.0", ## Answered Sex Questions
                                            "2159-0.0" ## Same sex behaviour
                                            )]

## Replace all NAs with a double value to make filtering easier
fertility.metrics[is.na(fertility.metrics)] <- -9

setnames(fertility.metrics,names(fertility.metrics),c("eid",
                                                      "children.fathered",
                                                      "live.births",
                                                      "in.household",
                                                      "number.in.household",
                                                      "answered.sex",
                                                      "same.sex"))
                                                     
# Number of live births:
fertility.metrics[,live.births:=if_else(live.births > 7, -9, live.births)]
fertility.metrics[,live.births:=if_else(live.births < 0, -9, live.births)]
                    
ggplot(fertility.metrics[live.births>=0],aes(live.births,..density..)) +
  geom_histogram(binwidth = 1,colour="black",fill=female) +
  xlab("Live Births") +
  scale_y_continuous(name = "Proportion of Females", limits=c(0,0.5), labels = paste0(c(0,10,20,30,40,50),"%")) +
  theme

# Children fathered
fertility.metrics[,children.fathered:=if_else(children.fathered > 7, -9, children.fathered)]
fertility.metrics[,children.fathered:=if_else(children.fathered < 0, -9, children.fathered)]

ggplot(fertility.metrics[children.fathered>=0],aes(children.fathered,..density..)) +
  geom_histogram(binwidth = 1,colour="black",fill=male) +
  xlab("Children Fathered") +
  scale_y_continuous(name = "Proportion of Males", limits=c(0,0.5), labels = paste0(c(0,10,20,30,40,50),"%")) +
  theme

## Who is in the household is stored in an array of up to 5 values (so can stored UP to 5 possible relationships)
## Is a follow-up question to "how many individuals are in your household?" and will be NA if they did not answer
## To make this simple, just taking the first response, the followup data is so small, isn't going to matter and it's taking me way too long to come up with all possible combinations
fertility.metrics[,partner.in.house:=if_else(number.in.household < 0,-9, ## Did not answer, did not know, did not want to answer
                                               if_else(number.in.household==1,0, ## individuals living by themselves
                                                       if_else(number.in.household > 1 & in.household == 1,1,0)))] ## Check if partner present

ggplot(merge(UKBB.phenotype.data,fertility.metrics,by="eid"),aes(as.factor(partner.in.house),group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  stat_count(position="identity",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_discrete(name="Has Partner In Home?",labels=c("Did Not Answ.","False","True")) +
  theme.legend

## Same sex sexual behaviour
fertility.metrics[,same.sex:=if_else(answered.sex == 1,
                                     if_else(same.sex == 0,0,
                                             if_else(same.sex == 1,1,-9)),
                                     -9)]

ggplot(merge(UKBB.phenotype.data,fertility.metrics,by="eid"),aes(as.factor(same.sex),group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  stat_count(position="identity",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_discrete(name="Engaged in Same Sex Behaviour?",labels=c("True","False","Did Not Answ.")) +
  theme.legend

## Now convert all the -9s back to NA
fertility.metrics <- fertility.metrics[,c("eid","children.fathered","live.births","partner.in.house","same.sex")]
fertility.metrics[,children.fathered:=if_else(children.fathered==-9,as.numeric(NA),children.fathered)]
fertility.metrics[,live.births:=if_else(live.births==-9,as.numeric(NA),live.births)]
fertility.metrics[,partner.in.house:=if_else(partner.in.house==-9,as.numeric(NA),partner.in.house)]
fertility.metrics[,same.sex:=if_else(same.sex==-9,as.numeric(NA),same.sex)]

UKBB.phenotype.data <- merge(UKBB.phenotype.data,fertility.metrics,by="eid")
rm(fertility.metrics)
```

## 3C. Fluid Intelligence

This section looks at UKBB "Fluid Intelligence". 

The field of relevance for us is 20016-0.0. There is no array data (only 1 test was done, but 3 instances - we're using instance 0).

```{r Fluid Intelligence}

## Grab fluid intel from the raw phenotypes:
fluid.intel.table <- UKBB.raw.phenotypes[,c("eid","20016-0.0")]
fluid.intel.table[,fluid.intel:=if_else(is.na(`20016-0.0`),as.integer(NA),`20016-0.0`)]
ggplot(merge(UKBB.phenotype.data,fluid.intel.table,by="eid"),aes(fluid.intel,group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  geom_histogram(binwidth = 1, position="identity", alpha = 0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_continuous(name="Fluid Intel Score") +
  scale_y_continuous(name = "# of Individuals") +
  theme.legend

## Normalize fluid intelligence
fluid.intel.table[,fluid.intel:=(fluid.intel-mean(fluid.intel,na.rm=T))/sd(fluid.intel,na.rm=T)]
ggplot(merge(UKBB.phenotype.data,fluid.intel.table,by="eid"),aes(fluid.intel,group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  geom_histogram(binwidth = 1, position="identity", alpha = 0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_continuous(name="Normalized Fluid Intel Score") +
  scale_y_continuous(name = "# of Individuals") +
  theme.legend

## Merge with remaining phenotypes
UKBB.phenotype.data <- merge(UKBB.phenotype.data,fluid.intel.table[,c("eid","fluid.intel")],by="eid",all.x=T)

rm(fluid.intel.table)
```

## 3D. Educational Attainment

Analyzing fields for Educational Attainment.

6138-0/1/2 includes educational attainment measures. There are a max of 5 values for each instance (to accomodate multiple levels of qualifications). Weuse a binary for did/did not complete a college degree, which is high correlated with years of education according to [this](https://academic.oup.com/sf/article-abstract/92/1/109/2235872?redirectedFrom=fulltext) article (cannot actually read it as is behind a paywall, but was cited in [this](https://static-content.springer.com/esm/art%3A10.1038%2Fnature17671/MediaObjects/41586_2016_BFnature17671_MOESM48_ESM.pdf) study as an explanation for why they don't care about years schooling vs. college education.

```{r Educational Attainment, fig.height=3, fig.width=6}

educational.attainment <- UKBB.raw.phenotypes[,c("eid","6138-0.0")]

## only have to check the first array column as that is the only one that is ever == 1 (i.e. college education)
educational.attainment[,test.1:=if_else(is.na(`6138-0.0`),as.integer(NA),
                                        if_else(`6138-0.0` == -3,as.integer(NA),
                                                if_else(`6138-0.0` == 1,1L,0L)))]

## This is for just testing in center data
educational.attainment[,completed.college:=test.1]
educational.attainment <- educational.attainment[,c("eid","completed.college")]

ggplot(merge(UKBB.phenotype.data,educational.attainment,by="eid"),aes(as.factor(completed.college),group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  stat_count(position="identity",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_discrete(name="Completed College?",labels=c("False","True","NA")) +
  theme.legend

## Merge with remaining phenotypes
UKBB.phenotype.data <- merge(UKBB.phenotype.data,educational.attainment,by="eid",all.x=T)
rm(educational.attainment)
```

## 3E. Household Income

```{r Income data}

income.data <- UKBB.raw.phenotypes[,c("eid","738-0.0")]

income.data[,household.income:=if_else(`738-0.0`>0,`738-0.0`,as.integer(NA))]

income.data <- income.data[,c("eid","household.income")]

ggplot(merge(UKBB.phenotype.data,income.data,by="eid"),aes(household.income,group=as.factor(sexPulse),fill=as.factor(sexPulse))) + 
  geom_histogram(binwidth=1,position=position_dodge(),colour="black") + 
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_continuous(name="Income Bracket") +
  ylab("# of Individuals") +
  theme.legend

## Merge with remaining phenotypes
UKBB.phenotype.data <- merge(UKBB.phenotype.data,income.data,by="eid",all.x=T)
rm(income.data)
```

## 3F. Email

```{r email data}

email.data <- UKBB.raw.phenotypes[,c("eid","20005-0.0")]

## As far as I can tell this is a purely binary value:
email.data[,has.email:=if_else(!is.na(`20005-0.0`),1,0)]

email.data <- email.data[,c("eid","has.email")]

ggplot(merge(UKBB.phenotype.data,email.data,by="eid"),aes(as.factor(has.email),group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  stat_count(position="identity",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_discrete(name="Has Email?",labels=c("False","True")) +
  theme.legend

## Merge with remaining phenotypes
UKBB.phenotype.data <- merge(UKBB.phenotype.data,email.data,by="eid",all.x=T)
rm(email.data)
```

## 3G. Mental Health Phenotypes

### ICD 10 Coding

#### Hospital Episode Statistics

This code pulls in all Hospital Episode Statistic (HES) ICD-10 codes for all individuals. Using this to test for 

$$ has.children \sim s_{het[i,v]} + has.icd.code + age + age^2 + PC1..PC10 $$

In the section(s) below.

```{r All ICD codings}

## Load most HES ICD-10 Codes except cancer
cols <- names(UKBB.raw.phenotypes)[grep("eid|41202|41204",names(UKBB.raw.phenotypes))]
hes.data.long <- data.table(pivot_longer(UKBB.raw.phenotypes[,..cols],-eid,values_to="icd.code",values_drop_na = T))
hes.data.long <- hes.data.long[,c("eid","icd.code")]

## Remove duplicate primary/secondary codes:
hes.data.long <- unique(hes.data.long)

## Remove any cancer codes that we will get from cancer-specific icd.data
hes.data.long <- hes.data.long[grepl("C",icd.code) == F & grepl("D[0-4]", icd.code, perl = T) == F & grepl("O0", icd.code, perl = T) == F]

## Load Cancer codings:
cols <- names(UKBB.raw.phenotypes)[grep("eid|40006",names(UKBB.raw.phenotypes))]
cancer.data.long <- data.table(pivot_longer(UKBB.raw.phenotypes[,..cols],-eid,values_to="icd.code",values_drop_na = T))
cancer.data.long <- cancer.data.long[,c("eid","icd.code")]

## Mash together regular ICD10 and Cancer codes:
hes.data.long <- rbind(hes.data.long, cancer.data.long)

## Generate shorter string to match:
hes.data.long[,icd.category:=substr(icd.code,1,3),by=1:nrow(hes.data.long)]

```

#### First Incidence ICD Codings

We have gotten access to the first incidence ICD-10 codings, which we hope will represent a more accurate depiction of conditions an individual has, as well as provide a way of only testing individuals with conditions prior to child-bearing age. We extract fields the same way as before, and then create a data dictionary to link up each code to it's relevant UKBB field. This will incorperate all fields from 130000-132605. We also incorperate field 42040 here to exclude individuals who don't have GP records. This cuts our sample size in half, but is better than having differential ascertainment in my opinion.

```{r read and process}

first.incidence.data <- fread("rawdata/phenofiles/fi_phenotypes.txt")
first.incidence.data[,eid:=as.character(eid)]

valid.first.incidence.indvs <- fread("rawdata/phenofiles/valid_fi_indvs.txt")
valid.first.incidence.indvs[,eid:=as.character(eid)]

## Pretty certain everybody has at least one GP code... so this doesn't do anything, but just to be sure...
first.incidence.data <- first.incidence.data[eid %in% valid.first.incidence.indvs[!is.na(num.gp.codes),eid]]
first.incidence.data <- merge(first.incidence.data,UKBB.phenotype.data[,c("eid","birthday")],by="eid")
first.incidence.data[,date:=as.Date(date, format = "%Y-%m-%d")]

## Set a flag in the phenotype data for people I should include:
UKBB.phenotype.data[,has.first.incidence.data:=eid %in% valid.first.incidence.indvs[!is.na(num.gp.codes),eid]]

## Get ~age of incidence while taking into account special codes:
first.incidence.data[,age.at.incidence:=if_else(date == as.Date("2037-07-07"), -1, ## This is an error code for incidence in the future and is presumably an error.
                                                if_else(date == as.Date("1901-01-01"), -1, ## This is an error code for incidence before birth (doesn't appear to be any...?)
                                                        if_else(date == as.Date("1902-02-02"), 0, ## This is congenital conditions
                                                                if_else(date == as.Date("1903-03-03"), 0.5, ## This is for neonatal conditions 
                                                                        as.numeric(difftime(date, birthday), units = "days") / 365))))] ## This is for all other cases. I ignore leap years, leave me alone. (Also, I don't have the exact birthday, so leap years is the least of my worries)
```

This is just to generate equivalent data from FI data as is generated for HES and MHQ data.

```{r translate to table format}

## This is very ugly but was the easiest way for me to tabulate it from another datasource to ensure rough concistency. 
codes <- c("F20",
"F20","F20","F20","F20","F20","F20","F20","F20","F20","F23","F23","F25", "F25","F25","F25","F25","F25","F84","F84","F84","F84","F30", "F30","F30","F30","F30","F30","F31", "F31","F31","F31","F31","F31","F31","F31","F31","F31","F31","F32", "F32","F32","F32","F32","F32","F32","F33", "F33","F33","F33","F33","F33","F33","F33","F50", "F50","F50","F50","F50","F50","F50","F40","F40","F42","F42","F42","F42","F42","F42","F41","F40","F60","F60","F60","F60","F60","F60","F60","F60","F60","F60","F60","F61","F41","F90","N46")
condition <- c('scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','scizo','asd','asd','asd','asd','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','bipolar','depression','depression','depression','depression','depression','depression','depression','depression','depression','depression','depression','depression','depression','depression','depression','eating_disorders','eating_disorders','eating_disorders','eating_disorders','eating_disorders','eating_disorders','eating_disorders','phobia','phobia','ocd','ocd','ocd','ocd','ocd','ocd','gen_anxiety','phobia','gen_personality','gen_personality','gen_personality','gen_personality','gen_personality','gen_personality','gen_personality','gen_personality','gen_personality','gen_personality','gen_personality','gen_personality','gen_anxiety','add','infertility')

condition.key <- data.table(code=codes, table.condition=condition)
condition.key <- unique(condition.key)

first.incidence.data <- merge(first.incidence.data, condition.key, by = "code", all.x = T)
condition.table <- data.table(table(first.incidence.data[,c("eid","table.condition")]))
condition.table[,N:=if_else(N == 0, 0, 1)]
condition.table <- data.table(pivot_wider(condition.table, id_cols = eid, names_from=table.condition, values_from = N))
setnames(condition.table,names(condition.table)[-1],paste("fi",names(condition.table)[-1],sep="."))

UKBB.phenotype.data <- merge(UKBB.phenotype.data,condition.table[,c("eid","fi.scizo","fi.bipolar","fi.asd","fi.add")],by="eid",all.x=T)
```

#### Specific HES ICD-10 Codings

The ICD-10 codes that I have used and their equivalancies to the MHQ section are listed in the perl script below. For the traits covered in [Power et al.](https://jamanetwork.com/journals/jamapsychiatry/article-abstract/1390257) I have stuck with their exact codes to enable replication, for the others I have searched for equivalents using various articles on those particular subjects.

This set of data needs to be processed in two steps, as I use perl to process the actual phenotypes (it's much easier than in R). Need to first print out a text file of the raw phenotypes I need, process it with Perl, and then read back in and add to the final phenotype table.

```{r Print ICD10 Data}

cols.to.print <- c("eid",names(UKBB.raw.phenotypes)[grep("41202",names(UKBB.raw.phenotypes))],names(UKBB.raw.phenotypes)[grep("41204",names(UKBB.raw.phenotypes))])
icd.data <- UKBB.raw.phenotypes[,..cols.to.print]
write.table(icd.data,file="rawdata/phenofiles/ICD10.data.txt",sep="\t",row.names=F,col.names=F,quote=F)

```

```{bash Process ICD10 Data}

./scripts/process_icd.pl

```

```{r process ICD10}

hes.data <- fread("rawdata/phenofiles/ICD10.data.processed.txt")
hes.data[,eid:=as.character(eid)]

setnames(hes.data, names(hes.data), c("eid",paste("hes",names(hes.data)[2:length(names(hes.data))],sep=".")))
UKBB.phenotype.data <- merge(UKBB.phenotype.data,hes.data[,c("eid","hes.scizo","hes.bipolar","hes.asd","hes.add")],by="eid",all.x=T)
```

### Mental Health Questionnaire

This [recent paper](https://doi.org/10.1192/bjo.2019.100) documents the mental health questionaire that was sent out to a subset of UKBB particpants. ~160k responded on a number of measures. On the UKBB Data Showcase, they have a [document](http://biobank.ndph.ox.ac.uk/showcase/showcase/docs/mental_health_online.pdf) about what questions were asked and where to find them in the showcase.

This section is attempting to replicate the general codings of [this](https://jamanetwork.com/journals/jamapsychiatry/article-abstract/1390257) study that looked at all Swedish individuals born from 1950-1970 that did not have any genetic data. As such, the equivalent UK Biobank fields and their codings withing the MH Questionnaire are:

* 20406 (alcohol), 20503 (prescription meds), 20456(rec. drugs) - Substance Addiction. Field 20401 indicates a 'YES' answer to ever addicted to a substance or behaviour, which is a 'gate' question to answer these three fields.
* 20544: Numbers that follow are the code for that disorder 
    + Social Anxiety/Phobia (1)
    + Psychotic disorders (2 & 3) - This is also encoded in ICD10 code(s) F20-29. Could get a bigger N by using ICD10 codes?
    + Personality disorders (4)
		+  Any other diabling phobia(5)
		+  Panic Attacks (6)
		+  OCD (7)
		+  Bipolar disorder, manic depressive diso., etc. (10)
		+  Depression (11)
		+  Eating disorders (12,13,16)
		+  ASD (14)
		+  General Anxiety Disorder(15)
		+  Agorophobia (17)
		+  ADD/ADHD (18)
		+  Did not answer one or both sections (-818, -819)

Processing of MH Traits functions similarly to ICD10 above, where I have to print a file, processes with perl and then read it back in:

```{r Print MHQ data}

cols.to.print <- c("eid","20401-0.0","20406-0.0","20456-0.0","20503-0.0",names(UKBB.raw.phenotypes)[grep("20544",names(UKBB.raw.phenotypes))])
mhq.data <- UKBB.raw.phenotypes[,..cols.to.print]
write.table(mhq.data,file="rawdata/phenofiles/mhq.data.txt",sep="\t",row.names=F,col.names=F,quote=F)

```

```{bash Process MH data}

./scripts/process_mhq.pl

```

```{r Process MHQ}

mhq.data <- fread("rawdata/phenofiles/mhq.data.processed.txt")
mhq.data[,eid:=as.character(eid)]

setnames(mhq.data, names(mhq.data), c("eid",paste("mhq",names(mhq.data)[2:length(names(mhq.data))],sep=".")))

## Convert answered MHQ to binary:
mhq.data[,mhq.answered_mhq:=if_else(is.na(mhq.answered_mhq),0,1)]
UKBB.phenotype.data <- merge(UKBB.phenotype.data,mhq.data[,c("eid","mhq.scizo","mhq.bipolar","mhq.asd","mhq.add","mhq.answered_mhq")],by="eid",all.x=T)
```

### Comparing MH Data Sources:

```{r compare MHQ and ICD10}

## Totals MHQ:
totals.mhq <- mhq.data[,lapply(.SD, sum,na.rm=T),.SDcols=names(mhq.data)[2:length(names(mhq.data))]]
totals.mhq <- data.table(pivot_longer(totals.mhq,cols=names(totals.mhq),names_sep="\\.",names_to = c(".value","condition")))

## Totals HES:
totals.hes <- hes.data[,lapply(.SD, sum,na.rm=T),.SDcols=names(hes.data)[2:length(names(hes.data))]]
totals.hes <- data.table(pivot_longer(totals.hes,cols=names(totals.hes),names_sep="\\.",names_to = c(".value","condition")))

## Totals FI:
totals.fi <- condition.table[,lapply(.SD, sum,na.rm=T),.SDcols=names(condition.table)[2:length(names(condition.table))]]
totals.fi <- data.table(pivot_longer(totals.fi,cols=names(totals.fi),names_sep="\\.",names_to = c(".value","condition")))

n.mhq <- totals.mhq[condition=="answered_mhq",mhq]
n.hes <- nrow(hes.data)
n.fi <- nrow(condition.table)

totals.mhq[,prop:=(mhq/n.mhq)*100]
totals.hes[,prop:=(hes/n.hes)*100]
totals.fi[,prop:=(fi/n.fi)*100]

setnames(totals.mhq,c("mhq","prop"),c("value.mhq","prop.mhq"))
setnames(totals.hes,c("hes","prop"),c("value.hes","prop.hes"))
setnames(totals.fi, c("fi","prop"),c("value.fi","prop.fi"))

totals <- merge(totals.mhq, totals.hes,by="condition",all.y = T)
totals <- merge(totals, totals.fi, by = "condition", all.x = T)

ggplot(totals,aes(prop.hes,prop.mhq)) + geom_point() + scale_x_log10(name="HES Proportion",limits=c(1e-2,1e1)) + scale_y_log10(name="MHQ Proportion",limits=c(1e-2,1e1)) + geom_text(aes(label=condition)) + geom_abline(linetype = 2, colour = "red") + theme

ggplot(totals,aes(prop.mhq,prop.fi)) + geom_point() + scale_x_log10(name = "MHQ Proportion",limits=c(1e-2,1e1)) + scale_y_log10(name="FI Proportion",limits=c(1e-2,1e1)) + geom_text(aes(label=condition)) + geom_abline(linetype = 2, colour = "red") + theme

ggplot(totals,aes(prop.hes,prop.fi)) + geom_point() + scale_x_log10(name = "HES Proportion",limits=c(1e-2,1e1)) + scale_y_log10(name="FI Proportion",limits=c(1e-2,1e1)) + geom_text(aes(label=condition)) + geom_abline(linetype = 2, colour = "red") + theme

rm(totals.mhq,totals.hes,n.mhq,n.hes,totals,mhq.data,hes.data)
```

## 3H. Neutral Phenotypes

Purpose of these phenotypes is to provide a test against s[het] for a phenotype we do not expect to have a (strong) genetic component to test to make sure there is no bias in our ascertainment:

* Fresh Fruit Intake (Field 1309)
* Handedness (Field 1707)
* Hair colour (Field 1747)

```{r neutral phenotypes}

neutral.phenos <- UKBB.raw.phenotypes[,c("eid","1309-0.0","1707-0.0","1747-0.0")]

neutral.phenos[,fresh.fruit:=ifelse(is.na(`1309-0.0`),NA,
                                     ifelse(`1309-0.0` < 0,NA,`1309-0.0`))]

neutral.phenos[,handedness:=ifelse(`1707-0.0` == "NaN" | is.na(`1707-0.0`), NA,
                                    ifelse(`1707-0.0`==1,0,
                                            ifelse(`1707-0.0`==2,1,NA)))]

neutral.phenos[,is.blonde:=if_else(is.na(`1747-0.0`) | `1747-0.0` < 0, NaN,
                                   if_else(`1747-0.0` == 1, 1, 0))]

UKBB.phenotype.data <- merge(UKBB.phenotype.data,neutral.phenos[,c("eid","fresh.fruit","handedness","is.blonde")],by="eid",all.x=T)

```

# 4. Assembling Sequencing/Array Data

## 4A. Curating Gene Lists

We use several genelists as part of this project:

1. pLI information from the [gnomAD project](https://storage.googleapis.com/gnomad-public/release/2.1.1/constraint/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz).
2. s~het~ from [Weghorn et al.](https://doi.org/10.1093/molbev/msz092). The reference file is included in this repository (`rawdata/genelist/shet.weghorn.txt`).
    + We also, for comparative purposes, use the old s~het~ from [Cassa et al.](https://www.nature.com/articles/ng.3831) which is included in this repository as well (`rawdata/genelist/shet.cassa.txt`)
3. ENSEMBL-downloaded resources from [BioMart](https://www.ensembl.org/biomart/martview/0511514c231557b5d24ace4e8f7862e0).
4. Disease genes from ClinVar, DDG2P, and OMIM (see that section for links).
5. Male Infertility Genes from [this paper](https://academic.oup.com/humrep/article/34/5/932/5377831).

The purpose of the following scripts is to generate these lists if they are not available. This process is also duplicated when processing CNV data and annotating SNVs/InDels, as that has to be done as part of a separate script. See both the section on [Variant Data](#4._variant_data) in this document, and the separate RMarkdown documents `CNVCalling_Filtering.R` and `SNVCalling_Filtering.Rmd`, respectively, for more information.

**Note**: These scripts assume you have `curl` installed on your system, which _should_ be true if you are using macos. Please change the scripts below if this is not the case.

### Download Resources from BioMart

```{r Generate biomart resources}

## Hg19
ensembl <- useMart("ensembl", host="http://grch37.ensembl.org", dataset = "hsapiens_gene_ensembl")
hg19.table <- data.table(getBM(attributes = c('ensembl_gene_id','chromosome_name','start_position','end_position','hgnc_id','hgnc_symbol','ensembl_transcript_id'),mart = ensembl))
hg19.table <- hg19.table[!grep("_",chromosome_name)]
write.table(hg19.table,"rawdata/genelists/hg19.genes.txt",col.names=F,row.names=F,quote=F,sep="\t")

## Hg38
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
hg38.table <- data.table(getBM(attributes = c('ensembl_gene_id','chromosome_name','start_position','end_position','hgnc_id','hgnc_symbol','strand'),mart = ensembl))
hg38.table[,hgnc_id:=str_remove(hgnc_id,"HGNC:"),by=1:nrow(hg38.table)]
hg38.table <- hg38.table[!grep("CHR_",chromosome_name)]
write.table(hg38.table,"rawdata/genelists/hg38.genes.txt",col.names=F,row.names=F,quote=F,sep="\t")

rm(hg19.table,hg38.table,ensembl)
```

### s~het~ Gene Lists

```{bash Generate sHET gene lists}

perl -ane 'chomp $_; @F = split("\t", $_); print "$F[0]\t$F[7]\n";' rawdata/genelists/shet.weghorn.txt > rawdata/genelists/shet.processed.weghorn.txt
perl -ane 'chomp $_; @F = split("\t", $_); print "$F[0]\t$F[1]\n";' rawdata/genelists/shet.cassa.txt > rawdata/genelists/shet.processed.cassa.txt

## sHET gene lists (have to attach ENSG):
scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -col1 5 -file2 rawdata/genelists/shet.processed.weghorn.txt -r | perl -ane 'chomp $_; print "$F[2]\t$F[0]\t$F[1]\t$F[6]\n";' > rawdata/genelists/shet.hgnc.txt
scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -col1 5 -file2 rawdata/genelists/shet.processed.cassa.txt -r | perl -ane 'chomp $_; print "$F[2]\t$F[0]\t$F[1]\t$F[6]\n";' > rawdata/genelists/shet.cassa.hgnc.txt
```

### Hg19 Gene Lists

```{bash Generate hg19 Gene Lists}

## Download gnomAD scores:
curl -o rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz https://storage.googleapis.com/gnomad-public/release/2.1.1/constraint/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz

## Rename your files gnomAD........
mv rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt.gz
gunzip -f rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt.gz

## Create a reference file of just ENSG and pLI, while removing genes w/o a pLI score:
perl -ane 'chomp $_; @F = split("\t", $_); if ($F[20] ne 'NA') {print "$F[63]\t$F[20]\n";}' rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt > rawdata/genelists/hg19.all_genes_with_pli.txt

## Add additional info from biomart that we acquired:
# pLI file:
scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -file2 rawdata/genelists/hg19.all_genes_with_pli.txt -r | perl -ne 'chomp $_;  @F = split("\t", $_); print "$F[0]\t$F[3]\t$F[4]\t$F[5]\t$F[6]\t$F[7]\t$F[8]\t$F[1]\n";' > rawdata/genelists/hg19.all_genes_with_pli.2.txt
mv rawdata/genelists/hg19.all_genes_with_pli.2.txt rawdata/genelists/hg19.all_genes_with_pli.txt

# sHET file:
scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -file2 rawdata/genelists/shet.hgnc.txt -r | perl -ne 'chomp $_;  @F = split("\t", $_); print "$F[0]\t$F[5]\t$F[6]\t$F[7]\t$F[8]\t$F[9]\t$F[10]\t$F[2]\n";' > rawdata/genelists/hg19.all_genes_with_shet.txt
```

### Hg38 Gene Lists

```{bash Generate hg38 Gene lists}
# Try and match genes to Hg19 based on HGNC ID
# Generate a list of hg19 genes with HGNC IDs:
perl -ane 'chomp $_; if ($F[4] ne "NA" && $F[4] ne "") {print "$F[4]\t$F[0]\t$F[5]\n";}' rawdata/genelists/hg19.genes.txt | sort | uniq > rawdata/genelists/hg19.trans.txt

scripts/matcher.pl -file1 rawdata/genelists/hg19.trans.txt -file2 rawdata/genelists/hg38.genes.txt -col2 4 -r | perl -ane 'chomp $_; print "$F[0]\t$F[1]\t$F[2]\t$F[3]\t$F[4]\t$F[5]\t$F[8]\n";' > rawdata/genelists/hg38.hgnc.matched.txt

# Ask which genes have a pLI score:
scripts/matcher.pl -file1 rawdata/genelists/hg38.hgnc.matched.txt -col1 6 -file2 rawdata/genelists/hg19.all_genes_with_pli.txt -r | perl -ane 'chomp $_; @F = split("\t", $_); print "$F[8]\t$F[9]\t$F[10]\t$F[11]\t$F[12]\t$F[13]\t$F[0]\t$F[7]\n";' > rawdata/genelists/hg38.all_genes_with_pli.txt

# Ask which genes have a sHET score:
scripts/matcher.pl -file1 rawdata/genelists/hg38.hgnc.matched.txt -col1 6 -file2 rawdata/genelists/hg19.all_genes_with_shet.txt -r | perl -ane 'chomp $_; @F = split("\t", $_); print "$F[8]\t$F[9]\t$F[10]\t$F[11]\t$F[12]\t$F[13]\t$F[0]\t$F[7]\n";' > rawdata/genelists/hg38.all_genes_with_shet.txt

# There is a fairly large caveat here, which is that I label the genes with their Hg19 ENSG ID so that I can be consistant in my R code below!!! This does't impact too many genes, they mostly have the same IDs (~2-300)
# This gets a translatable list to hg19 ENSG###:
perl -ne 'chomp $_; @F = split("\t", $_); print "$F[0]\t$F[6]\n";' rawdata/genelists/hg38.all_genes_with_pli.txt > rawdata/genelists/hg38_to_hg19_ENSG.txt
perl -ne 'chomp $_; @F = split("\t", $_); print "$F[0]\t$F[6]\n";' rawdata/genelists/hg38.all_genes_with_shet.txt >> rawdata/genelists/hg38_to_hg19_ENSG.txt
sort rawdata/genelists/hg38_to_hg19_ENSG.txt | uniq > rawdata/genelists/hg38_to_hg19_ENSG.2.txt
mv rawdata/genelists/hg38_to_hg19_ENSG.2.txt rawdata/genelists/hg38_to_hg19_ENSG.txt 
```

### Disease Genes

This section of the document is not evaluated, as we need to acquire disease gene resources from three locations. The actual acquisition of these files is trivial, but did not want to attempted to make reproduceable due to potential links breaking. If this section needs to be reproduced, download the resources at the _rough_ following locations and run the code in this section. Otherwise, move to the next section where the file produced by this section has already been generated. Locations to place necessary files and file dates used in the manuscript are listed below:

1. Clinvar - https://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh37/archive_2.0/2019/clinvar_20191003.vcf.gz
    +  `rawdata/genelists/clinvar.vcf.gz`
    +  date: October 3, 2019
2. DDG2P - http://www.ebi.ac.uk/gene2phenotype/downloads/DDG2P.csv.gz
    +  `rawdata/genelists/DDG2P.csv`
    +  date: November 12, 2019
3. OMIM - https://www.omim.org/downloads
    +  `rawdata/genelists/morbidmap.txt`
    +  date: October 8, 2019

**Note**: To download OMIM morbid map you will need to register and place a copy of this file at: `rawdata/genelists/morbidmap.txt`

```{r Process Disease Genes, eval = F}
## Clinvar
clinvarVCFfiltered <- read_tsv("rawdata/genelists/clinvar.vcf.gz", comment = '#', col_names = F, col_types = 'cccccccccccccc') %>% 
  mutate(PHEN = str_remove(str_extract(X8, 'CLNDN=[^;]*;'), "CLNDN=")) %>% 
  mutate(PHEN = str_remove(PHEN, "not_provided")) %>% 
  mutate(PHEN = str_remove(PHEN, "|")) %>%
  mutate(PHEN = str_remove(PHEN, ";")) %>%
  filter(PHEN != '') %>% 
  mutate(GENE = str_remove(str_extract(X8, 'GENEINFO=[^;]*:'), "GENEINFO=")) %>% 
  #mutate(GENE = str_remove(GENE, ":")) %>% 
  mutate(CLNSIG = str_remove(str_extract(X8, 'CLNSIG=[^;]*;'), "CLNSIG=")) %>% 
  filter(CLNSIG %in% c("Pathogenic/Likely_pathogenic;", "Pathogenic;", "Likely_pathogenic;")) %>% 
  mutate(CLNSIG = str_remove(CLNSIG, ";")) %>% 
  mutate(ID = X3) %>% 
  select(c(X1,X2,ID, PHEN, GENE, CLNSIG)) %>% 
  drop_na(PHEN, GENE) 
clinvarGenes <- clinvarVCFfiltered %>% 
  select(GENE) %>% 
  distinct() %>% 
  transform(GENE = strsplit(GENE, "\\|")) %>%
  unnest(GENE) %>% 
  mutate(GENE = gsub(":.*", "", GENE))
clinvarGenes <- data.table(clinvarGenes)

## DDG2P
ddg2p <- fread("rawdata/genelists/DDG2P.csv") %>% 
  rename(hgnc_id = `hgnc id`)
develGenes <- ddg2p %>% 
  filter(`DDD category` %in% c("probable","confirmed","both DD and IF")) %>% 
  distinct(`hgnc_id`)
develGenes <- data.table(develGenes)

## OMIM
omimGenes <- read_tsv("rawdata/genelists/morbidmap.txt", skip = 4, comment = '#', col_types = 'ccic',
                      col_names = c("Pheno", "Gene", "MIM_Number", "Cyto_Location")) %>%
  select(Pheno, Gene) %>%
  drop_na() %>%
  mutate(Gene = gsub(",.*", "", Gene)) %>%
  mutate(omim_nondisease = ifelse(grepl("\\[", Pheno), T,F)) %>%
  mutate(omim_complex = ifelse(grepl("\\{", Pheno), T,F)) %>%
  mutate(omim_provisional = ifelse(grepl("\\?", Pheno), T,F))
omimGenes <- omimGenes %>% 
  filter(!omim_complex & !omim_nondisease)
omimGenes <- data.table(omimGenes)

hgnc.to.ENSG <- fread("rawdata/genelists/hg19.coordinates.txt",fill=T)
setnames(hgnc.to.ENSG,names(hgnc.to.ENSG),c("hg19.GENE","chr","start","end","hgnc_id","hgnc.symbol"))

clinvarGenes <- unique(merge(clinvarGenes,hgnc.to.ENSG,by.x="GENE",by.y="hgnc.symbol"))
develGenes <- unique(merge(develGenes,hgnc.to.ENSG,by="hgnc_id"))
omimGenes <- unique(merge(omimGenes[,c("Gene")],hgnc.to.ENSG,by.x="Gene",by.y="hgnc.symbol"))

diseaseGenes <- bind_rows(clinvarGenes[,c("hg19.GENE")],develGenes[,c("hg19.GENE")],omimGenes[,c("hg19.GENE")])
diseaseGenes <- unique(diseaseGenes)

write.table(diseaseGenes, "rawdata/genelists/diseaseGenes.txt",col.names = F, row.names = F, quote = F, sep ="\t")

rm(ddg2p, develGenes, omimGenes, clinvarVCFfiltered, clinvarGenes, hgnc.to.ENSG, diseaseGenes)
```

### Male Infertility Genes

This is a list of genes confirmed as playing a role in male infertility from [Manon Oud and Joris Veltman](https://academic.oup.com/humrep/article/34/5/932/5377831). We download and process the data direct from thier supplement (Table S3-S6):

**Note**: I have no idea if the link below will work for everyone. If it doesn't, download "Supplementary Table 3-6" manually from [here](https://academic.oup.com/humrep/article/34/5/932/5377831#supplementary-data) and set the name of the file to `rawdata/genelists/male_infertility_genes.xlsx`

```{bash Get Male Infertility Genes, eval = F}

curl -L -o rawdata/genelists/male_infertility_genes.xlsx "https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/humrep/34/5/10.1093_humrep_dez022/2/dez022_supplementary_tables_siii_-_svi_final.xlsx?Expires=1591021841&Signature=Fs~qzUue5gM-9WRPnYlSzzQ1kQpryWdxzLqW1Yx74QHgzCVgGzeuNyf2ZhyqDRTUSmWoaPTHi-O~PXLJRsW~jsJKq8YVr-mGYlbJ9hb40YJIulotNzUiY1mIRYyS7MTvncojcWo9xwEfB~-KNeguJbfX7dv6f4RgDtHX1ne59zK9kueOK-jJRrzrW73Xb07JtMuGM3ChvbFAObx4-9cPg44U~JzEERrAoBZjkUuqt1tEQ2EM70Yy26FL-v34-P2nu3BtV3hulfWfk9dzdMP-hRupRkwfFJ3RaaWU5iboHwT9srQlRMEkJ0XHBp8MeeImXgFJAxzC3EPYhU4YgYpa7w__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA"

```

```{r Process Male Infertility Gene XLSX}

male.genes.xlsx <- data.table(read_xlsx("rawdata/genelists/male_infertility_genes.xlsx",sheet = "Supplementary Table SIV",skip=1))
male.genes.xlsx <- male.genes.xlsx[4:nrow(male.genes.xlsx)]
male.genes.xlsx <- male.genes.xlsx[,c("HGNC gene name","Inheritance pattern in human","Conclusion")]
male.genes.xlsx <- male.genes.xlsx[`HGNC gene name` != ""]
male.genes.xlsx <- male.genes.xlsx[Conclusion!="No evidence"]
male.genes.xlsx <- male.genes.xlsx[`Inheritance pattern in human`!= "XL" & `Inheritance pattern in human` != "YL"]

## Need to rename some genes as they used Hg38 gene IDs:
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="CATSPERE","C1orf101",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="CFAP43","WDR96",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="CFAP44","WDR52",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="CFAP69","C7orf63",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="DNAAF4","DYX1C1",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="DNAAF5","HEATR2",`HGNC gene name`)]

write.table(male.genes.xlsx,"rawdata/genelists/male_infertility_genes.txt",row.names=F,col.names=F,sep="\t",quote=F)

rm(male.genes.xlsx)
```

```{bash Annotate Male Infertility Genes}

scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -file2 rawdata/genelists/male_infertility_genes.txt -col1 5 -r | perl -ne 'chomp $_; @F = split("\t", $_); splice(@F, 4, 9); print join("\t", @F) . "\n";' > rawdata/genelists/male_infertility_genes.annotated.txt

```

```{bash Annotate Mouse Infertility Genes}

scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -file2 rawdata/genelists/mouse_infertility_genes.txt -col1 5 -r | perl -ne 'chomp $_; @F = split("\t", $_); splice(@F, 4, 9); print join("\t", @F) . "\n";' > rawdata/genelists/mouse_infertility_genes.annotated.txt

```

## 4B. Load Gene Lists For Phenotype Testing

### Generic Lists

This code block just loads our generic lists that we created above, namely:

1. Our hg19 -> hg38 conversion table
2. Table of all sHET values
3. Table of all pLI values

```{r Load Generic Lists}

## Load gene translation file
gene.translate <- fread("rawdata/genelists/hg38_to_hg19_ENSG.txt", header=F)
setnames(gene.translate,names(gene.translate),c("hg38.GENE","hg19.GENE"))

## Load sHET genes
shet.genes <- fread("rawdata/genelists/shet.hgnc.txt")
## Remember, we had to annotate sHET with hg38 gene IDs
setnames(shet.genes,names(shet.genes),c("hg19.GENE","GENE","sHET.val","HGNC.ID"))
shet.genes[,deciles:=cut(sHET.val,breaks=quantile(sHET.val,seq(0,1,by=0.1)),include.lowest = T)]
shet.genes[,sHET.val.binary:=cut(sHET.val,breaks=c(0,0.15,1),labels = c("lt_015","gt_015"),right = F)]

print(paste0("Total number of genes with sHET value                       : ", nrow(shet.genes)))
print(paste0("Total number of genes with sHET value in both hg19 and hg38 : ", nrow(merge(shet.genes,gene.translate))))

## Load Cassa sHET genes
shet.genes.cassa <- fread("rawdata/genelists/shet.cassa.hgnc.txt")
## Remember, we had to annotate sHET with hg38 gene IDs
setnames(shet.genes.cassa,names(shet.genes.cassa),c("hg19.GENE","GENE","sHET.val","HGNC.ID"))

## Load pLI genes:
pli.genes <- fread("rawdata/genelists/hg19.all_genes_with_pli.txt")
pli.genes <- pli.genes[,c("V1","V6","V8","V5")]
setnames(pli.genes, c("hg19.GENE","GENE","pLI.val","HGNC.ID"))
pli.genes[,pLI.val.binary:=cut(pLI.val,breaks=c(0,0.9,1),labels = c("lt_09","gt_09"),right = F)]

## Generate lists for phenotype testing:
gene.lists <- list()
gene.lists["highPLI"] = list(pli.genes[pLI.val >= 0.9,hg19.GENE])
gene.lists["highsHET"] = list(shet.genes[sHET.val >= 0.15,hg19.GENE])

```

#### UKBB Unmapped Regions

It was [recently identified](https://onlinelibrary.wiley.com/doi/full/10.1111/ahg.12383) that the UKBB data was not aligned properly and as such has several genes without any variants. Purpose of this code is to check which genes these are based on a list of "affected" baits given by the UKBB team.

**Note**: This code requires bedtools to be installed and in your PATH.

```{bash Get Bad Genes}
## Note -- this may break if you do not have one of these files!
source ~/.bash_profile
source ~/.bashrc

## This gets a list of baits that are affected by the issues in UKBB
curl -o rawdata/ukbb_missing_baits/xgen_plus_spikein_b38_alt_affected.bed biobank.ctsu.ox.ac.uk/crystal/crystal/auxdata/xgen_plus_spikein_b38_alt_affected.bed

## Need to make a bed file of the genes that are available in Hg38
perl -ane 'chomp $_; print "$F[1]\t$F[2]\t$F[3]\t$F[0]\n";' rawdata/genelists/hg38.all_genes_with_pli.txt > rawdata/ukbb_missing_baits/hg38.genes.bed

## Count the total number of times a gene has a missing bait
/usr/bin/env bedtools intersect -c -a rawdata/ukbb_missing_baits/hg38.genes.bed -b rawdata/ukbb_missing_baits/xgen_plus_spikein_b38_alt_affected.bed > rawdata/ukbb_missing_baits/intersected.txt

## Convert gene IDs to Hg19
scripts/matcher.pl -file1 rawdata/genelists/hg38_to_hg19_ENSG.txt -file2 rawdata/ukbb_missing_baits/intersected.txt -col2 3 -r > rawdata/ukbb_missing_baits/intersected.hg19.txt
```

```{r Check Affected Baits, fig.height=4, fig.width=8}

new.baits <- fread("rawdata/ukbb_missing_baits/intersected.hg19.txt")
setnames(new.baits,names(new.baits),c("chr","start","end","hg38.GENE","baits.hit","hg19.GENE","hg19.GENE.2"))
new.baits[,affected:=baits.hit>0]
new.baits[,dummy:=1]

ggplot(new.baits,aes(baits.hit)) + geom_histogram(binwidth=1) + scale_y_log10(name="# of Genes") + scale_x_continuous(name="Total Baits Affected") + theme

## This is the list of bad genes in Hg19 IDs!
bad.genes <- new.baits[baits.hit>0,hg19.GENE]

## Are some Shet gene groups enriched for bad genes?
shet.genes[,bad.gene:=hg19.GENE %in% bad.genes]

shet.genes[,dummy:=1]
counts <- shet.genes[,list(sum(bad.gene),sum(dummy)),by=deciles]
setnames(counts,c("V1","V2"),c("bad.gene","all"))
counts[,pct:=bad.gene/all]

ggplot(shet.genes,aes(deciles,sHET.val,group=interaction(bad.gene,deciles),colour=bad.gene)) + geom_boxplot() + xlab("S.het Quintile") + scale_y_log10(name="S.het") + theme

ggplot(counts,aes(deciles,pct)) + geom_col(fill="blue",colour="black") + theme

## FET
counts <- shet.genes[,list(sum(bad.gene),sum(dummy)),by=sHET.val.binary]
setnames(counts,c("V1","V2"),c("bad.gene","all"))
counts[,all:=all-bad.gene]

shet.ft <- fisher.test(counts[,c("bad.gene","all")])
prop.table <- prop.table(as.matrix(counts[,c("bad.gene","all")]),margin=1)

## Print data for paper:
print(paste0("Number of sHET genes affected : ", nrow(shet.genes[bad.gene == T])))
print(paste0("Prop of ≥ 0.15 sHET           : ", sprintf("%0.1f",prop.table[2,1]*100), "%"))
print(paste0("Prop of < 0.15 sHET           : ", sprintf("%0.1f",prop.table[1,1]*100), "%"))
print(paste0("Fisher test p                 : ", sprintf("%0.2g",shet.ft$p.value)))

rm(counts, shet.ft, new.baits, prop.table)
```

### Disease Genes

```{r Load Disease Genes}

## Get a list of genes to exclude which are known OMIM/DD/ClinVar genes
disease.genes <- fread("rawdata/genelists/diseaseGenes.txt",header=F)
setnames(disease.genes,"V1","hg19.GENE")
print(paste0("Number of disease genes: ", nrow(disease.genes)))

```

### Male Infertility Genes

```{r Load Male Infertility Genes}
male.infertility.genes <- fread("rawdata/genelists/male_infertility_genes.annotated.txt",header=F)
setnames(male.infertility.genes,names(male.infertility.genes),c("GENE","inheritance","evidence","hg19.GENE"))

print(paste0("Number of male infertility genes: ", nrow(male.infertility.genes)))
```
### Mouse Infertility Genes

```{r Load Male Infertility Genes}
mouse.infertility.genes <- fread("rawdata/genelists/mouse_infertility_genes.annotated.txt",header=F)
setnames(mouse.infertility.genes,names(mouse.infertility.genes),c("GENE","hg19.GENE","chr","start"))

print(paste0("Number of mouse infertility genes: ", nrow(mouse.infertility.genes)))
```

## 4C. Gene Expression Data

This code just quickly downloads GTEx expression data (v7) from the [GTEx Consortium](https://gtexportal.org/home/datasets) and loads it into R so we can use it later.

```{bash Download GTEx}

curl -o rawdata/genelists/GTEx_Analysis_2016-01-15_v7_RNASeQCv1.1.8_gene_median_tpm.gct.gz https://storage.googleapis.com/gtex_analysis_v7/rna_seq_data/GTEx_Analysis_2016-01-15_v7_RNASeQCv1.1.8_gene_median_tpm.gct.gz
gunzip -f rawdata/genelists/GTEx_Analysis_2016-01-15_v7_RNASeQCv1.1.8_gene_median_tpm.gct.gz

```

```{r Load Gene Expression}
## GTEX expression data:
expression <- fread("rawdata/genelists/GTEx_Analysis_2016-01-15_v7_RNASeQCv1.1.8_gene_median_tpm.gct")
expression[,c("gene","vers"):=tstrsplit(gene_id,".",fixed=T),by=1:nrow(expression)]
setnames(expression,"gene","hg19.GENE")

## GTEx testis expression
expression.testis <- expression[,c("hg19.GENE","Testis")]

rm(expression)
```

## 4D. Variant Data

### SNV Data

#### Downloading Requisite Data From UKBB

Section tbd, but need to make sure to get two files:

1. Variant calls themselves: `rawdata/snvresources/counts.ukbb_wes.txt`
2. Field of 'has wes' from our derived data. I have already created a fake version at `rawdata/snvresources/has_exome.txt`

This data is not going to be available until final publication of the manuscript. This is due to guidelines from UK Biobank that do not allow returned data fields for studies not yet through peer review. We cannot make these calls available as part of this repository due to patient/subject protection.

```{bash Get SNVs, eval = F}



```

#### Annotating Rare Variants in UKBB

SNV and InDel annotation is handled by the document `SNVCalling_Filtering.Rmd` within this repository. Please see that document for details on how to perform SNV QC and annotation.

#### Build Data Files

This section does the actual loading of UKBB SNV data into R.

```{r Load SNV Data}

load.data <- function(counts.file, 
                      samples.file, 
                      indv.to.keep) {
  
  ## Read the counts file:
  variant.counts <- fread(counts.file)
  setnames(variant.counts,names(variant.counts),c("eid","gt","chr","pos","ref","alt","CADD","MPC","gnomadAF","VQSR","PEXT","CSQ","UKBB.AC","AN","UKBB.AF","AP","GENE","last_exon","last_intron"))
  
  ## Fix the sample IDs, which have a '_' in them. Have to do it this way otherwise it's insanely slow:
  ids <- unique(variant.counts[,c("eid")])
  ids[,eid.split:=str_split_fixed(eid,pattern = "_",n = 2)[1],by=1:nrow(ids)]
  variant.counts <- merge(variant.counts,ids,by="eid")
  variant.counts[,eid:=eid.split]
  variant.counts[,eid.split:=NULL]
  
  ## Set a variable in the table for SNV or INDEL
  variant.counts[,allele.type:=ifelse(nchar(ref)==nchar(alt),"SNV","INDEL")]
  
  ## Set gnomadAF to 0 if it was not found for a particular variant
  variant.counts[,gnomadAF:=ifelse(is.nan(gnomadAF),0,gnomadAF)]
  
  ## Need this because some samples might have 0 variants. (SYN should always have some...?)
  ## Will load a list of samples that we should expect to have and attaches the phenotype ID to them
  final.samples <- fread(samples.file)
  final.samples <- final.samples[has.exome==1]
  final.samples[,eid:=as.character(eid)]
  
  # Exclude/Include individuals/variants based on ancestry and relatedness
  variant.counts <- variant.counts[eid %in% indv.to.keep]
  final.samples <- final.samples[eid %in% indv.to.keep,c("eid")]
  
  ###!! FILTERING !!###
  ## Filter by CADD & MPC:
  variant.counts <- variant.counts[((CSQ == "LOF_HC" | (CSQ == "MIS" & MPC > 2)) & CADD > 25) | (CSQ != "LOF_HC" & CSQ != "MIS")]

  ## Get rid of last exon LoFs:
  variant.counts <- variant.counts[(CSQ == "LOF_HC" & last_exon == F & last_intron == F) | (CSQ != "LOF_HC")]
  
  ## Filter by gnomAD MAF:
  variant.counts <- variant.counts[gnomadAF < 0.001]
  
  ## Filter by PEXT:
  # Only filter by PEXT for allosomes -- hemizygous genes do not use PEXT
  variant.counts <- variant.counts[((chr == "X" | chr == "Y") & PEXT >= 0) | PEXT >= 0.1]
  
  ## Filter by allele missingness:
  variant.counts <- variant.counts[AN >= AP/2]
  ###!! FILTERING !!###

  return(list(variant.counts,final.samples))
  
}

# UKBB/Hg38
counts.file <- "rawdata/snvresources/counts.ukbb_wes.txt"
samples.file <- "rawdata/snvresources/has_exome.txt"
indv.to.keep <- paste0(UKBB.phenotype.data[,eid])

## The weird paste is because of how sampleIDs are represented in the variants table
data.UKBB <- load.data(counts.file,samples.file,indv.to.keep)
variants.UKBB <- data.UKBB[[1]]
samples.UKBB <- data.UKBB[[2]]
rm(data.UKBB)

## Translate geneIDs from Hg38 to Hg19
variants.UKBB <- merge(variants.UKBB,gene.translate,by.x = "GENE",by.y = "hg38.GENE",all.x=T)
variants.UKBB[,GENE:=hg19.GENE]
variants.UKBB[,hg19.GENE:=NULL]

rm(indv.to.keep, counts.file, samples.file)
```

#### Plotting Various Counts

Just plotting some simple variant count diagrams for QC purposes. This data will be used to make supplementary figures later.

```{r Plotting Variant Totals, fig.height=4, fig.width=6}

count.variants <- function(variant.counts,samples,af.cutoff) {

  counts.AC1 <- variant.counts[UKBB.AC == 1,sum(gt),by=c("eid","CSQ")]
  counts.AC1[,AF:="AC1"]
  counts.AF0.1 <- variant.counts[UKBB.AF < af.cutoff,sum(gt),by=c("eid","CSQ")]
  counts.AF0.1[,AF:="AF0.1"]

  count.table <- bind_rows(counts.AC1,counts.AF0.1)

  samples.table <- data.table(crossing(samples=samples[,eid],CSQ=c("LOF_HC","MIS","SYN"),AF=c("AC1","AF0.1")))
  setnames(samples.table,"samples","eid")
  
  count.table <- merge(samples.table,count.table,by=c("eid","CSQ","AF"),all.x=T)
  count.table[,V1:=ifelse(is.na(V1),0,V1)]
  
  setnames(count.table,"V1","count")
  
  return(count.table)
  
}

UKBB.counts <- count.variants(variants.UKBB,samples.UKBB,0.001)
UKBB.plot <- ggplot(UKBB.counts,aes(CSQ,count,colour=AF)) + geom_boxplot() + ggtitle("UKBB") + ylim(0,100) + theme.legend
UKBB.genes <- variants.UKBB[CSQ == "SYN" & UKBB.AF<=1e-3,sum(gt),by=GENE]
setnames(UKBB.genes,"V1","UKBB")

UKBB.plot

ggplot(UKBB.counts[AF=="AC1" & CSQ=="LOF_HC"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AC = 1 LoF Variants") + theme.legend
ggplot(UKBB.counts[AF=="AC1" & CSQ=="MIS"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AC = 1 Missense Variants") + theme.legend
ggplot(UKBB.counts[AF=="AC1" & CSQ=="SYN"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AC = 1 Synonymous Variants") + theme.legend

ggplot(UKBB.counts[AF=="AF0.1" & CSQ=="LOF_HC"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AF < 0.001 LoF Variants") + theme.legend
ggplot(UKBB.counts[AF=="AF0.1" & CSQ=="MIS"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AF < 0.001 Missense Variants") + theme.legend
ggplot(UKBB.counts[AF=="AF0.1" & CSQ=="SYN"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AF < 0.001 Synonymous Variants") + theme.legend + xlim(0,200)

rm(UKBB.plot)
```

#### Variant Totals / Individual / Gene Group

This is where we make the variant count totals for each individual for the purposes of phenotype testing. This first code block is for simple gene lists (high pLI/sHET) where we just count total number of variants.

```{r Total Number of Variants Per Gene Category}

get.gene.counts.snvs <- function(data, samples, maf) {
    
    variants <- data.table(crossing(sample_id=samples[,eid],type=c("LOF_HC","SYN","MIS")))
    
    ## This handles the high pLI/sHET lists:
    for (gene.list in names(gene.lists)) {
    
      current.genes <- get(gene.list,gene.lists)
      
      ## Filter on frequency cutoff and gene list
      if (maf == 0) {
        counts <- data[UKBB.AC == 1 & GENE %in% current.genes & chr!="X" & chr!="Y",sum(gt),by=c("eid","CSQ")]
      } else {
        counts <- data[UKBB.AF <= maf & GENE %in% current.genes & chr!="X" & chr!="Y",sum(gt),by=c("eid","CSQ")]
      }
      
      variants <- merge(variants,counts,by.x=c("sample_id","type"),by.y=c("eid","CSQ"),all.x=T)
      variants[,V1:=if_else(is.na(V1),0L,V1)]
      setnames(variants,"V1",gene.list)
      
    }
    
    variants[,allele.freq:=maf]
    setcolorder(variants,c(names(variants)[-grep("type",names(variants))],c("type")))
    return(variants)
}

snv.counts <- bind_rows(get.gene.counts.snvs(variants.UKBB,samples.UKBB,0),
                        get.gene.counts.snvs(variants.UKBB,samples.UKBB,1e-3))

```

And this code block does the calculation for s~het~ listed in the manuscript:

$$s_{het[i,v]}=1-\prod_{g} (1-s_{het[i,v,g]})$$

```{r Quantitative sHET SNV Calculation}

quantify.shet.snv <- function(maf, type, to.remove=c()) {
    
    ## Filter on frequency cutoff and gene list
    if (maf == 0) {
      returned <- variants.UKBB[UKBB.AC == 1 & chr!="X" & chr!="Y" & CSQ == type & !GENE %in% to.remove]
    } else {
      returned <- variants.UKBB[UKBB.AF <= maf & chr!="X" & chr!="Y" & CSQ == type & !GENE %in% to.remove]
    }
    
    returned <- merge(returned,shet.genes[,c("hg19.GENE","sHET.val")],by.x="GENE",by.y="hg19.GENE")
    returned <- returned[,list(1-prod(1-sHET.val)),by="eid"]

    setnames(returned,c("eid","V1"),c("sample_id","product_sHET"))
    returned[,allele.freq:=maf]
    returned[,type:=type]
    
    return(returned)

}

## First do regular sHET list
quants <- data.table()
shet.quant.table <- data.table(crossing(allele.freq=unique(snv.counts[,allele.freq]),type=unique(snv.counts[,type])))

for (i in c(1:nrow(shet.quant.table))) {
  
  returned <- quantify.shet.snv(shet.quant.table[i,allele.freq],
                                shet.quant.table[i,type])

  returned[,allele.freq:=shet.quant.table[i,allele.freq]]
  returned[,type:=shet.quant.table[i,type]]
  
  quants <- bind_rows(quants,returned)
  
}

snv.counts <- merge(snv.counts,quants,by=c("sample_id","allele.freq","type"),all.x=T)
snv.counts[,product_sHET:=if_else(is.na(product_sHET),0,product_sHET)]

## Then do male infertility list
quants <- data.table()
shet.quant.table <- data.table(crossing(allele.freq=unique(snv.counts[,allele.freq]),type=unique(snv.counts[,type])))

for (i in c(1:nrow(shet.quant.table))) {
  
  returned <- quantify.shet.snv(shet.quant.table[i,allele.freq],
                                shet.quant.table[i,type],
                                male.infertility.genes[,hg19.GENE])

  returned[,allele.freq:=shet.quant.table[i,allele.freq]]
  returned[,type:=shet.quant.table[i,type]]
  
  quants <- bind_rows(quants,returned)
  
}

setnames(quants,c("product_sHET"),c("product_sHET_no_male_infertility"))

snv.counts <- merge(snv.counts,quants,by=c("sample_id","allele.freq","type"),all.x=T)
snv.counts[,product_sHET_no_male_infertility:=if_else(is.na(product_sHET_no_male_infertility),0,product_sHET_no_male_infertility)]

## Then do no disease list
quants <- data.table()
shet.quant.table <- data.table(crossing(allele.freq=unique(snv.counts[,allele.freq]),type=unique(snv.counts[,type])))

for (i in c(1:nrow(shet.quant.table))) {
  
  returned <- quantify.shet.snv(shet.quant.table[i,allele.freq],
                                shet.quant.table[i,type],
                                disease.genes[,hg19.GENE])

  returned[,allele.freq:=shet.quant.table[i,allele.freq]]
  returned[,type:=shet.quant.table[i,type]]
  
  quants <- bind_rows(quants,returned)
  
}

setnames(quants,c("product_sHET"),c("product_sHET_no_disease"))

snv.counts <- merge(snv.counts,quants,by=c("sample_id","allele.freq","type"),all.x=T)
snv.counts[,product_sHET_no_disease:=if_else(is.na(product_sHET_no_disease),0,product_sHET_no_disease)]

## Then do no mouse infertility list
quants <- data.table()
shet.quant.table <- data.table(crossing(allele.freq=unique(snv.counts[,allele.freq]),type=unique(snv.counts[,type])))

for (i in c(1:nrow(shet.quant.table))) {
  
  returned <- quantify.shet.snv(shet.quant.table[i,allele.freq],
                                shet.quant.table[i,type],
                                mouse.infertility.genes[,hg19.GENE])

  returned[,allele.freq:=shet.quant.table[i,allele.freq]]
  returned[,type:=shet.quant.table[i,type]]
  
  quants <- bind_rows(quants,returned)
  
}

setnames(quants,c("product_sHET"),c("product_sHET_no_mouse_infertility"))

snv.counts <- merge(snv.counts,quants,by=c("sample_id","allele.freq","type"),all.x=T)
snv.counts[,product_sHET_no_mouse_infertility:=if_else(is.na(product_sHET_no_mouse_infertility),0,product_sHET_no_mouse_infertility)]


rm(quants,shet.quant.table,returned)
```

And finally calculate product s~het~ for values derived from Cassa et al.

```{r old shet}

quantify.shet.snv <- function(maf, type, to.remove=c()) {
    
    ## Filter on frequency cutoff and gene list
    if (maf == 0) {
      returned <- variants.UKBB[UKBB.AC == 1 & chr!="X" & chr!="Y" & CSQ == type & !GENE %in% to.remove]
    } else {
      returned <- variants.UKBB[UKBB.AF <= maf & chr!="X" & chr!="Y" & CSQ == type & !GENE %in% to.remove]
    }
    
    returned <- merge(returned,shet.genes.cassa[,c("hg19.GENE","sHET.val")],by.x="GENE",by.y="hg19.GENE")
    returned <- returned[,list(1-prod(1-sHET.val)),by="eid"]

    setnames(returned,c("eid","V1"),c("sample_id","product_sHET"))
    returned[,allele.freq:=maf]
    returned[,type:=type]
    
    return(returned)

}

quants <- data.table()
shet.quant.table <- data.table(crossing(allele.freq=unique(snv.counts[,allele.freq]),type=unique(snv.counts[,type])))

for (i in c(1:nrow(shet.quant.table))) {
  
  returned <- quantify.shet.snv(shet.quant.table[i,allele.freq],
                                shet.quant.table[i,type])

  returned[,allele.freq:=shet.quant.table[i,allele.freq]]
  returned[,type:=shet.quant.table[i,type]]
  
  quants <- bind_rows(quants,returned)
  
}

setnames(quants,"product_sHET","product_sHET_old")

snv.counts <- merge(snv.counts,quants,by=c("sample_id","allele.freq","type"),all.x=T)
snv.counts[,product_sHET_old:=if_else(is.na(product_sHET_old),0,product_sHET_old)]

rm(quants,shet.quant.table,returned)
```

### CNV Data

For how CNV data was prepared prior to this step, please see the document `CNVCalling_and_Filtering.RMD` which handles all of the data collation and QC of CNVs. This section only deals with getting the result of that document into R and attaching/quantifying gene data. The ultimate outputs of that document read in here are:

1. Annotations for each CNV as created with VEP and custom perl script.
2. Individuals which actually have CNV data.
3. The CNVs themselves.

#### Downloading Requisite Data From UKBB

Section tbd, but need to make to get two files (and place at the following location):

1. Variant calls themselves: `rawdata/cnvresources/ukbb.cnvs.qcd.txt`
2. Field of 'has CNV data' from our derived data. I have already created a fake version at `rawdata/cnvresources/has_cnvs.txt`

This data is not going to be available until final publication of the manuscript. This is due to guidelines from UK Biobank that do not allow returned data fields for studies not yet through peer review. We cannot make these calls available as part of this repository due to patient/subject protection.

```{bash Get CNVs, eval = F}



```

#### Building R Annotations from VEP:

This file was created as part of CNV QC in the `CNVCalling_Filtering.Rmd` document. See that document for more information on how this file was generated and CNV annotation in general.

```{r Build Annotations, fig.height=4, fig.width=10}

## Get annotation information:
annotations<-fread("rawdata/cnvresources/cnv_vep_parsed.revision.sorted.bed")
setnames(annotations,names(annotations),c("chr","start","end","ct","genes","plis","shets","highPLI","highsHET","product_sHET","product_sHET_old","product_sHET_no_disease","product_sHET_no_male_infertility","product_sHET_no_mouse_infertility"))

# Add a matchable locus:
annotations[,locus:=paste0(chr,":",start,"-",end)]
```

#### Build Data Files

Have created a file that contains the merged loci for MAF calculation:

And using VEP annotated file as generated from `CNVCalling_Filtering.Rmd`

UKBB Samples dropped here are derived from a few different sources:

1. Those who failed CNV QC (n = 2,591 individuals)
2. They were part of a batch with no calls (currently only know of batch18 - n = 4,620)

All other individuals are included if they have broadly European ancestry and are unrelated (as set in the above 'Setting Individuals To Use' section).

```{r Build CNV Calls}

build.omics.map <- function(cnv.file, id.name, merge.key) {

  ## Get allele frequency information from CNVCalling_Filtering.Rmd:
  annotated.cnvs.qcd <- fread(cnv.file)
  annotated.cnvs.qcd[,eid:=as.character(eid)]
  
  # Add impact information
  annotated.cnvs.qcd <- merge(annotated.cnvs.qcd,annotations[,c("ct","genes","highPLI","highsHET","product_sHET","product_sHET_old","product_sHET_no_disease","product_sHET_no_male_infertility","product_sHET_no_mouse_infertility","locus")],by=c("locus","ct"))

  for (g in names(gene.lists)) {
    annotated.cnvs.qcd[,eval(g):=get(g)*gt]
  }

  return(annotated.cnvs.qcd)
  
}

## UKBB - I need to translate the IDs from George to Martin application as well:
ukbb.annotated.cnvs.qcd <- build.omics.map("rawdata/cnvresources/ukbb.cnvs.qcd.txt")

## Get individuals w/o any CNV data (regardless of QC)
has.cnv.data <- fread("rawdata/cnvresources/has_cnvs.txt")
has.cnv.data[,eid:=as.character(eid)]
```

#### Variant Totals / Individual / Gene Group

Doing it this way so all of my main association testing uses the exact same numbers!

```{r CNV Variant Totals}

## Set samples with Phenotype data
samples.UKBB.cnv <- UKBB.phenotype.data[,c("eid")]

## ... And remove bad arrays/missing data:
samples.UKBB.cnv <- samples.UKBB.cnv[eid %in% has.cnv.data[has_cnvs==1,eid]]

get.gene.counts.cnvs <- function (maf, type) {
  
  samp.size <- nrow(samples.UKBB.cnv)
  test <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score == T & ct == type]

  allele.frq <- test[ct==type,sum(gt),by=c("locus")]
  allele.frq[,frq:=V1/(samp.size*2)]
  setnames(allele.frq,"V1","ac")
  
  test <- merge(test,allele.frq[,c("locus","frq","ac")],by=c("locus"))
  
  g.names <- names(gene.lists)
  
  if (maf == 0) {
    test.counted <- test[ac == 1,lapply(.SD, sum),by="eid", .SDcols=g.names]
    test.counted.product <- test[ac == 1, list(1-prod(1-product_sHET),1-prod(1-product_sHET_old),1-prod(1-product_sHET_no_male_infertility),1-prod(1-product_sHET_no_disease),1-prod(1-product_sHET_no_mouse_infertility)),by="eid"]
  } else {
    test.counted <- test[frq <= maf,lapply(.SD, sum),by="eid", .SDcols=g.names]
    test.counted.product <- test[frq <= maf, list(1-prod(1-product_sHET),1-prod(1-product_sHET_old),1-prod(1-product_sHET_no_male_infertility),1-prod(1-product_sHET_no_disease),1-prod(1-product_sHET_no_mouse_infertility)),by="eid"]
  }
  
  setnames(test.counted.product,c("V1","V2","V3","V4","V5"),c("product_sHET","product_sHET_old","product_sHET_no_male_infertility","product_sHET_no_disease","product_sHET_no_mouse_infertility"))
  final.stats <- merge(samples.UKBB.cnv,test.counted,by="eid",all.x=T)
  final.stats <- merge(final.stats,test.counted.product,by="eid",all.x=T)
  final.stats[,allele.freq:=maf]
  final.stats[,type:=type]
  final.stats[is.na(final.stats)] <- 0
  
  setnames(final.stats,"eid","sample_id")
  
  return(final.stats)
  
}

cnv.counts <- bind_rows(get.gene.counts.cnvs(1e-3,"DEL"),
                        get.gene.counts.cnvs(0,"DEL"),
                        get.gene.counts.cnvs(1e-3,"DUP"),
                        get.gene.counts.cnvs(0,"DUP"))
```

### Combining All Variant Totals

```{r Combine Variants}

## Master table of ALL variants:
# Set SNV column order the same because of the quantification magic I have to do above:
setcolorder(snv.counts,neworder=names(cnv.counts))
variant.counts <- bind_rows(cnv.counts,snv.counts)

paste0("Number of individuals with CNV data: ", length(unique(variant.counts[type == "DEL" & allele.freq == 0,sample_id])))
paste0("Number of individuals with SNV data: ", length(unique(variant.counts[type == "LOF_HC" & allele.freq == 0,sample_id])))

rm(cnv.counts, snv.counts)
```

#### Burden of variants by Sex

Just to make sure sexes aren't burdened different between variant classes among highly constrained genes.

```{r Plotting Quant sHET, fig.height=5, fig.width=4}

## Sex specific burden:
sex.burden.calc <- function(t) {

  sex.specific <- variant.counts[allele.freq == 0 & type == t,c("sample_id","product_sHET")]
  sex.specific <- merge(sex.specific,UKBB.phenotype.data[,c("eid","sexPulse")],by.x="sample_id",by.y="eid")
  print(paste0("Number of Individuals w/",t,"s :", nrow(sex.specific)))

  sex.specific[,product_sHET.log:=log10(product_sHET)]
  ## Can do two tests, proportion in each sex with SOME sHET value, and actual testing burden of sHET
  print(wilcox.test(product_sHET.log ~ sexPulse, data = sex.specific))
  chi.sq <- matrix(c(nrow(sex.specific[product_sHET < 0.15 & sexPulse == 1]),
                     nrow(sex.specific[product_sHET < 0.15 & sexPulse == 2]),
                     nrow(sex.specific[product_sHET >= 0.15 & sexPulse == 1]),
                     nrow(sex.specific[product_sHET >= 0.15 & sexPulse == 2])),
                   nrow = 2,
                   dimnames = list(c("Male","Female"),c(paste0("No ",t),paste0("Has ", t))))

  prop <- prop.table(chi.sq,margin = 1)*100
  fisher <- fisher.test(chi.sq)
  
  format.text <- paste0(t, " ≥ 0.15 sHET Prop Male (", sprintf("%0.2f",prop[1,2]),"), Female (", sprintf("%0.2f",prop[2,2]),"), p = ", sprintf("%0.2f", fisher$p.value))
  print(format.text)
  return(format.text)

}

format.sex.burden.DEL <- sex.burden.calc("DEL")
format.sex.burden.DEL
format.sex.burden.PTV <- sex.burden.calc("LOF_HC")
format.sex.burden.PTV
```

### Add A Covariate for Having WES Data

Need this value in the UKBB Phenotype data.table to be able to filter out WES individuals when running Deletion models so that meta analysis isn't biased in anyway.

```{r add WES tag}
UKBB.phenotype.data[,has.wes:=eid %in% samples.UKBB[,eid]]
```

# 5. Variant Burden Impact on Traits

## 5A. Function for Linear Modeling

This code blob builds a function which does linear or logistic modeling for all my variant associations of the format:

$ phenotype \sim s_{het[i,v]} + age + age^2 + PC1..PC10 $

Where

$ s_{het[i,v]}$

is the s~het~ burden in individual $i$ for variant class $v$, where $v$ can be DEL, DUP, PTV, Missense, or Synonymous. This block has a number of flags to handle the differing cases we test (i.e. logistic vs linear model, removing all individuals without children, etc.).

```{r Linear Regression Function}

run.regression <- function(maf,
                           gene.list,
                           y.var,
                           sex,
                           variant.type,
                           binary,
                           add.covars = c(),
                           return.data = F,
                           remove.zeros = F,
                           remove.sequenced = T,
                           cutoff.high = F,
                           num.pcs = 30) {
 
  id.name <- "eid"
  
  cols.to.keep <- c("sample_id",gene.list)
  final.stats <- variant.counts[type == variant.type & allele.freq == maf,..cols.to.keep]

  if (cutoff.high == T & (variant.type == "DEL" | variant.type == "DUP" | variant.type == "LOF_HC")) {
    final.stats <- final.stats[get(gene.list) <= 3]
  }
  
  final.stats <- merge(final.stats,UKBB.phenotype.data,by.x="sample_id",by.y=id.name)
  
  ## Remove WES individuals from CNV analyses for meta-analysis purposes
  if (remove.sequenced == T & (variant.type == "DEL" | variant.type == "DUP")) {
    final.stats <- final.stats[has.wes == F]
  }
  
  ## Remove missing y.var data
  final.stats <- final.stats[!is.na(get(y.var))]
  if (remove.zeros == T) {
    final.stats <- final.stats[get(y.var)>0]
  }

  ## Do a model w/o sex
  if (sex == 1 | sex == 2) {
    final.stats <- final.stats[sexPulse == sex]
  }
  
  ## Set linear or logistic model
  if (binary == T) {
    fam <- "binomial"
    ## And force the phenotype to binary:
    final.stats[,binary.stat:=if_else(get(y.var) > 0,1,0)]
    y.var <- "binary.stat"
  } else {
    fam <- "gaussian"
  }
  
  ## Remove missing additional covar data
  add.covars <- unlist(add.covars)
  for (cov in add.covars) {
    final.stats <- final.stats[!is.na(get(cov))]
  }
  
  covariates <- c(gene.list,"agePulse.squared","agePulse","sexPulse",add.covars)
  if (num.pcs == 30) {
    covariates <- c(covariates,"PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10","PC11","PC12","PC13","PC14","PC15","PC16","PC17","PC18","PC19","PC20","PC21","PC22","PC23","PC24","PC25","PC26","PC27","PC28","PC29","PC30")
  } else {
    for (pc.num in c(1:num.pcs)) {
      covariates <- c(covariates, paste0("PC",pc.num))
    }
  }
    
  cov.string <- paste(covariates, collapse=" + ")
  formated.formula <- as.formula(paste(y.var, cov.string,sep=" ~ "))
  
  test.lm <- glm(formated.formula, data=final.stats, family=fam)
  coef.lm <- tidy(test.lm) %>% data.table()
  final.stats <- augment(test.lm) %>% data.table()

  total.hits <- final.stats[,sum(get(gene.list))]
  
  return(list(coef.lm[term==eval(gene.list),estimate],
    coef.lm[term==eval(gene.list),std.error],
    coef.lm[term==eval(gene.list),p.value],
    total.hits,
    nrow(final.stats)))
  
}
```

## 5B. Plotting Function

This is a plotting function for generating a nice formated plot for initial data visualization purposes. It isn't used for any main text/supplemental data or figures.

```{r Plotting Function, fig.height=7, fig.width=8}

plot.result <- function(data, binary, num.tests, ymin, ymax, y.lab) {

  plottable <- copy(data)
  ## This just makes it so the labels aren't 500 miles long:
  plottable[,gene.list.2:=factor(gene.list,
                                 levels=sort(unique(plottable[,gene.list])),
                                 labels=c(str_wrap(gsub("_"," ",gsub("\\."," ",sort(unique(plottable[,gene.list])))),width=20)))]
  
  ## Checks for significance:
  # Note: We did 140 total tests in UKBB-FI data if including both MAFs, both sexes, and all gene lists
  # I think 140 is a bit restrictive as the MAF tests are likely independent, so going with 70 tests (exclude MAF cutoffs from correction)
  sig.threshold <- 0.05/num.tests
  
  ## Confidence Intervals and significance
  if (binary == T) {
    ## Convert to OR (I don't think this should effect the original table...)
    plottable[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
    plottable[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
    plottable[,sig.pos:=if_else(var.beta<0,var.ci.lower-0.1,var.ci.upper+0.1)]
    
    plottable[,var.beta:=exp(var.beta)]
    ylab <- "Odds Ratio"
    yline <- 1

  } else {
    plottable[,var.ci.upper:=var.beta + (1.96*var.stderr)]
    plottable[,var.ci.lower:=var.beta - (1.96*var.stderr)]
    plottable[,sig.pos:=if_else(var.beta<0,var.ci.lower-0.05,var.ci.upper+0.05)]

    ylab <- "Effect Size"
    yline <- 0
  }
  
  ## Set Arrows!
  plottable[,var.ci.lower.symbol:=if_else(var.ci.lower<ymin,25,NaN)]
  plottable[,var.ci.lower:=if_else(var.ci.lower<ymin,ymin,var.ci.lower)]
  plottable[,var.ci.upper.symbol:=if_else(var.ci.upper>ymax,24,NaN)]
  plottable[,var.ci.upper:=if_else(var.ci.upper>ymax,ymax,var.ci.upper)]
  
  plottable[,sig:=if_else(var.p <= sig.threshold, "*", "")]
  
  plottable[,sex:=factor(sex,levels=c(1,2,3),labels=c("Male","Female","Both"))]
  
  betas <- ggplot(plottable,aes(x=gene.list.2,y=var.beta,group=interaction(sex,variant.type,maf),colour=variant.type,linetype=as.factor(maf),shape=as.numeric(sex)+16)) +
    geom_hline(aes(yintercept=yline),linetype=7,colour="red") +
    geom_point(position=position_dodge(width=1)) +
    scale_x_discrete(name="") +
    scale_y_continuous(name=ylab,limits = c(ymin,ymax)) +
    geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),position=position_dodge(width=1),width=0) +
    geom_text(aes(y=sig.pos,label=sig),position=position_dodge(width=1),size=10,hjust="middle") +
    geom_point(aes(y=var.ci.lower,shape=var.ci.lower.symbol,fill=variant.type),position=position_dodge(width=1)) +
    geom_point(aes(y=var.ci.upper,shape=var.ci.upper.symbol,fill=variant.type),position=position_dodge(width=1)) +
    ## This code which uses the 'unique' function is to keep it from breaking if Males aren't present
    scale_shape_identity(guide=guide_legend(title = "Sex"),breaks=as.numeric(unique(plottable[,sex])) + 16,labels=unique(plottable[,sex])) + 
    scale_color_discrete(guide="none") +
    scale_linetype_discrete(guide=guide_legend(title = "MAF Threshold")) +
    theme.legend + theme(axis.text.x = element_blank())
  
  counts <- ggplot(plottable,aes(gene.list.2,n.var,group=interaction(sex,variant.type,maf),fill=variant.type,linetype=as.factor(maf))) +
    geom_col(position=position_dodge(),colour="black") +
    scale_x_discrete(name="") +
    scale_y_log10(name=y.lab) +
    scale_fill_discrete(guide=guide_legend(title="Variant Type")) +
    scale_linetype_discrete(guide="none") +
    theme.legend +
    theme(axis.text.x=element_blank())
  
  plot <- (counts / betas) + plot_layout(heights=c(1,3),guides = "collect")
  
  plot
  
  return(plot)
  
}
```

## 5C. Fertility

### Main Regression

```{r Childlessness Regression, fig.height=7, fig.width=8}
results.fertility <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = c("product_sHET"),
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = F),by=1:nrow(results.fertility)]

plot.result(results.fertility,T,20,0,1.4, "# of Individuals\nWith sHET\n> 0.15")
```

### Additional Analyses

Note: I also tested if removing any CNV that overlaps the MHC locus (~chr6:29000000-33000000) changes the effect size. It did not. I don't have it documented here as it requires me to retool the code base and did not observe any change in effect. Likely reasons"

- Not many individuals have a rare variant that overlaps MHC (many have a variant but a lot are more common).
- HLA genes don't really have high s~het~ scores.
- Genes in this locus are more to do with the immune system. I believe our effect is going to be modulated more via neurodev/brain active genes.

#### Linear Model Instead of Logistic

This tests the relationship of s~het~ burden with actual number of children:

```{r Linear Childlessness Regression,  fig.height=7, fig.width=8}
results.fertility.linear <- data.table(crossing(maf = c(0.001,0),
                                     gene.list = "product_sHET",
                                     y.var = c("children.fathered","live.births"),
                                     variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility.linear[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.linear[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,F),by=1:nrow(results.fertility.linear)]

plot.result(results.fertility.linear,F,20,-1,0.5, "# of Individuals\nWith sHET\n> 0.15")
```

#### Using Gene Lists Instead of Quantitative sHET

```{r Gene List Regression, fig.height=7, fig.width=8}
results.fertility.genelists <- data.table(crossing(maf = c(0.001,0),
                                                   gene.list = names(gene.lists)[grep("highsHET|highPLI",names(gene.lists))],
                                                   y.var = c("children.fathered","live.births"),
                                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility.genelists[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.genelists[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,binary=T,cutoff.high = T),by=1:nrow(results.fertility.genelists)]

plot.result(results.fertility.genelists,T,70,0.5,1.2,"Total Number of\nVariants")

paste0("Number of DEL Individuals Lost, pLI ≥ 0.9  : ", results.fertility[variant.type == "DEL" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "DEL" & maf == 0 & gene.list == "highPLI",sum(n.indvs)])
paste0("Number of DEL Individuals Lost, sHET ≥ 0.9 : ", results.fertility[variant.type == "DEL" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "DEL" & maf == 0 & gene.list == "highsHET",sum(n.indvs)])

paste0("Number of PTV Individuals Lost, pLI ≥ 0.9  : ", results.fertility[variant.type == "LOF_HC" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "LOF_HC" & maf == 0 & gene.list == "highPLI",sum(n.indvs)])
paste0("Number of PTV Individuals Lost, sHET ≥ 0.9 : ", results.fertility[variant.type == "LOF_HC" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "LOF_HC" & maf == 0 & gene.list == "highsHET",sum(n.indvs)])

```

#### Cassa et al. s~het~

```{r cassa shet, fig.height=7, fig.width=8}

results.fertility.cassa <- data.table(crossing(maf = c(0.001,0),
                                               gene.list = c("product_sHET"),
                                               y.var = c("children.fathered","live.births"),
                                               variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility.cassa[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.cassa[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = F),by=1:nrow(results.fertility.cassa)]

plot.result(results.fertility.cassa,T,20,0,1.4, "# of Individuals\nWith Cassa sHET\n> 0.15")
```

#### Excluding Various Genes/Individuals

##### Individuals With >0 Children

```{r GT 0 Children Regression, fig.height=7, fig.width=8}
results.fertility.zero <- data.table(crossing(maf = c(0.001,0), 
                                   gene.list = "product_sHET",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility.zero[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.zero[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,F,remove.zeros = T),by=1:nrow(results.fertility.zero)]

plot.result(results.fertility.zero,F,20,-1,0.5,"# of Individuals\nWith sHET\n> 0.15")
```

##### Male Infertility Genes

```{r Exclude Male Infertility Genes, fig.height=7, fig.width=8}

results.excl.male <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET_no_male_infertility",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS"),
                                   quant = 0.15))
results.excl.male[,sex:=if_else(y.var=="children.fathered",1,2)]

results.excl.male[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.excl.male)]

plot.result(results.excl.male,T,70,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

##### Mouse Infertility Genes

```{r Exclude Mouse Infertility Genes, fig.height=7, fig.width=8}

results.excl.mouse <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET_no_mouse_infertility",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS"),
                                   quant = 0.15))
results.excl.mouse[,sex:=if_else(y.var=="children.fathered",1,2)]

results.excl.mouse[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.excl.mouse)]

plot.result(results.excl.mouse,T,70,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

##### Male Infertility Carriers

```{r No Male Infertility Carriers, fig.height=7, fig.width=8}

## Get individuals that carry a known pathogenic CNV
ukbb.has.male.infertility <- unique(c(hes.data.long[icd.category == "N46", eid],first.incidence.data[grepl("N46",code), eid]))

## Kind of have to do this in a weird way so that I don't have to change my function massively
variant.counts.backup <- copy(variant.counts)
variant.counts <- variant.counts[!sample_id %in% ukbb.has.male.infertility]

results.fertility.no.male.infertility <- data.table(crossing(maf = c(0.001,0),
                                                             gene.list = "product_sHET",
                                                             y.var = c("children.fathered","live.births"),
                                                             variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.fertility.no.male.infertility[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.no.male.infertility[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.fertility.no.male.infertility)]

plot.result(results.fertility.no.male.infertility,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")

## Restore the original file and delete the backup:
variant.counts <- copy(variant.counts.backup)
rm(variant.counts.backup)

## Total number of individuals with Male Infertility Coding:
paste0("# of Individuals with Male Infertility coding: ", length(ukbb.has.male.infertility))

```

##### Known Disease Genes

```{r Exclude Disease, fig.height=7, fig.width=8}

results.excl.disease <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET_no_disease",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.excl.disease[,sex:=if_else(y.var=="children.fathered",1,2)]

results.excl.disease[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.excl.disease)]

plot.result(results.excl.disease,T,70,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

##### Pathogenic CNV Carriers

```{r No Pathogenic Regression, fig.height=7, fig.width=8}

## Get individuals that carry a known pathogenic CNV
ukbb.path.carriers <- unique(ukbb.annotated.cnvs.qcd[path.locus != "null" & filter.0.95.wes.support.score == T, eid])

## Kind of have to do this in a weird way so that I don't have to change my function massively
variant.counts.backup <- copy(variant.counts)
variant.counts <- variant.counts[!sample_id %in% ukbb.path.carriers]

results.fertility.no.path <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.fertility.no.path[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.no.path[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.fertility.no.path)]

plot.result(results.fertility.no.path,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")

## Restore the original file and delete the backup:
variant.counts <- copy(variant.counts.backup)
rm(variant.counts.backup)

## Total number of individuals with path CNVs:
path.cnv.counts <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score == T & path.locus != "null"]

paste0("CNV Carriers account for ",sprintf("%0.1f",(length(unique(path.cnv.counts[,eid]))/nrow(samples.UKBB.cnv)*100)),"% (", length(unique(path.cnv.counts[,eid])),") of individuals.)")
```

#### Gene Expression in Testis

```{r Testis Expression, fig.height=5, fig.width=5}

dels.male <- ukbb.annotated.cnvs.qcd[ct == "DEL" & eid %in% samples.UKBB.cnv[,eid] & !eid %in% samples.UKBB[,eid] & filter.0.95.wes.support.score == T,c("eid","genes","locus","wes.support.score","gt")]

af <- dels.male[,sum(gt),by="locus"]
setnames(af,"V1","ac")
tot.samps <- nrow(samples.UKBB.cnv)
af[,af:=ac/(tot.samps*2)]

dels.male <- merge(dels.male,af,by="locus")
dels.male <- dels.male[ac == 1]

counts.dels <- data.table(table(dels.male[,unlist(genes)]))
setnames(counts.dels,c("V1","N"),c("hg19.GENE","N.del"))

counts.ptvs <- data.table(table(variants.UKBB[UKBB.AC==1 & CSQ == "LOF_HC" & eid %in% samples.UKBB[,eid],GENE]))
setnames(counts.ptvs,c("V1","N"),c("hg19.GENE","N.ptv"))

shet.genes.expr <- merge(shet.genes[,c("hg19.GENE","sHET.val","GENE")],expression.testis[,c("hg19.GENE","Testis")],by="hg19.GENE")
shet.genes.expr[,male.infertility:=hg19.GENE %in% male.infertility.genes[,hg19.GENE]]

shet.genes.expr <- merge(shet.genes.expr,counts.dels,by="hg19.GENE", all.x = T)
shet.genes.expr <- merge(shet.genes.expr,counts.ptvs,by="hg19.GENE", all.x = T)
shet.genes.expr[,N.del:=if_else(is.na(N.del),0L,N.del)]
shet.genes.expr[,N.ptv:=if_else(is.na(N.ptv),0L,N.ptv)]

shet.genes.expr[,has.del:=N.del>0]
shet.genes.expr[,has.ptv:=N.ptv>0]
shet.genes.expr[,log.mean:=log(Testis)]

## Has a Private DEL
ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(has.del), log.mean, group = as.factor(has.del))) + geom_boxplot() + scale_x_discrete(name = "Has a private DEL") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle(expression(s[HET]~`>`~0.15~Genes~Only)) + theme
wilcox.test(log.mean ~ has.del, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))

ggplot(shet.genes.expr, aes(as.factor(has.del), log.mean, group = as.factor(has.del))) + geom_boxplot() + scale_x_discrete(name = "Has a private DEL") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle("All Genes") + theme
wilcox.test(log.mean ~ has.del, data = shet.genes.expr,alternative=c("less"))

## Has a Private PTV
ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(has.ptv), log.mean, group = as.factor(has.ptv))) + geom_boxplot() + scale_x_discrete(name = "Has a private PTV") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle(expression(s[HET]~`>`~0.15~Genes~Only)) + theme
wilcox.test(log.mean ~ has.ptv, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))

ggplot(shet.genes.expr, aes(as.factor(has.ptv), log.mean, group = as.factor(has.ptv))) + geom_boxplot() + scale_x_discrete(name = "Has a private PTV") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle("All Genes") + theme
wilcox.test(log.mean ~ has.ptv, data = shet.genes.expr,alternative=c("less"))

## Is a male infertility gene
ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(male.infertility), log.mean, group = as.factor(male.infertility))) + geom_boxplot() + scale_x_discrete(name = "Is a male infertility gene") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle(expression(s[HET]~`>`~0.15~Genes~Only)) + theme
wilcox.test(log.mean ~ male.infertility, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))

ggplot(shet.genes.expr, aes(as.factor(male.infertility), log.mean, group = as.factor(male.infertility))) + geom_boxplot() + scale_x_discrete(name = "Is a male infertility gene") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle("All Genes") + theme
wilcox.test(log.mean ~ male.infertility, data = shet.genes.expr,alternative=c("less"))
```

#### Effect In Varying Age Groups

```{r Age Groupings, fig.height=4, fig.width=10}

res.age <- data.table()

for (i in c(40,50,60)) {

  age.remove <- UKBB.phenotype.data[agePulse < i | agePulse >= (i + 10),eid]
  
  ## Kind of have to do this in a weird way so that I don't have to change my function massively
  variant.counts.backup <- copy(variant.counts)
  variant.counts <- variant.counts[!sample_id %in% age.remove]
  
  results.fertility.age <- data.table(crossing(maf = c(0),
                                     gene.list = "product_sHET",
                                     y.var = c("children.fathered","live.births"),
                                     variant.type = c("DEL","LOF_HC"),
                                     age = i))
  
  results.fertility.age[,sex:=if_else(y.var=="children.fathered",1,2)]
  
  results.fertility.age[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.fertility.age)]
  
  res.age <- rbind(res.age,results.fertility.age[,c("var.beta","var.stderr","y.var","variant.type","age","n.indvs","var.p")])
  
  ## Restore the original file and delete the backup:
  variant.counts <- copy(variant.counts.backup)
  rm(variant.counts.backup)
  
}

for (i in c(40,50,60)) {
  
  for (a in c("children.fathered","live.births")) {
    
    meta.table <- res.age[age == i & y.var == a]
    
    meta.analy <- metagen(var.beta,
                          var.stderr,
                          studlab = variant.type,
                          method.tau = "SJ",
                          sm = "OR",
                          data = meta.table)

    res.age <- rbind(res.age,data.table(var.beta = meta.analy$TE.fixed,var.stderr = meta.analy$seTE.fixed,y.var = a,variant.type = "META",age = i, n.indvs=meta.table[,sum(n.indvs)],var.p=meta.analy$pval.fixed))
    
  }
  
}
  
res.age[,age:=as.character(age)]
## Actual results to compare against:
male <- results.fertility[sex == 1 & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC"),c("var.beta","var.stderr","y.var","variant.type","n.indvs","var.p")]
male[,age:="ALL"]
meta.analy.male <- metagen(var.beta,
                          var.stderr,
                          studlab = variant.type,
                          method.tau = "SJ",
                          sm = "OR",
                          data = male)

male <- rbind(male,data.table(var.beta = meta.analy.male$TE.fixed,var.stderr = meta.analy.male$seTE.fixed,y.var = "children.fathered",variant.type = "META",age = "ALL", n.indvs=male[,sum(n.indvs)],var.p=meta.analy.male$pval.fixed))

female <- results.fertility[sex == 2 & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC"),c("var.beta","var.stderr","y.var","variant.type","n.indvs","var.p")]
female[,age:="ALL"]
meta.analy.female <- metagen(var.beta,
                          var.stderr,
                          studlab = variant.type,
                          method.tau = "SJ",
                          sm = "OR",
                          data = female)

female <- rbind(female,data.table(var.beta = meta.analy.female$TE.fixed,var.stderr = meta.analy.female$seTE.fixed,y.var = "live.births",variant.type = "META",age = "ALL",n.indvs=female[,sum(n.indvs)],var.p=meta.analy.female$pval.fixed))

res.age <- rbind(res.age,female,male)

res.age[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
res.age[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
res.age[,var.beta:=exp(var.beta)]

ggplot(res.age, aes(age, var.beta, colour=variant.type, shape = y.var, group = interaction(variant.type,y.var))) + geom_point(position = position_dodge(0.5)) + geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),width=0.5,position = position_dodge(0.5)) + coord_flip() + xlab("Age") + ylab("Odds Ratio") + theme.legend

rm(male, female, meta.analy.female, meta.analy.male, age.remove)
```

#### PC Analysis

##### Variance Explained

```{r PCs}

phenotypes <- UKBB.phenotype.data[,c("eid","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10","PC11","PC12","PC13","PC14","PC15","PC16","PC17","PC18","PC19","PC20","PC21","PC22","PC23","PC24","PC25","PC26","PC27","PC28","PC29","PC30","agePulse.squared","agePulse","sexPulse","children.fathered","live.births")]
phenotypes <- merge(variant.counts[type == "DEL" & allele.freq == 0 & !sample_id %in% samples.UKBB[,eid],c("sample_id","product_sHET")], phenotypes, by.x = "sample_id",by.y = "eid")

phenotypes[,children:=if_else(sexPulse==1,children.fathered,live.births)]
phenotypes <- phenotypes[!is.na(children)]
phenotypes[,has.children:=if_else(children>0,1,0)]

covariates <- c("product_sHET","agePulse.squared","agePulse")

cov.string <- paste(covariates, collapse=" + ")
formated.formula <- as.formula(paste("has.children", cov.string,sep=" ~ "))

test.dt <- phenotypes[sexPulse == 1]

test.lm.init <- glm(formated.formula, data=test.dt, family="binomial")
coef.lm.init <- tidy(test.lm.init) %>% data.table()
nag.init <- nagelkerke(test.lm.init)

covariates <- c("product_sHET","agePulse.squared","agePulse","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10","PC11","PC12","PC13","PC14","PC15","PC16","PC17","PC18","PC19","PC20","PC21","PC22","PC23","PC24","PC25","PC26","PC27","PC28","PC29","PC30")
cov.string <- paste(covariates, collapse=" + ")
formated.formula <- as.formula(paste("has.children", cov.string,sep=" ~ "))

test.lm.pc30 <- glm(formated.formula, data=test.dt, family="binomial")
coef.lm.pc30 <- tidy(test.lm.pc30) %>% data.table()
nag.pc30 <- nagelkerke(test.lm.pc30, null = test.lm.init)

covariates <- c("product_sHET","agePulse.squared","agePulse","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")
cov.string <- paste(covariates, collapse=" + ")
formated.formula <- as.formula(paste("has.children", cov.string,sep=" ~ "))

test.lm.pc10 <- glm(formated.formula, data=test.dt, family="binomial")
coef.lm.pc10 <- tidy(test.lm.pc10) %>% data.table()
nag.pc10 <- nagelkerke(test.lm.pc10, null = test.lm.init)

paste0("Null R2: ",nag.init$Pseudo.R.squared.for.model.vs.null[3]*100)
paste0("10 PC R2: ", nag.pc10$Pseudo.R.squared.for.model.vs.null[3]*100)
paste0("30 PC R2: ", nag.pc30$Pseudo.R.squared.for.model.vs.null[3]*100)

pc.effects.table <- coef.lm.pc30[grepl("PC", term),c("term","estimate","std.error","p.value")]
setnames(pc.effects.table, names(pc.effects.table), c("PC","var.beta", "var.stderr", "var.p"))

pc.effects.table[,pc.num:=.I]
pc.effects.table[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
pc.effects.table[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
pc.effects.table[,sig.pos:=if_else(var.beta<0,var.ci.lower-0.1,var.ci.upper+0.1)]
pc.effects.table[,var.beta:=exp(var.beta)]



```

##### Separate PCs

*Note*: Remember, this doesn't work with the function `run.regression` as currently written. Will need to adjust that function or write new one when publishing.

```{r All PCs}

add.pcs <- c("PC10","PC11","PC12","PC13","PC14","PC15","PC16","PC17","PC18","PC19","PC20","PC21","PC22","PC23","PC24","PC25","PC26","PC27","PC28","PC29","PC30")

add.co <- list()
for (i in 1:21) {
  add.co[[i]] <- c(add.pcs[1:i])
}

results.pcs <- data.table(crossing(maf = 0,
                                   gene.list = "product_sHET",
                                   y.var = "children.fathered",
                                   variant.type = c("DEL","LOF_HC"),
                                   sex = 1,
                                   add.covars = add.co))
results.pcs[,num.pcs:=9+length(unlist(add.covars)),by=1:nrow(results.pcs)]

results.pcs[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = F,add.covars = add.covars, num.pcs = num.pcs),by=1:nrow(results.pcs)]

get.pc.meta.val <- function(n) {
  
  meta.table <- results.pcs[num.pcs == n]
  
  meta.analy.var <- metagen(var.beta,
                            var.stderr,
                            studlab = variant.type,
                            method.tau = "SJ",
                            sm = "OR",
                            data = meta.table)
  
  return(list(meta.analy.var$TE.fixed,
              meta.analy.var$seTE.fixed,
              meta.analy.var$pval.fixed
              ))
  
}

results.pcs.meta <- unique(results.pcs[,c("maf","gene.list","y.var","sex","num.pcs")])
results.pcs.meta[,c("var.beta","var.stderr","var.p"):=get.pc.meta.val(num.pcs),by=1:nrow(results.pcs.meta)]
results.pcs.meta[,PCs:=paste0("..PC",.I+9)]
results.pcs.meta[,PCs:=if_else(PCs == "..PC10","PC1..PC10",PCs)]

results.pcs.meta[,log.p:=-1*log(var.p,10)]
results.pcs.meta[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
results.pcs.meta[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
results.pcs.meta[,sig.pos:=if_else(var.beta<0,var.ci.lower-0.1,var.ci.upper+0.1)]
results.pcs.meta[,var.beta:=exp(var.beta)]
```


## 5D. Partner at Home

### Main Regression

```{r Partner Regression, fig.height=7, fig.width=8}
results.partner <- data.table(crossing(maf = c(0.001,0), 
                                   gene.list = "product_sHET",
                                   y.var = "partner.in.house",
                                   sex = c(1,2),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.partner[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.partner)]

plot.result(results.partner,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

## 5E. Cognition

### Main Regression

This code actually tests just overall effect on cognition if using my filter.

```{r Cognition Linear Regression, fig.height=7, fig.width=8}
## 0 is just my way of saying I only want singleton variants. I have code in the above function which handles it
results.cog <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = "fluid.intel",
                                   sex = c(1,2,3),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.cog[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,F),by=1:nrow(results.cog)]

plot.result(results.cog,F,20,-1.4,0.5,"# of Individuals\nWith sHET\n> 0.15")
```

## 5F. Educational Attainment

### Main Regression

```{r Educational Attainment Regression, fig.height=7, fig.width=8}
results.ea <- data.table(crossing(maf = c(0.001,0), 
                                  gene.list = "product_sHET",
                                  y.var = "completed.college",
                                  sex = c(1,2),
                                  variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.ea[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.ea)]

plot.result(results.ea,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

## 5G. Mental Health and ICD10

### Fertility Ratios

Here attempting to replicate the result from [Power et al](https://jamanetwork.com/journals/jamapsychiatry/article-abstract/1390257) which identified differential fertility rates among carriers/non carriers.

```{r Fertility Ratios, fig.height=8, fig.width=10}

fertility.ratios <- data.table(crossing(phenotype=gsub("hes.","",names(UKBB.phenotype.data)[grep("hes",names(UKBB.phenotype.data))]),
                                        sex=c(1,2),
                                        data.source=c("mhq","hes")))

calc.mean.fertility <- function(sex, phenotype, data.source) {
  
  if (phenotype == "infertility" & (sex == 2 | data.source == "mhq")) {
    return(list(1.0,1.0,1L,1.0,1.0,1L,1.0,0.0,0.0,1.0))
  } else {
    col <- paste(data.source,phenotype,sep=".") 
    if (sex == 1) {
      relevant.fertility <- "children.fathered"
    } else {
      relevant.fertility <- "live.births"
    }
    
    cols <- c(relevant.fertility,col,"agePulse","agePulse.squared","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")
    table.to.use <- UKBB.phenotype.data[sexPulse == sex &!is.na(get(col)) & !is.na(get(relevant.fertility)),..cols]
    
    covariates <- c("PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10","agePulse.squared","agePulse")
    
    cov.string <- paste(covariates, collapse=" + ")
    formated.formula <- as.formula(paste(relevant.fertility, cov.string,sep=" ~ "))
  
    test.lm <- glm(formated.formula, data=table.to.use, family="gaussian")
    resid.test <- augment(test.lm) %>% data.table()
    resid.test[,eval(col):=table.to.use[,get(col)]]
    setnames(resid.test,".fitted","fitted")
    resid.test[,corrected:=`.resid` - min(resid.test[,`.resid`])]
    formated.formula <- as.formula(paste("corrected",paste0("as.factor(",col,")"),sep=" ~ "))
    ratio.test <- ttestratio(formated.formula,data=resid.test,base=1)
  
    res <- table.to.use[,list(mean(get(relevant.fertility),na.rm=T),sd(get(relevant.fertility),na.rm=T)),by=col]
    return(list(res[get(col)==0,V1],
                res[get(col)==0,V2],
                nrow(UKBB.phenotype.data[sexPulse==sex & get(col) == 0]),
                res[get(col)==1,V1],
                res[get(col)==1,V1],
                nrow(UKBB.phenotype.data[sexPulse==sex & get(col) == 1]),
                ratio.test$estimate[3],
                ratio.test$conf.int[1],
                ratio.test$conf.int[2],
                ratio.test$p.value))
  }
}

fertility.ratios[,c("mean.children.unaffected","sd.children.unaffected","n.unaffected","mean.children.affected","sd.children.affected","n.affected","ratio","ci.lower","ci.upper","p.val"):=calc.mean.fertility(sex,phenotype,data.source),by=1:nrow(fertility.ratios)]

fertility.ratios[,sex:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]
test <- copy(fertility.ratios)
## Set Arrows!
test[,ci.lower.symbol:=if_else(ci.lower<0,25,NaN)]
test[,ci.lower:=if_else(ci.lower<0,0,ci.lower)]
test[,ci.upper.symbol:=if_else(ci.upper>1.4,24,NaN)]
test[,ci.upper:=if_else(ci.upper>1.4,1.4,ci.upper)]

test[,sig:=if_else(p.val <= 0.05/28, "*", "")]
test[,sig.pos:=if_else(ratio<1,ci.lower-0.03,ci.upper+0.03)]

test[,ratio:=if_else(phenotype == "infertility" & (sex == "Female" | data.source == "mhq"), NaN, ratio)]

mhq <- ggplot(test[data.source=="mhq"],aes(phenotype,ratio,group=sex,colour=sex)) +
  geom_point(position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymin=ci.lower,ymax=ci.upper),position=position_dodge(width=0.5),width=0.1) +    
  geom_text(aes(y=sig.pos,label=sig),position=position_dodge(width=0.8),size=5) +
  ylim(0,1.4) +
  geom_point(aes(y=ci.lower,shape=ci.lower.symbol,fill=sex),position=position_dodge(width=0.5)) +
  geom_point(aes(y=ci.upper,shape=ci.upper.symbol,fill=sex),position=position_dodge(width=0.5)) +
  scale_shape_identity() +
  theme.legend +
  ggtitle("MHQ") +
  coord_flip()

icd <- ggplot(test[data.source=="hes" & (phenotype == "scizo" | phenotype == "asd" | phenotype == "bipolar" | phenotype == "depression" | phenotype == "eating_disorders" | phenotype == "substance")],aes(phenotype,ratio,group=sex, colour=sex)) +
  geom_point(position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymin=ci.lower,ymax=ci.upper),position=position_dodge(width=0.5),width=0.1) +
  ylim(0,1.4) +
  geom_text(aes(y=sig.pos,label=sig),position=position_dodge(width=0.8),size=5) +
  theme.legend +
  geom_point(aes(y=ci.lower,shape=ci.lower.symbol,fill=sex),position=position_dodge(width=0.5)) +
  geom_point(aes(y=ci.upper,shape=ci.upper.symbol,fill=sex),position=position_dodge(width=0.5)) +
  scale_shape_identity() +
  ggtitle("HES") +
  coord_flip() +
  scale_x_discrete(name = "")
  # theme(axis.text.y=element_blank())

mhq + icd + plot_layout(guides = "collect")

rm(mhq,icd)
```

### Main Regressions

Conclusions from above are that the ICD-10 data is too sparse for us to be able to use it truly effectively. Also confirmed is that, in general, it also looks like the UKBB is healthier than the population as a whole (at least when comparing to Power et al.), which is a fairly obvious conclusion. With that in mind, we think we can only really do two different regressions:

* Binary of do you have a disability that has been previously shown to be associated with [rare variant burden](https://www.sciencedirect.com/science/article/pii/S0002929718301630)?:
    +  Schizophrenia, Autism, ADHD, Bipolar
    +  Also have ID/DD, but we don't have that here...
* Binary of do you have a disability that Power et al has shown to have <0.8 drop in fertility for either gender?:
    +  Schizophrenia, Autism, bipolar disorder, eating disorders

For the purposes of this manuscript, we have gone for the former, although both have similar results. This code block adds a binary value for having any of those phenotypes ('ganna.binary') to our primary phenotype table.

```{r MHQ regression, fig.height=7, fig.width=8}

## Calculate the 'Ganna' binary listed above:
UKBB.phenotype.data[,ganna.binary:=if_else(hes.scizo == 1 | hes.bipolar == 1 | hes.asd == 1 | hes.add == 1, 1, 0)]

results.mhq <- data.table(crossing(maf = c(0.001,0),
                                  gene.list = "product_sHET",
                                  y.var = c("ganna.binary"),
                                  sex = c(1,2),
                                  variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.mhq[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.mhq)]

plot.result(results.mhq,T,20,0,10,"# of Individuals\nWith sHET\n> 0.15")
```

### Additional Analyses

### Exploring Issues with MHQ Data

#### Only test non-carriers

See if we just remove MH patients from our model, do we still have an effect?

```{r Remove MH Patients, fig.height=7, fig.width=8}

mht.remove <- UKBB.phenotype.data[mhq.scizo == 1 | mhq.bipolar == 1 | mhq.asd == 1 | mhq.add == 1 | hes.scizo == 1 | hes.bipolar == 1 | hes.asd == 1 | hes.add == 1 | fi.scizo == 1 | fi.bipolar == 1 | fi.asd  ==  1 | fi.add == 1,eid]

## Kind of have to do this in a weird way so that I don't have to change my function massively
variant.counts.backup <- copy(variant.counts)
variant.counts <- variant.counts[!sample_id %in% mht.remove]


results.fertility.no.mhq <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility.no.mhq[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.no.mhq[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.fertility.no.mhq)]

plot.result(results.fertility.no.mhq,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")

## Restore the original file and delete the backup:
variant.counts <- copy(variant.counts.backup)
rm(variant.counts.backup)
```

#### Did Or Did Not Answer the MHQ

```{r Answered MHQ Regression, fig.height=7, fig.width=8}

results.answered.mhq <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = c("mhq.answered_mhq"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS"),
                                   sex = c(1,2)))

results.answered.mhq[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.answered.mhq)]

plot.result(results.answered.mhq,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

#### Has an email

```{r Email Regression, fig.height=8, fig.width=7}

results.email <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = c("has.email"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS"),
                                   sex = c(1,2)))

results.email[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.email)]

plot.result(results.email,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

### Association of ICD10 coding with childlessness

#### Loading the ICD-10 Tree

This code snippet just loads in the icd10 tree so we can build labels on our data.tables and figures.

```{r load icd10 tree}

## Load the ICD-10 tree
icd.codes <- fread("rawdata/phewas/icd10_tree.tsv")

## Factorize chapters for plotting
chapters <- c("I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV","XV","XVI","XVII","XVIII","XIX","XX","XXI","XXII")
chapters <- paste("Chapter", chapters, sep = " ")
chapters.table <- data.table(chapter=chapters)
chapters.table[,chapter:=factor(chapter,levels=chapters)]
chapters.table <- merge(chapters.table,icd.codes[grepl("Chapter",coding),c("coding","meaning")],by.x="chapter",by.y="coding")
chapters.table[,meaning:=str_remove(meaning,"Chapter\\s[XVI]*\\s")]
chapters.table[,meaning:=str_wrap(meaning,width=40)]
chapters.table[,meaning:=paste(chapter,meaning,sep=":\n")]
chapters.table[,rn:=str_remove(chapter,"Chapter ")]

```

#### Running Logistic Models

Going to just try a (relatively) naive approach at the moment based on the logic of [TreeWAS](https://www.nature.com/articles/ng.3926). This just means that not only do we test lower codes (like A00), but we also test groups of related codes (like A00-A09) and entire chapters (like Chapter I). For Hospital Episode Statistic (HES) data, we also test more specific codes (like A00.1) since that data has that granularity. For First Incidence (FI), they limited to the disease level (i.e. A00), so we just test at that level. In short, we are just running the model:

$$ has.children \sim s_{het[i,v]} + has.icd.code + age + age^2 + PC1..PC10 $$

Due to the necessity to separately test 19,194 separate codings/coding blocks, this method is split into three parts to allow for parallelization: 

1. Writing the input files
2. Running the actual jobs (with the script `./scripts/run_logistic_model.R`)
    + This script runs the primary logistic model defined above, as well as meta-analyses combined PTV and DEL results.
3. Reading back in and getting final tables for analysis.

##### Preparing Input Data

```{r PhewasModel, fig.height=6, fig.width=8}

## Save variants and Phenotype data that is the same for all data:
saveRDS(UKBB.phenotype.data, "rawdata/phewas/UKBB.phenotype.rdat")
saveRDS(variant.counts, "rawdata/phewas/variant_counts.rdat")

## Make HES Table:
# Convert individual level ICD data into format for TreeWAS-esque logit model:
disease.table <- hes.data.long[,c("eid","icd.code")]
# Add a dummy variable for age that will always be included so that we don't need two scripts for HES and FI codes.
disease.table[,age.at.incidence:=0]
saveRDS(disease.table,"rawdata/phewas/samples.hes.rdat")

## Make FI Table:
# Convert individual level ICD data into format for TreeWAS/logit model:
# Has to be a TSV here since that's what TreeWAS requires
disease.table <- first.incidence.data[,c("eid","code","age.at.incidence")]
setnames(disease.table,"code","icd.code")
saveRDS(disease.table,"rawdata/phewas/samples.fi.rdat")

```

##### Running Model Scripts

These are simply given as an exmaple of how these were run on the Sanger LSF cluster and are not intended to be run here. 

```{bash Run logit PheWAS, eval = F}

## HES Models:
bsub -q normal -M 2000 -o gridout/logistic.%J.%I -J 'LOG[1-19154]%500' './run_logistic_model.R rawdata/phewas/samples.hes.rdat 0 100 FALSE outfiles/'
cat outfiles/glm.*.out > glm.out

## FI Models:
bsub -q normal -M 2000 -o gridout_fi/logistic.%J.%I -J 'LOGFI[1-19154]%500' './run_logistic_model.R rawdata/phewas/samples.fi.rdat 0 100 TRUE outfiles_fi/'
cat outfiles_fi/glm.*.out > glm.fi.out

## And a model only incorperating disorders identified among young individuals via FI data:
bsub -q normal -M 2000 -o gridout_fi/logistic.%J.%I -J 'LOGFI[1-19154]%500' './run_logistic_model.R rawdata/phewas/samples.fi.rdat 0 20 TRUE outfiles_fi_young/'
cat outfiles_fi_young/glm.*.out > glm.fi_young.out
```

##### Loading Data

```{r icd}

build.ICD.table <- function(file) {
 
  data <- fread(file)

  setnames(data,names(data),c("coding","meaning","node_id","sex","variant.type","var.est","var.err","var.p","icd.est","icd.err","icd.p","N","N.cases","chapter","level"))
  
  data[,chapter:=factor(chapter,levels=chapters.table[,chapter],labels = chapters.table[,rn])]
  
  data[,var.err.upper:=exp(var.est + (1.96*var.err))]
  data[,var.err.lower:=exp(var.est - (1.96*var.err))]
  data[,var.or:=exp(var.est)]
  
  data[,icd.err.upper:=exp(icd.est + (1.96*icd.err))]
  data[,icd.err.lower:=exp(icd.est - (1.96*icd.err))]
  data[,icd.or:=exp(icd.est)]
  
  data[,var.p.log:=-1*log(var.p,10)]
  data[,icd.p.log:=-1*log(icd.p,10)]
  
  data[,meaning:=str_wrap(meaning,width=60)]
  
  ## This just adds a +/- value for which direction the OR is for plotting later
  data[,factor:=if_else(icd.est>0, 1, -1)]
  
  return(data)
   
}

## Load completed LMs
hes.analysis.table <- build.ICD.table("rawdata/phewas/glm.out")
fi.analysis.table <- build.ICD.table("rawdata/phewas/glm.fi.out")
fi.young.analysis.table <- build.ICD.table("rawdata/phewas/glm.fi_young.out")

```

#### Comparing Data Sources

```{r Comparing HES and FI data}

test <- merge(fi.analysis.table[level == 3 & variant.type == "META",c("coding","meaning","sex","chapter","var.p.log","icd.p.log")], hes.analysis.table[level == 3 & variant.type == "META",c("coding","meaning","sex","var.p.log","icd.p.log")], by = c("coding","sex","meaning"), suffixes = c(".fi",".hes"))

test <- merge(test,fi.young.analysis.table[level == 3 & variant.type == "META",c("coding","meaning","sex","var.p.log","icd.p.log")],by = c("coding","sex","meaning"))
setnames(test,c("var.p.log","icd.p.log"),c("var.p.log.fiyoung","icd.p.log.fiyoung"))

ggplot(test[sex == "MALE" & !is.na(var.p.log.fi)], aes(var.p.log.fi,var.p.log.hes,colour=chapter)) + 
  geom_point(size = 0.5) + 
  xlab("FI -log10 p.value") +
  ylab("HES -log10 p.value") +
  geom_text(data = test[sex == "MALE" & !is.na(var.p.log.fi) & var.p.log.fi < 8.1 & var.p.log.hes < 14], aes(label = meaning),size=2) +
  theme.legend
ggplot(test[sex == "MALE" & !is.na(var.p.log.fi)], aes(icd.p.log.fi,icd.p.log.hes,colour=chapter)) + 
  geom_point(size = 0.5) + 
  xlab("FI -log10 p.value") +
  ylab("HES -log10 p.value") +
  geom_text(data = test[sex == "MALE" & !is.na(var.p.log.fi) & icd.p.log.fi > 12], aes(label = meaning),size=2) +
  theme.legend

ggplot(test[sex == "MALE" & !is.na(var.p.log.fi)], aes(var.p.log.fi,var.p.log.fiyoung,colour=chapter)) + 
  geom_point(size = 0.5) + 
  xlab("FI -log10 p.value") +
  ylab("FI-Young -log10 p.value") +
  geom_text(data = test[sex == "MALE" & !is.na(var.p.log.fi) & var.p.log.fi < 8.1 & var.p.log.hes < 14], aes(label = meaning),size=2) +
  theme.legend
ggplot(test[sex == "MALE" & !is.na(var.p.log.fi)], aes(icd.p.log.fi,icd.p.log.fiyoung,colour=chapter)) + 
  geom_point(size = 0.5) + 
  xlab("FI -log10 p.value") +
  ylab("FI-Young -log10 p.value") +
  geom_text(data = test[sex == "MALE" & !is.na(var.p.log.fi) & (icd.p.log.fi > 12 | icd.p.log.fiyoung > 7)], aes(label = meaning),size=2) +
  theme.legend

ggplot(test[sex == "MALE" & !is.na(var.p.log.fi)], aes(var.p.log.fiyoung,var.p.log.hes,colour=chapter)) + 
  geom_point(size = 0.5) + 
  xlab("FI-Young -log10 p.value") +
  ylab("HES -log10 p.value") +
  geom_text(data = test[sex == "MALE" & !is.na(var.p.log.fi) & var.p.log.fiyoung < 8.1 & var.p.log.hes < 14], aes(label = meaning),size=2) +
  theme.legend
ggplot(test[sex == "MALE" & !is.na(var.p.log.fi)], aes(icd.p.log.fiyoung,icd.p.log.hes,colour=chapter)) + 
  geom_point(size = 0.5) + 
  xlab("FI-Young -log10 p.value") +
  ylab("HES -log10 p.value") +
  geom_text(data = test[sex == "MALE" & !is.na(var.p.log.fi) & (icd.p.log.fi > 12 | icd.p.log.fiyoung > 7)], aes(label = meaning),size=2) +
  theme.legend
```

#### Male Infertility Codes

```{r Male Infertility Codes, fig.height=5, fig.width=10}

columns <- c("coding","variant.type","var.or","var.err.lower","var.err.upper","var.p","icd.or","icd.err.lower","icd.err.upper","icd.p","N")

male.codings.fi <- fi.analysis.table[coding=="N46" & sex == "MALE",..columns]
male.codings.fi[,data:="FI"]

male.codings.icd <- hes.analysis.table[coding=="N46" & sex == "MALE",..columns]
male.codings.icd[,data:="ICD"]

male.codings <- rbind(male.codings.fi, male.codings.icd)

male.ors.plot <- ggplot(male.codings, aes(variant.type, icd.or, group = data, linetype = data)) +
  scale_x_discrete(name = "") +
  scale_y_continuous(name = "OR for the Impact of Having a\nMale Infertility Code (N46) on Childlessness") +
  geom_hline(yintercept = 1, colour = "red", linetype = 2) +
  geom_point(position = position_dodge(0.5), colour = sex.colours["Male"], size = 3) +
  geom_errorbar(aes(ymin = icd.err.lower, ymax = icd.err.upper),position = position_dodge(0.5), width = 0, colour = sex.colours["Male"], size = 1) +
  scale_linetype_discrete(guide=guide_legend(title="Data Source")) +
  coord_flip() + 
  theme.legend + theme(panel.grid.major.y=element_blank())
  
male.counts.plot <- ggplot(male.codings, aes(variant.type, N, group = data, linetype = data)) +
  scale_x_discrete(name = "") +
  scale_y_continuous(name = "# of Partic.") +
  geom_col(fill = sex.colours["Male"],position = position_dodge(0.5),width=0.5,size=1, colour = "black") +
  coord_flip() +
  scale_linetype_discrete(guide=guide_legend(title="Data Source")) +
  theme.legend + theme(panel.grid.major.y = element_blank(), axis.text.y = element_blank())
  
male.ors.plot + male.counts.plot + plot_layout(ncol = 2, widths = c(3,1), guides = 'collect')

```

#### Fertility for Only FI Individuals

Check to see if just using individuals with FI data (~50% of all UKB Participants) affects the affect size of our primary model of $ has.children \sim s_{het[i,v]} $.

```{r FI Only, fig.height=7, fig.width=8}
ukbb.FI.individuals <- UKBB.phenotype.data[has.first.incidence.data==T, eid]

## Kind of have to do this in a weird way so that I don't have to change my function massively
variant.counts.backup <- copy(variant.counts)
variant.counts <- variant.counts[sample_id %in% ukbb.FI.individuals]

results.fertility.FI.only <- data.table(crossing(maf = c(0.001,0),
                                                 gene.list = "product_sHET",
                                                 y.var = c("children.fathered","live.births"),
                                                 variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.fertility.FI.only[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.FI.only[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.fertility.FI.only)]

plot.result(results.fertility.FI.only,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")

## Restore the original file and delete the backup:
variant.counts <- copy(variant.counts.backup)
rm(variant.counts.backup)
```

## 5H. Household Income

### Main Regression

```{r household income, fig.height=7, fig.width=8}

## First do our standard linear model:
results.household.income <- data.table(crossing(maf = c(0.001,0),
                                        gene.list = "product_sHET",
                                        y.var = c("household.income"),
                                        sex = c(1,2),
                                        variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.household.income[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,F,add.covars = c("partner.in.house")),by=1:nrow(results.household.income)]

plot.result(results.household.income,F,20,-1.5,0.5,"# of Individuals\nWith sHET\n> 0.15")
```


## 5I. Same Sex Sexual Behaviour

### Main Regression

```{r same sex, fig.height=7, fig.width=8}

## First do our standard linear model:
results.same.sex <- data.table(crossing(maf = c(0.001,0),
                                        gene.list = "product_sHET",
                                        y.var = c("same.sex"),
                                        sex = c(1,2),
                                        variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.same.sex[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.same.sex)]

plot.result(results.same.sex,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

### Exclude

```{r Exclude same sex behaviour individuals}

ubb.same.sex <- unique(UKBB.phenotype.data[same.sex == 1, eid])

## Kind of have to do this in a weird way so that I don't have to change my function massively
variant.counts.backup <- copy(variant.counts)
variant.counts <- variant.counts[!sample_id %in% ubb.same.sex]

results.fertility.no.same.sex <- data.table(crossing(maf = c(0.001,0),
                                                     gene.list = "product_sHET",
                                                     y.var = c("children.fathered","live.births"),
                                                     variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.fertility.no.same.sex[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.no.same.sex[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.fertility.no.same.sex)]

plot.result(results.fertility.no.same.sex,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")

## Restore the original file and delete the backup:
variant.counts <- copy(variant.counts.backup)
rm(variant.counts.backup)

```

## 5J. Neutral Phenotypes

```{r Neutral Phenotypes, fig.height =7, fig.width=8}

results.fruit <- data.table(crossing(maf = c(0.001,0),
                                     gene.list = "product_sHET",
                                     y.var = c("fresh.fruit"),
                                     sex = c(1,2),
                                     variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.fruit[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,F),by=1:nrow(results.fruit)]

plot.result(results.fruit,F,20,-1,1, "# of Individuals\nWith sHET\n> 0.15")

results.handedness <- data.table(crossing(maf = c(0.001,0),
                                          gene.list = "product_sHET",
                                          y.var = c("handedness"),
                                          sex = c(1,2),
                                          variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.handedness[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.handedness)]

plot.result(results.handedness,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")

results.hair <- data.table(crossing(maf = c(0.001,0),
                                          gene.list = "product_sHET",
                                          y.var = c("is.blonde"),
                                          sex = c(1,2),
                                          variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.hair[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.hair)]

plot.result(results.hair,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")

```

# 6. Modulation of Traits by Variant Burden

This section of code is what was used to estimate the contribution of each of our measured traits to overall childlessness and fitness. We first determine the contribution of [Fertility Alone](#6c._fertility_alone) and then do the same for other traits except for household income (due to issues with how the trait was recorded).

Each section other than the first 4 include a subheading:

1. For estimating the effect of a trait on childlessness alone through a general linear model.
2. For estimating the effect of a trait on childlessness and overall fitness

**Note**: All plotting of estimated fitness is done when actually generating [Figures](#7._figures).

## 6A. Function for Testing Simple Regressions Via GLM

This section is used for all traits to address the simple regression of:

$ childlessness \sim phenotype+age+age^2+PC1..PC10 $

There is a flag in the function for excluding PCs. This is so that we can use the models generated by the function to estimate the contribution of phenotype to childlessness when we cannot simulate PCs due to too much complexity. All ORs/Effect sizes reported on the manuscript for the effect of a trait on childlessness include PCs and are calculated when creating the Supplementary Figure in which they are reported.

This will also return a 'fit model' for the expected trait that we can then feed into our simulations.

```{r simple lm function for childlessness x phenotype}

run.lm <- function(sex, x.var, add.covars=c(), inc.PCs = F) {

  if (sex == 1) {
    y.var <- "children.fathered"
  } else {
    y.var <- "live.births"
  }
  
  phenotypes <- UKBB.phenotype.data[sexPulse == sex & !is.na(get(y.var)) & !is.na(get(x.var))]
  
  ## Make sure none of our additional covariates are NA
  for (cov in add.covars) {
    if(grepl("\\*",cov) == F) {
      phenotypes <- phenotypes[!is.na(get(cov))]
    }
  }
  
  phenotypes[,binary.stat:=if_else(get(y.var) > 0,1,0)]
  
  covariates <- c(x.var,"agePulse.squared","agePulse",add.covars)
  if (inc.PCs == T) {
    covariates <- c(covariates,"PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")
  }
  cov.string <- paste(covariates, collapse=" + ")
  form <- as.formula(paste("binary.stat", cov.string,sep=" ~ "))

  test.lm <- glm(form, data=phenotypes[sexPulse == sex], family = "binomial")
  coef.lm <- tidy(test.lm) %>% data.table()
  resid.table <- augment(test.lm) %>% data.table()
  resid.table[,sexPulse:=sex]
  
  cols <- c(".resid",x.var,"sexPulse",add.covars[-grep("\\*",add.covars)])
  
  return(list(coef.lm[term==eval(x.var),estimate],
              coef.lm[term==eval(x.var),std.error],
              coef.lm[term==eval(x.var),p.value],
              list(resid.table[,..cols]),
              list(test.lm)))
  
}

```

## 6B. Calculating Base Fertility Statistics for UKBB Participants

This code just generates base-level statistics for individuals in the UK Biobank. It also includes some functions for calculating the expected number of individuals with a given trait at a specified odd ratio.

```{r Base Stats}

## Build an object of all base fertilities for Male and Female:
# 1. Base fertility only for individuals with children:
base.fertilities <- data.table(fertility = UKBB.phenotype.data[sexPulse == 1 & eid %in% variant.counts[,sample_id] & children.fathered > 0,mean(children.fathered)],inc.zero = F, sex = 1)
base.fertilities <- bind_rows(base.fertilities, data.table(fertility = UKBB.phenotype.data[sexPulse == 2 & eid %in% variant.counts[,sample_id] & live.births > 0,mean(live.births)],inc.zero = F, sex = 2))

# 2. Base fertility including all individuals:
base.fertilities <- bind_rows(base.fertilities, data.table(fertility = UKBB.phenotype.data[sexPulse == 1 & eid %in% variant.counts[,sample_id] & children.fathered >= 0,mean(children.fathered)], inc.zero = T, sex = 1))
base.fertilities <- bind_rows(base.fertilities, data.table(fertility = UKBB.phenotype.data[sexPulse == 2 & eid %in% variant.counts[,sample_id] & live.births >= 0,mean(live.births)], inc.zero = T, sex = 2))

## Base childlessness for all UKBB Participants
base.childlessness.male <- nrow(UKBB.phenotype.data[sexPulse == 1 & eid %in% variant.counts[,sample_id] & children.fathered == 0])/nrow(UKBB.phenotype.data[sexPulse == 1 & eid %in% variant.counts[,sample_id] & children.fathered >= 0])
base.childlessness.female <- nrow(UKBB.phenotype.data[sexPulse == 2 & eid %in% variant.counts[,sample_id] & live.births == 0])/nrow(UKBB.phenotype.data[sexPulse == 2 & eid %in% variant.counts[,sample_id] & live.births >= 0])

paste0("Base Childlessness Male             : ", sprintf("%0.1f",base.childlessness.male*100))
paste0("Base Childlessness Female           : ", sprintf("%0.1f",base.childlessness.female*100))

paste0("Base Children Among Males w/Child   : ", sprintf("%0.2f",base.fertilities[sex == 1 & inc.zero == F,fertility]))
paste0("Base Children Among Females w/Child : ", sprintf("%0.2f",base.fertilities[sex == 2 & inc.zero == F,fertility]))

paste0("Base Children Among Males          : ", sprintf("%0.2f",base.fertilities[sex == 1 & inc.zero == T,fertility]))
paste0("Base Children Among Females        : ", sprintf("%0.2f",base.fertilities[sex == 2 & inc.zero == T,fertility]))


## Array of ages to sample from:
ages <- UKBB.phenotype.data[eid %in% variant.counts[,sample_id], agePulse]

## Helper Functions:
calc.prop.indvs <- function(odds.ratio, healthy.ratio) {
  
  healthy.ratio / (odds.ratio + healthy.ratio)
  
}

simulate.proportion <- function(expected) {
  if (expected>=1) {
    return(0L)
  } else {
    return(rbinom(1,1,1-expected))
  }
}

```

## 6C. Fertility Alone

Here we estimate just the effect of s~het~ on childlessness and, through that estimate, overall fitness.

```{r Fertility Alone, fig.height=4, fig.width=12}

model.fertility <- data.table()

for (s in c(1,2)) {
  
  ## Get meta-anlysis OR from the original fertility LM that was calculated above in section 5C.
  meta.analy <- metagen(var.beta,
                        var.stderr,
                        studlab = variant.type,
                        method.tau = "SJ",
                        sm = "OR",
                        data = results.fertility[sex == s & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC")])
  
  ## Get actual proportion of individuals without a child 
  ## our data generated above
  if (s == 1) {
    stat <- "children.fathered"
    prop.affected <- base.childlessness.male
  } else {
    stat <- "live.births"
    prop.affected <- base.childlessness.female
  }
  
  ## This is just a constant denominator when calculating expected 
  ## childlessness via the function calc.prop.indvs()
  aff <- prop.affected/(1-prop.affected)
  
  ## Determine expected proportions of childlessness at various shet 
  ## values based on meta-analysis OR
  for (modifier in seq(0,1,by=0.1)) {
  
    ## Calculate value for the actual OR, as well as upper and lower confidence intervals
    for (place in c("mid","lower","upper")) {
      
      ## Just modifies the actual OR (actual or upper/lower CI) that 
      ## will be used to get expected proportion of childlessness
      if (place == "mid") {
        or <- exp(meta.analy$TE.fixed*modifier)
      } else if (place == "upper") {
        or <- exp((meta.analy$TE.fixed + (1.96*(meta.analy$seTE.fixed))) * modifier)
      } else if (place == "lower") {
        or <- exp((meta.analy$TE.fixed - (1.96*(meta.analy$seTE.fixed))) * modifier)
      }
      
      ## Get proportion of individuals that are childless based off the OR
      prop.shet <- calc.prop.indvs(or, aff)
      # This works because we know that individuals w/o children are 0 and individuals with children do
      # not deviate from the population mean (see subsection in Fertility - Only Individuals With >0 Children)
      # So we obviously don't have to do (prop.shet * 0) + (1-prop.shet * base.fertility) since 0 * anything == 0 
      # (duh... but here since my brain forgot that for a second and got nervous that I did something wrong) 
      mean.children <- (1 - prop.shet) * base.fertilities[inc.zero == F & sex == s, fertility]
      
      ## Grab a mean fertility value to calculate a fertility ratio from
      if (s == 1) {
        to.use.ratio <- base.fertilities[sex == 1 & inc.zero == T, fertility]
      } else {
        to.use.ratio <- base.fertilities[sex == 2 & inc.zero == T, fertility]
      }
      
      model.fertility <- bind_rows(model.fertility,
                                   data.table(shet = modifier, 
                                              sex = s, 
                                              error = place, 
                                              mean.childlessness = 1 - prop.shet,
                                              mean.children = mean.children, 
                                              ratio = mean.children / to.use.ratio))
    
    }
  
  }
    
}

model.fertility[,mean.childlessness:=1-mean.childlessness]

model.fertility <- data.table(pivot_wider(model.fertility, names_from = error, values_from = c(mean.childlessness,mean.children,ratio)))

model.fertility[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

paste0("Contribution of sHET to Fitness (sex averaged): ",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_mid)])*100)),
       "% (",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_upper)])*100)),
       " - ",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_lower)])*100)),
       "%)")
```

## 6D. Function to Calculate Increased Childlessness Due to Partner at Home/EA

Partner at Home and Educational Attainment use a similar methodology to get estimates of fitness. As such, I wrote a single function to handle the calculation.

```{r Increased Childlessness Function}

## Helper function to generate a given trait and age for a 'simulated' 
## individual given a probability of having that trait. 
calc.childlessness <- function(glm.result, y.var.result, y.var) {
  
  ## Datatable for return:
  model <- data.table()

  for (s in c(1,2)) {
  
    ## Get meta-anlysis OR from the original fertility LM that was calculated above section.
    meta.analy <- metagen(var.beta,
                          var.stderr,
                          studlab = variant.type,
                          method.tau = "SJ",
                          sm = "OR",
                          data = glm.result[sex == s & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC")])
    
    ## Get actual proportion of individuals without 'y.var' from our data generated above
    prop.affected <- 1 - mean(UKBB.phenotype.data[sexPulse == s & !is.na(get(y.var)), get(y.var)])
    
    ## This is just a constant denominator when calculating expected 
    ## childlessness via the function calc.prop.indvs()
    aff <- prop.affected/(1-prop.affected)
    
    ## Determine expected proportions of childlessness at various shet
    ## values based on meta-analysis OR
    for (modifier in seq(0,1,by=0.1)) {
      
      ## Calculate value for the actual OR, as well as upper and 
      ## lower confidence intervals
      for (place in c("mid","lower","upper")) {
    
        ## Just modifies the actual OR (actual or upper/lower CI) that will
        ## be used to get expected proportion of childlessness
        if (place == "mid") {
          or <- exp(meta.analy$TE.fixed*modifier)
        } else if (place == "upper") {
          or <- exp((meta.analy$TE.fixed + (1.96*(meta.analy$seTE.fixed))) * modifier)
        } else if (place == "lower") {
          or <- exp((meta.analy$TE.fixed - (1.96*(meta.analy$seTE.fixed))) * modifier)
        }
      
        ## Determine expected proportions at various shet values based on meta-analysis OR
        prop.shet <- calc.prop.indvs(or, aff)
        model.sim <- data.table(val = prop.shet, shet = modifier, sex = s, error = place)
        
        ## Determine the increased proportion of individuals without children due to shet
        # This creates a fake table that we can use to pull the probabilities out from the GLM of has.child ~ y.var
        # We use the median age for UKBB participants
        prob.table <- data.table(id = c(1:2), shet=modifier, sex = s, agePulse = mean(UKBB.phenotype.data[sexPulse == s, agePulse]), var = c(0,1))
        prob.table[,agePulse.squared:=agePulse^2]
        setnames(prob.table,"var",y.var)
        var.model <- y.var.result[sex == s, model][[1]]
        prob.table[,prob.child:=predict(var.model, prob.table,type="response")]
        
        ## So now that we have the proportion of individuals for the y.var and childlessness for those proportions,
        ## We can calculate our fertility by adding together the individuals who have children from each category:
        mean.have.children <- ((prop.shet * prob.table[get(y.var) == 0, prob.child]) + ((1-prop.shet) * prob.table[get(y.var) == 1, prob.child]))
        mean.children <- mean.have.children * base.fertilities[inc.zero == F & sex == s, fertility]
        ## For the above, we know that individuals w/o children are 0 and individuals with children do
        ## not deviate from the population mean (see subsection in Fertility - Only Individuals With >0 Children),
        ## So we can just use fertility of those with children.
        
        model.sim[,mean.childlessness:=1-mean.have.children]
        model.sim[,mean.children:=mean.children]
        model.sim[,ratio:=mean.children/base.fertilities[sex == s & inc.zero == T, fertility]]
        model <- rbind(model, model.sim)
        
      }
      
    }
  
  }

  return(model)
  
}

```

## 6E. Fertility + Partner at Home

### Linear Model

```{r Partner Linear Model, fig.height=4, fig.width=7}

## Actual LM
sex.diff.partner <- data.table(sex=c(1,2))
sex.diff.partner[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"partner.in.house"),by=1:nrow(sex.diff.partner)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.partner[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.partner[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.partner[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.partner[,beta:=exp(beta)]
sex.diff.partner[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.partner, aes(sexPulse,beta,colour=sexPulse)) + 
  geom_point() + 
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(name="OR", limits=c(0.9,6)) + 
  sex.colours.colour + 
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- rbind(sex.diff.partner[1,data][[1]],sex.diff.partner[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("partner.in.house","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(partner.in.house),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Partner In Home",labels=c("False","True")) +
  sex.colours.colour +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
```

### Effect on Childlessness

This code uses the function from [above](#6d._function_to_calculate_increased_childlessness_due_to_partner_at_home/ea). See that code for how this section works.

```{r Partner Childlessness}

## Datatable for return:
model.partner <- calc.childlessness(results.partner, sex.diff.partner, "partner.in.house")
model.partner[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]
setnames(model.partner, "val", "expected.without.partner")

model.partner <- data.table(pivot_wider(model.partner, 
                                        names_from = error, 
                                        values_from = c(expected.without.partner, 
                                                        ratio, 
                                                        mean.childlessness, 
                                                        mean.children)))

paste0("Contribution of Partner at Home to Fitness: ",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       "% (",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       
       "%)")
```

## 6F. Fertility + Educational Attainment

### Linear Model

```{r EA Linear Model}

## Actual LM
sex.diff.ea <- data.table(sex=c(1,2))
sex.diff.ea[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"completed.college"),by=1:nrow(sex.diff.ea)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.ea[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.ea[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.ea[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.ea[,beta:=exp(beta)]
sex.diff.ea[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.ea, aes(sexPulse,beta,colour=sexPulse)) + 
  geom_point() + 
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(name="OR",limits=c(-0.1,1)) + 
  sex.colours.colour +
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- rbind(sex.diff.ea[1,data][[1]],sex.diff.ea[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("completed.college","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(completed.college),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Completed College",labels=c("False","True")) +
  sex.colours.colour +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
```

### Effect on Childlessness

This code uses the function from [above](#6d._function_to_calculate_increased_childlessness_due_to_partner_at_home/ea). See that code for how this section works. Note that this calculation is not included in the main text but is performed here for sake of completion/supplementary data.

```{r EA Childlessness}

model.ea <- calc.childlessness(results.ea, sex.diff.ea, "completed.college")
model.ea[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]
setnames(model.ea, "val", "expected.did.not.complete.college")
model.ea[,expected.completed.college:=1-expected.did.not.complete.college]

model.ea <- data.table(pivot_wider(model.ea, 
                                   names_from = error, 
                                   values_from = c(expected.completed.college, ratio, mean.childlessness, mean.children,expected.did.not.complete.college)))
```

## 6G. Fertility + Fluid Intelligence

### Linear Model

Testing the interaction of cognition and fertility via a glm of $Fertility \sim Fluid.Intel + control.covars$

```{r FI Linear Model, fig.height=4, fig.width=10}

## Actual LM
sex.diff.fluidintel <- data.table(sex=c(1,2))
sex.diff.fluidintel[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"fluid.intel"),by=1:nrow(sex.diff.fluidintel)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.fluidintel[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.fluidintel[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.fluidintel[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.fluidintel[,beta:=exp(beta)]
sex.diff.fluidintel[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.fluidintel, aes(sexPulse,beta,colour=sexPulse)) +
  geom_point() + 
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(name="OR", limits=c(0.8,1.5)) +
  sex.colours.colour +
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- rbind(sex.diff.fluidintel[1,data][[1]],sex.diff.fluidintel[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,fluid.intel.binned:=cut(fluid.intel,breaks=14)]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("fluid.intel.binned","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(fluid.intel.binned,mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Fluid Intel Score",labels = c(0:29)) +
  sex.colours.colour +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
```

### Effect on Childlessness

This section uses paired IQ and fertility data from the Swedish birth cohort presented in the study.

#### Load Data and Fit Expected Models

We first load data for both:

1. IQ vs Mean Children: `rawdata/cognitive_data/cognitive_data_raw.txt`
2. IQ vs Increased Childlessness: `rawdata/cognitive_data/cognitive_childlessness_data_raw.txt`

The data that is loaded is identical to that which is presented in the Supplementary Materials of the manuscript. I have simply provided raw data files at the above locations.

##### IQ and Mean Children

```{r Fit Mean Children Data}

## Need to generate a fit for the model -- first load data and correct some errors
cog.raw <- fread("rawdata/cognitive_data/cognitive_data_raw.txt")
cog.raw[,Obs:=as.integer(str_replace(Obs,",",""))]
cog.raw[,SD:=as.numeric(SD)]

## This basically takes a set of input "estimated" parameters that are reasonably close by eye and generates a set of optimized parameters for a sigmoid curve
fit.log <- nls(Mean ~ a/(1 + exp(-b * (newiq - c))), start = list(a = 1.6, b = 0.15, c = 70), data = cog.raw[newiq <= 120])

## Generate a table to predict on that also contains actual data:
cog.raw <- bind_rows(data.table(newiq = c(1:62),Obs=NA,Mean=NA,SD=NA,Min=NA,Max=NA),cog.raw,data.table(newiq = c(140:200),Obs=NA,Mean=NA,SD=NA,Min=NA,Max=NA))
cog.raw[,pred.log:=predict(fit.log,cog.raw)]
cog.raw[,ci:=(SD/sqrt(Obs))*1.96]

## Generate quick plots of actual data:
ggplot(cog.raw,aes(newiq, Mean), colour="blue") +
  geom_line(colour="blue") +
  geom_ribbon(aes(ymin=Mean-ci,ymax=Mean+ci),colour="grey",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_x_continuous(name = "IQ", limits=c(0,140)) +
  scale_y_continuous(name = "Average Children", limits=c(-0.1,2)) +
  theme

## The fitted model
ggplot(cog.raw) + 
  geom_line(data = cog.raw[newiq<120],aes(x=newiq, y=Mean),colour="blue") +
  geom_line(aes(x = newiq, y=pred.log),colour="green") +
  scale_x_continuous(name = "IQ", limits=c(0,140)) +
  scale_y_continuous(name = "Average Children", limits=c(-0.1,2)) +
  theme

## The IQ Distribution
ggplot(cog.raw,aes(newiq, Obs)) +
  geom_col() +
  theme

## Generate mean/sd from the actual distributions of Swedish IQ data and UKBB Fluid Intel for Males
iq.table <- data.table(iq = cog.raw[!is.na(newiq) & !is.na(Obs),rep(newiq, Obs)])
mean.cog <- iq.table[,mean(iq)]
sd.cog <- iq.table[,sd(iq)]

mean.fi <- UKBB.phenotype.data[sexPulse == 1 & !is.na(fluid.intel), mean(fluid.intel)]
sd.fi <- UKBB.phenotype.data[sexPulse == 1 & !is.na(fluid.intel), sd(fluid.intel)]

## Plot the FI/IQ distribution
fi.table <- UKBB.phenotype.data[sexPulse == 1 & !is.na(fluid.intel),c("fluid.intel")]
fi.table[,fi.cut:=cut(fluid.intel,breaks = c(seq(mean.fi-(sd.fi*4),mean.fi-(sd.fi*1),by=sd.fi),seq(mean.fi+(sd.fi*1),mean.fi+(sd.fi*4),by=sd.fi)))]
fi.table[,dummy:=1]
means <- fi.table[,sum(dummy)/nrow(fi.table),by=fi.cut]

ggplot(means, aes(fi.cut,V1)) + 
  geom_col() + 
  xlab("Fluid Intel Bin") + 
  ylab("Proportion of Individuals") + 
  theme

iq.table[,iq.cut:=cut(iq,breaks = c(seq(mean.cog-(sd.cog*4),mean.cog-(sd.cog*1),by=sd.cog),seq(mean.cog+(sd.cog*1),mean.cog+(sd.cog*4),by=sd.cog)))]
iq.table[,dummy:=1]
means <- iq.table[,sum(dummy)/nrow(iq.table),by=iq.cut]

ggplot(means, aes(iq.cut,V1)) + 
  geom_col() + 
  xlab("IQ Bin") + 
  ylab("Proportion of Individuals") + 
  theme

paste0("Mean IQ, Swedish Data: ", sprintf("%0.0f", mean.cog))
paste0("SD   IQ, Swedish Data: ", sprintf("%0.0f", sd.cog))
```

##### IQ and Childlessness

**Note**: The data provided in this section indicate _increased_ childlessness, where the baseline is at IQ = 100. All values are thus ± from the childlessness at IQ 100, and we adjust for that when doing our estimates.

```{r Fit Childlessness Data}

## Read in initial data:
childless.raw <- fread("rawdata/cognitive_data/cognitive_childlessness_data_raw.txt")

## Plot actual distribution
ggplot(childless.raw,aes(iq,inc.childlessness)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=ci.lower,ymax=ci.upper),alpha = 0.5) + 
  theme

## What is actual childlessness?
childless.raw[,pred.childlessness:=inc.childlessness+base.childlessness.male]

## This basically takes a set of input "estimated" parameters that are reasonably close by eye and generates a set of optimized parameters for a sigmoid curve
## We have to invert the data so that it scales to 0 properly...
childless.raw[,inv.pred.childless:=(1 - (pred.childlessness))]
fit.log <- nls(inv.pred.childless ~ a/(1 + exp(-b * (iq - c))), start = list(a = 1.6, b = 0.15, c = 70), data = childless.raw[iq <= 120])
summary(fit.log)

## Generate a table to predict on that also contains actual data:
childless.raw <- bind_rows(data.table(iq = c(1:62),inc.childlessness=NA,`std. err.`=NA,t=NA,p.val=NA,ci.lower=NA,ci.upper=NA,inv.childless=NA,inv.pred.childless=NA,pred.childlessness=NA),childless.raw,data.table(iq = c(140:200),inc.childlessness=NA,`std. err.`=NA,t=NA,p.val=NA,ci.lower=NA,ci.upper=NA,inv.childless=NA,inv.pred.childless=NA,pred.childlessness=NA))

## Flip it back the same way again:
childless.raw[,pred.log:=predict(fit.log,childless.raw)]
childless.raw[,pred.log.inv:=(1-(pred.log))-base.childlessness.male]

## Plot fitted data
ggplot(childless.raw,aes(iq,inc.childlessness)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=ci.lower,ymax=ci.upper),alpha = 0.5) + 
  geom_line(aes(iq,pred.log.inv),colour="blue") + 
  theme
```

#### Simulations

##### Helper Functions

First code block is just a set of helper functions to assist with simulating.

```{r FI Helper Functions}

## Simulate a set of individuals with reduced IQ and match their fertility scores
sim.cog <- function(effect.iq) {
  
  ## number to include in sample
  num.random<-100000 
  ## Use the mean and sd from our IQ distributions calculated above to simulate "healthy" individuals 
  IQ.sim <- data.table(norm.iq=round(rnorm(num.random, mean=mean.cog, sd=sd.cog)))
  
  ## Get 'drop' on IQ given effect.iq, where effect.iq 
  ## is the expected decrease in IQ given an sHET score.
  IQ.sim[,changed.iq:=round(norm.iq-effect.iq),by=1:nrow(IQ.sim)]
  
  ## This grabs the expected fertility at each IQ for both the healthy cohort and simulated sHET cohort
  IQ.sim <- merge(IQ.sim,cog.raw[,c("newiq","pred.log")],by.x="norm.iq",by.y="newiq")
  setnames(IQ.sim,"pred.log","norm.fertility")
  IQ.sim <- merge(IQ.sim,cog.raw[,c("newiq","pred.log")],by.x="changed.iq",by.y="newiq")
  setnames(IQ.sim,"pred.log","changed.fertility")
  
  ## And then just return the fertility ratio:
  return(IQ.sim[,mean(changed.fertility)/mean(norm.fertility)])

}

## Simulate a set of individuals with reduced IQ and decide if they are childless or not with random selection
## Function is very similar to above, but just for childlessness instead
sim.childlessness <- function(effect.iq, base.childlessness) {
  
  ## number to include in sample
  num.random<-100000
  ## Use the mean and sd from our IQ distributions calculated above to simulate "healthy" individuals 
  IQ.sim <- data.table(norm.iq=round(rnorm(num.random, mean=mean.cog, sd=sd.cog)))
  
  ## Get 'drop' on IQ given effect.iq, where effect.iq 
  ## is the expected decrease in IQ given an sHET score.  
  IQ.sim[,changed.iq:=round(norm.iq-effect.iq),by=1:nrow(IQ.sim)]
  IQ.sim <- merge(IQ.sim,childless.raw[,c("iq","pred.log.inv")],by.x="changed.iq",by.y="iq")
  setnames(IQ.sim,"pred.log.inv","changed.childlessness")
  
  ## This converts from an increase in childlessness to actual childlessness
  IQ.sim[,changed.childlessness:=changed.childlessness+base.childlessness]
  
  ## This removes VERY high IQ values that sometimes appear due to simulations
  IQ.sim <- na.omit(IQ.sim)
  
  ## Now simulate childlessness for each individual given changed childlessness
  IQ.sim[,has.child:=simulate.proportion(changed.childlessness),by=1:nrow(IQ.sim)]

  ## Return proportion of simulated childless individuals
  return(nrow(IQ.sim[has.child==0])/nrow(IQ.sim))

}

```

##### Actual Calculation

This section then does the actual simulations. This uses the formula: $\Delta_{IQ}= \beta_{fluid.intel} * \sigma_{IQ}$ to determine the expected change in IQ given an individuals expected drop in fluid intelligence as a function of s~het~.

```{r FI Childlessness}

## Datatable for return:
model.cog <- data.table()

for (s in c(1,2)) {

  ## Get meta-anlysis OR from the original fertility LM that was calculated above section.
  meta.analy <- metagen(var.beta,
                        var.stderr,
                        studlab = variant.type,
                        sm = "SMD",
                        prediction=T,
                        data = results.cog[sex == s & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC")])
  
  ## Get actual proportion of individuals without a partner from our data generated above
  if (s == 1) {
    stat <- "children.fathered"
    prop.affected <- base.childlessness.male
  } else {
    stat <- "live.births"
    prop.affected <- base.childlessness.female
  }
  
  ## Determine expected proportions of childlessness at various shet
  ## values based on meta-analysis OR
  for (modifier in seq(0,1,by=0.1)) {
  
    ## Calculate value for the actual OR, as well as upper and 
    ## lower confidence intervals
    for (place in c("mid","lower","upper")) {
    
      ## Just modifies the actual OR (actual or upper/lower CI) that will
      ## be used to get expected proportion of childlessness
      if (place == "mid") {
        effect.fi <- meta.analy$TE.fixed*modifier
      } else if (place == "upper") {
        effect.fi <- (meta.analy$TE.fixed + (1.96 * meta.analy$seTE.fixed))*modifier
      } else if (place == "lower") {
        effect.fi <- (meta.analy$TE.fixed - (1.96 * meta.analy$seTE.fixed))*modifier
      }
    
      ## Uses the above function to determine a drop in IQ
      effect.iq <- abs(effect.fi * sd.cog)
      
      ## Uses above helper functions to determine simulated fertility/childlessness
      actual.effect.fert <- sim.cog(effect.iq)
      actual.effect.child <- sim.childlessness(effect.iq, prop.affected)
      
      ## Make a returnable data.table:
      model.cog <- bind_rows(model.cog,
                             data.table(val = effect.iq, 
                                        ratio = actual.effect.fert[[1]], 
                                        mean.childlessness = actual.effect.child, 
                                        shet = modifier, 
                                        sex = s, 
                                        error = place))
  
    }
      
  }

}

model.cog[,expected.iq:=mean.cog-val]
model.cog[,val:=NULL]

model.cog <- data.table(pivot_wider(model.cog, names_from = error, values_from = c(expected.iq, ratio, mean.childlessness)))

model.cog[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

paste0("Contribution of Cognition to Fitness: ",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       "% (",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       "%)")

paste0("Predicted drop in IQ for sHET = 1 male  : " ,sprintf("%0.2f", model.cog[shet == 1 & sex == 1,100 - expected.iq_mid]))
paste0("Predicted drop in IQ for sHET = 1 female: " ,sprintf("%0.2f", model.cog[shet == 1 & sex == 2,100 - expected.iq_mid]))
```

## 6G. Fertility + Mental Health

### Linear Model

```{r MH Linear Model}

## Actual LM
sex.diff.mhq <- data.table(sex=c(1,2))
sex.diff.mhq[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"ganna.binary"),by=1:nrow(sex.diff.mhq)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.mhq[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.mhq[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.mhq[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.mhq[,beta:=exp(beta)]
sex.diff.mhq[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.mhq, aes(sexPulse,beta,colour=sexPulse)) + 
  geom_point() + 
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(name="OR",limits=c(-0.1,1)) + 
  sex.colours.colour +
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- rbind(sex.diff.mhq[1,data][[1]],sex.diff.mhq[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("ganna.binary","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(ganna.binary),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Has Power et al. Disorder",labels=c("False","True")) +
  sex.colours.colour +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
```

### Effect on Childlessness

As described in the methods, we are using ORs extracted from [Ganna et al.](https://doi.org/10.1016/j.ajhg.2018.05.002) for three MH traits that have an association with rare variant burden, and fertility statistics for those same MH traits from [Power et al.](https://doi.org/10.1001/jamapsychiatry.2013.268). We provide tabulated forms of this data with the Supplementary Materials of the manuscript.

This calculation uses the function $OR_{s_{het}[x,t]}=\frac{log(OR_{ganna}) *s_{het}[x]} {0.1618034}$ to convert from an OR of one additional high pLI (≥ 0.9) gene. The calculation for a 'high pLI' gene is given below.

```{r MH Childlessness}

## Get mean high pLI
mean.highpLI <- merge(pli.genes,shet.genes)[pLI.val>=0.9,mean(sHET.val)]
print(paste0("high pLI genes (≥ 0.9) have a mean sHET value of : ",sprintf("%0.3f",mean.highpLI)))

## These are tabulated values that were extracted from either Ganna et al or Power et al.
modeling <- data.table(or = rep(c(1.4,1.3,1.25),2),
                       or.upper = rep(c(1.5,1.4,1.35),2),
                       n.indv = rep(c(2947,18890,14439),2),
                       sex.ratio = c(2/(2+1),1.5/(1.5+1),1/(1+1.5),1/(2+1),1/(1.5+1),1.5/(1+1.5)),
                       ratio = c(0.25,0.23,0.75,0.48,0.47,0.85),
                       trait = rep(c("asd","scizo","bipolar"),2),
                       sex = c(rep(1,3),rep(2,3)))

## Power et al. lists 1.76 as the mean number of children per person, 
## for which we can extrapolate the mean number of children for each trait
modeling[,mean.children:=1.76*ratio]
modeling[,incidence:=(sex.ratio*n.indv)/1178299]
modeling[,healthy.ratio:=(incidence/(1-incidence))]

## This is to make arbitrarily even CIs (why don't they provide their point estimates!!!)
modeling[,or.lower:=exp((-1*log(or.upper/or)) + log(or))]

## Use this function to calculate the expected number of individuals with 
## a MH trait at a given sHET value
calc.prop.indvs.mhq <- function(odds.ratio, healthy.ratio) {
  
  x <- odds.ratio * healthy.ratio
  y <- x + 1
  x / y

}

## Datatable for return:
mh.affected <- data.table()

for (s in c(1,2)) {

  ## Determine expected proportions of childlessness at various shet
  ## values based on meta-analysis OR
  for (shet in seq(0,1,by=0.1)) {
  
    ## Just modifies the actual OR (actual or upper/lower CI) that will
    ## be used to get expected proportion of childlessness
    for (place in c("mid","lower","upper")) {
    
      disorder.table <- data.table()
      
      for (disorder in unique(modeling[,trait])) {
        
        ## Median pLI shet value of a high pLI gene (0.144829) is hardcoded
        if (place == "mid") {
          or <- modeling[trait == disorder & sex == s,or]
        } else if (place == "upper") {
          or <- modeling[trait == disorder & sex == s,or.upper]
        } else if (place == "lower") {
          or <- modeling[trait == disorder & sex == s,or.lower]
        }
      
        ## This is the function that we use to convert from Ganna et al. ORs to sHET ORs.
        or <- (log(or) * shet)/mean.highpLI
        or <- exp(or)
        
        healthy.ratio <- modeling[trait == disorder & sex == s,healthy.ratio]
        children.affected <- modeling[trait == disorder & sex == s,ratio] * base.fertilities[sex == s & inc.zero == T, fertility]
        
        prop.shet <- calc.prop.indvs.mhq(or,healthy.ratio)
      
        disorder.table <- bind_rows(disorder.table,
                                    data.table(prop.affected = prop.shet,
                                               children.affected = children.affected,
                                               error = place,
                                               trait = disorder))
        
      }
      
      prop.affected.total <- disorder.table[,sum(prop.affected)]
      children.unaffected <- base.fertilities[sex == s & inc.zero == T, fertility]
      mean.children <- sum(disorder.table[1:3, prop.affected * children.affected]) + (children.unaffected * (1 - prop.affected.total))
      mh.affected <- bind_rows(mh.affected,
                               data.table(shet = shet, sex = s, error = place, mean.children = mean.children, 
                                          mean.has.disorder = prop.affected.total,
                                          inc.scizo=disorder.table[trait=="scizo", prop.affected],
                                          inc.asd=disorder.table[trait=="asd", prop.affected],
                                          inc.bipolar = disorder.table[trait=="bipolar", prop.affected]))
      
    }
  }
}

## Calculate a fertility ratio for each trait.
mh.affected[,ratio:=if_else(sex == 1,
                            mean.children/base.fertilities[sex==1 & inc.zero == T, fertility],
                            mean.children/base.fertilities[sex==2 & inc.zero == T, fertility])]

## And generate the final model data.table like for other traits
model.mhq <- data.table(pivot_wider(mh.affected[,-c("inc.scizo","inc.asd","inc.bipolar")], names_from = error, values_from = c(mean.children,ratio,mean.has.disorder)))
model.mhq[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## The following data table is used to plot incidence of each of the 
## MH traits we measure in the study
inc.mht <- data.table(pivot_longer(mh.affected,cols=starts_with("inc."),names_sep="\\.",names_to = c(".value","condition")))
inc.mht <- data.table(pivot_wider(inc.mht[,c("shet","sex","inc","condition","error")], names_from=error,values_from=inc))
inc.mht[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

paste0("Contribution of MHTs to Fitness: ",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       "% (",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       "%)")
```

## 6H. Fertility + Household Income

Remember, we don't fit HHI to expectations of childlessness/fitness, so no 'Effect on Childlessness' section.

### Linear Model

```{r HHI Linear Model, fig.height=5, fig.width=12}

## Actual LM
sex.diff.hhi <- data.table(sex=c(1,2))
sex.diff.hhi[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"household.income",add.covars=c("partner.in.house","partner.in.house*household.income")),by=1:nrow(sex.diff.hhi)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.hhi[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.hhi[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.hhi[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.hhi[,beta:=exp(beta)]
sex.diff.hhi[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.hhi, aes(sexPulse,beta,colour=sexPulse)) +
  geom_point() +
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) +
  scale_y_continuous(name="OR",limits=c(-0.1,1)) +
  sex.colours.colour +
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- rbind(sex.diff.hhi[1,data][[1]],sex.diff.hhi[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,household.income.binned:=cut(household.income,breaks=c(seq(0,5,by=1)))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("household.income.binned","sexPulse","partner.in.house")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(household.income.binned,mean,group=interaction(sexPulse,partner.in.house),colour=sexPulse,shape=as.factor(partner.in.house))) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Household Income Bin",labels = c(0:29)) +
  sex.colours.colour +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
rm(mean.plot, beta.plot)
```

## 6I. Fertility + Same Sex Sexual Behaviour

We also don't estimate increased/decreased childlessness for same sex sexual behaviour as there is no effect due to s~het~ burden.

### Linear Model

```{r Same Sex Linear Model, fig.height=5, fig.width=12}

## Actual LM
sex.diff.same.sex <- data.table(sexPulse=c(1,2))
sex.diff.same.sex[,c("beta","std.error","p.val","data","model"):=run.lm(sexPulse,"same.sex"),by=1:nrow(sex.diff.same.sex)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.same.sex[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.same.sex[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.same.sex[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.same.sex[,beta:=exp(beta)]
sex.diff.same.sex[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.same.sex, aes(sexPulse,beta,colour=sexPulse)) +
  geom_point() +
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(name="OR",limits=c(-0.1,1)) + 
  sex.colours.colour +
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- rbind(sex.diff.same.sex[1,data][[1]],sex.diff.same.sex[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("same.sex","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(same.sex),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Has Had Same Sex Behaviour",labels=c("False","True")) +
  sex.colours.colour +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
rm(mean.plot, beta.plot)
```

## 6J. Fertility + Neutral Phenotypes

```{r}
sex.diff.fruit <- data.table(sexPulse=c(1,2))
sex.diff.fruit[,c("beta","std.error","p.val","data","model"):=run.lm(sexPulse,"fresh.fruit"),by=1:nrow(sex.diff.fruit)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.fruit[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.fruit[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.fruit[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.fruit[,beta:=exp(beta)]
sex.diff.fruit[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.fruit, aes(sexPulse,beta,colour=sexPulse)) +
  geom_point() +
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(name="OR",limits=c(0.75,1.25)) + 
  sex.colours.colour +
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- rbind(sex.diff.fruit[1,data][[1]],sex.diff.fruit[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("fresh.fruit","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(fresh.fruit),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Fresh Fruit Intake") +
  sex.colours.colour +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
rm(mean.plot, beta.plot)
```

```{r}

sex.diff.handedness <- data.table(sexPulse=c(1,2))
sex.diff.handedness[,c("beta","std.error","p.val","data","model"):=run.lm(sexPulse,"handedness"),by=1:nrow(sex.diff.handedness)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.handedness[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.handedness[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.handedness[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.handedness[,beta:=exp(beta)]
sex.diff.handedness[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.handedness, aes(sexPulse,beta,colour=sexPulse)) +
  geom_point() +
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(name="OR",limits=c(0.75,1.4)) + 
  sex.colours.colour +
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- rbind(sex.diff.handedness[1,data][[1]],sex.diff.handedness[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("handedness","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(handedness),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Handedness",labels=c("Right","Left")) +
  sex.colours.colour +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
rm(mean.plot, beta.plot)

```


# 7. Figures

Create a directory to drop all figures and supplementary data into

```{bash Make Figure Dirs}

mkdir -p figures/supplement/

```

## 7A. Universal function to make forest plots

```{r Meta analysis calc and plotting}

## Helper functions for the main function:

get.meta.val.logistic <- function(study, m, s, g) {
  
  meta.table <- study[maf == m & (variant.type == "DEL" | variant.type == "LOF_HC") & sex == s & gene.list == g]
  meta.analy <- metagen(var.beta,
                        var.stderr,
                        studlab = variant.type,
                        method.tau = "SJ",
                        sm = "OR",
                        data = meta.table)
  
    return(list(meta.analy$TE.fixed,
                meta.analy$seTE.fixed,
                meta.analy$pval.fixed))
  
}

get.meta.val.linear <- function(study, m, s, g) {

  meta.table <- study[maf == m & (variant.type == "DEL" | variant.type == "LOF_HC") & sex == s & gene.list == g]
  meta.analy <- metagen(var.beta,
                        var.stderr,
                        studlab = variant.type,
                        sm = "SMD",
                        prediction=T,
                        data = meta.table)

    return(list(meta.analy$TE.fixed,
                meta.analy$seTE.fixed,
                meta.analy$pval.fixed))
    
}

make.meta.table <- function(data, is.linear, 
                            gene.list = "product_sHET",
                            allele.freq = 0,
                            ymin = -0.15, 
                            ymax = 1.25, 
                            b = 0.2, 
                            block = 0, 
                            p.pos = 0.05,
                            title = "",
                            show.x = T,
                            alt.y.axis = NA) {

  meta.result <- data.table(crossing(maf = allele.freq,
                                  sex = c(1,2),
                                  gene.list = gene.list,
                                  variant.type = "META"))

  if (is.linear == T) {
    meta.result[,c("var.beta","var.stderr","var.p"):=get.meta.val.linear(data,maf,sex,gene.list),by=1:nrow(meta.result)]
    y.axis <- expression(bold(Effect~Size~at~s[het]~burden == 1))
    plot.breaks <- c(seq(0,ymin,by=-1 * b),seq(0,ymax,by=b))
    plot.breaks <- plot.breaks[plot.breaks != block]

    meta.table <- rbind(data[maf == allele.freq & (variant.type == "DEL" | variant.type == "LOF_HC"),c("variant.type","sex","var.beta","var.stderr","var.p","n.var","n.indvs")],
                          meta.result[maf == allele.freq,c("variant.type","sex","var.beta","var.stderr","var.p")],
                        fill=TRUE)
    
    meta.table[,var.ci.upper:=var.beta + (1.96*var.stderr)]
    meta.table[,var.ci.lower:=var.beta - (1.96*var.stderr)]
    
  } else {
    meta.result[,c("var.beta","var.stderr","var.p"):=get.meta.val.logistic(data,maf,sex,gene.list),by=1:nrow(meta.result)]

    y.axis <- expression(bold(Odds~Ratio~at~s[het]~burden==1))
    plot.breaks <- c(seq(1,ymin,by=-1 * b),seq(1,ymax,by=b))
    plot.breaks <- plot.breaks[plot.breaks != block]
    
    meta.table <- rbind(data[maf == allele.freq & (variant.type == "DEL" | variant.type == "LOF_HC"),c("variant.type","sex","var.beta","var.stderr","var.p","n.var","n.indvs")],
                          meta.result[maf == allele.freq ,c("variant.type","sex","var.beta","var.stderr","var.p")],
                        fill=TRUE)
    
    meta.table[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
    meta.table[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
    meta.table[,var.beta:=exp(var.beta)]
    
  }

  if (!is.na(alt.y.axis)) {
    y.axis <- alt.y.axis
  }
  
  n.male <- data[sex == 1 & maf == allele.freq & (variant.type == "DEL" | variant.type == "LOF_HC"), sum(n.indvs)]
  n.female <- data[sex == 2 & maf == allele.freq & (variant.type == "DEL" | variant.type == "LOF_HC"), sum(n.indvs)]
  
  meta.table[,n.indvs:=if_else(variant.type=="META",if_else(sex == 1, n.male, n.female),n.indvs)]
  meta.table[,Sex:=factor(sex,levels=c("1","2"),labels = c("Male","Female"))]
  meta.table[,sex:=NULL]
  meta.table[,variant.type:=factor(variant.type,levels=c("META","LOF_HC","DEL"))]
  meta.table[,variant.shape:=if_else(variant.type=="META",18,15)]
  meta.table[,p.nudge:=if_else(variant.type=="LOF_HC",-0.2,-0.3)]
  
  if (show.x == T) {
    add.theme <- theme(panel.grid.major.y = element_blank())
  } else {
    add.theme <- theme(axis.title.x=element_blank(),axis.text.x=element_blank(), panel.grid.major.y = element_blank())
  }
  
  plot <- ggplot(meta.table,aes(variant.type,var.beta,group=Sex,colour=Sex)) +
    geom_hline(aes(yintercept=if_else(is.linear==T,0, 1)),colour="red",linetype=2,size=1) +
    geom_point(aes(size=n.indvs,shape=variant.shape),position=position_dodge(0.5)) +
    geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),width=0.1,position=position_dodge(0.5)) +
    geom_text(aes(y = p.pos, label=paste0("p = ", sprintf("%0.2g",var.p))),position=position_dodge(0.5),size=4,hjust=1,show.legend = F) +
    scale_x_discrete(name = title, position = "top",labels=c("Meta","PTVs","Dels")) +
    scale_y_continuous(name=y.axis,limits = c(ymin,ymax), breaks=plot.breaks) +
    scale_shape_identity() +
    scale_size_area(breaks=c(50000,100000,150000),guide=guide_legend(title="# of Indivs.")) +
    sex.colours.colour.rev +
    coord_flip() +
    theme.figures.legend + add.theme

  return(list(meta.table,plot))
  
}
```

## 7B. Main Text

**Note**: A very light amount of editing was used to make better figure legends for main text figures 1 and 2.

### Figure 1.

```{r Main Text Figure 1, fig.height=5, fig.width=7}

## This just gets a forest plot for our primary childlessness logistic regression
plot.a <- make.meta.table(results.fertility, F, b = 0.25)

## the 'tab' data.frame is relevant only for plot b and c, using old regressions for plot. 
## This is to just tabulate vitality statistics for each individual
tab <- UKBB.phenotype.data[,c("eid","sexPulse","agePulse","agePulse.squared","children.fathered","live.births","partner.in.house","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10","PC11","PC12","PC13","PC14","PC15","PC16","PC17","PC18","PC19","PC20","PC21","PC22","PC23","PC24","PC25","PC26","PC27","PC28","PC29","PC30")]

tab[,children:=if_else(sexPulse==1,children.fathered,live.births)]
tab <- tab[!is.na(children)]

## Function to generate plots for Dels and PTVs
plot.dist.mean <- function (v) {
  
  ## Attach sHET burden to each individual
  quants <- merge(tab,variant.counts[type==v & allele.freq==0,c("sample_id","product_sHET")],by.x="eid",by.y="sample_id",all.x=T)
  quants[,sexPulse:=factor(sexPulse,levels=c("1","2"),labels = c("Male","Female"))]
  
  ## Only include individuals for which we have CNV or PTV data
  quants <- quants[eid %in% samples.UKBB.cnv[,eid] | eid %in% samples.UKBB[,eid]]
  
  ## Get whether individuals have children or not:
  quants[,children.binary:=if_else(children>0,1,0)]
  quants[,dummy:=1]
  
  ## Remove individuals without an sHET score
  quants <- quants[!is.na(product_sHET)]
  
  ## The following code is to set axis limits and labels -- purely graphical
  # Bin sizes
  if (v == "DEL") {
    b <- c(-1,((0:4)*0.15),100)
  } else {
    b <- c(-1,((0:3)*0.15),100)
  }
  quants[,product_sHET.cut:=cut(product_sHET,breaks=b)]
  quants[,dummy:=1]
  
  # Quantify proportion of individuals in each sHET bin we create above
  totals <- quants[,sum(dummy),by=c("product_sHET.cut","sexPulse")]
  sums <- quants[,sum(dummy),by=c("sexPulse")]
  setnames(sums,c("sexPulse"),c("s"))
  totals[,prop:=V1/sums[s==sexPulse,V1],by=1:nrow(totals)]
  totals[,prop.2:=prop*100000]
  totals[,ci:=1.96*sqrt((prop.2*(100000-prop.2))/sums[s==sexPulse,V1]),by=1:nrow(totals)]
  
  ## Change the ugly formating that is the direct output of 'cut()' to something better for a plot label
  x.axis.labels <- str_replace(str_replace(str_replace(str_replace(totals[,levels(product_sHET.cut)],"\\[",""),"\\]",""),",","-"),"\\(","")
  x.axis.labels.2 <- c()
  for (l in x.axis.labels) {
    if (grepl("-100",l)) {
      l <- str_replace(l,"\\-100","")
      l <- paste0(">",l)
      x.axis.labels.2 <- c(x.axis.labels.2,l)
    } else if (grepl("-1-",l)) {
      l <- str_replace(l,"\\-1-","")
      x.axis.labels.2 <- c(x.axis.labels.2,l)
    } else {
      x.axis.labels.2 <- c(x.axis.labels.2,l)
    }
  }
  
  ## Cumulative Density Plot of joint.product_sHET by sex
  plot.dist <- ggplot(totals,aes(product_sHET.cut,prop.2,group=sexPulse,fill=sexPulse)) +
    geom_col(position=position_dodge(1),colour="black") +
    scale_x_discrete(name = "",labels=x.axis.labels.2) +
    scale_y_log10(name = "Proportion of Individuals",breaks=c(1,10,100,1000,10000,100000),labels=paste0(c(0.001,0.01,0.1,1,10,100),"%")) +
    geom_errorbar(aes(ymin=prop.2-ci,ymax=prop.2+ci),position=position_dodge(1),width=0) +
    sex.colours.fill +
    theme.figures + theme(axis.text.x=element_blank())

  ## Percentage of Individuals With Children By Sex and Variant Type
  means <- quants[,list(mean(children.binary),sd(children.binary),sum(dummy)),by=c("sexPulse","product_sHET.cut")]
  setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
  
  means[,mean:=mean*100]
  means[,sd:=sd*100]
  means[,ci:=(sd/sqrt(n))*1.96]
  means[,ci.lower:=mean-ci]
  means[,ci.upper:=mean+ci]
  
  means[,ci.lower.symbol:=if_else(ci.lower<0,25,NaN)]
  means[,ci.lower:=if_else(ci.lower<0,0,ci.lower)]
  means[,ci.upper.symbol:=if_else(ci.upper>100,24,NaN)]
  means[,ci.upper:=if_else(ci.upper>100,100,ci.upper)]
  
  means[,sex:=factor(sexPulse,levels=c(1,2,3),labels=c("Male","Female","Both"))]
  
  means[,mean.adj:=if_else(sexPulse=="Male",mean+2.47741,mean)]
  means[,sd.adj:=if_else(sexPulse=="Male",sd+2.47741,sd)]
  means[,ci.adj:=(sd.adj/sqrt(n))*1.96]
  means[,ci.lower.adj:=mean.adj-ci.adj]
  means[,ci.upper.adj:=mean.adj+ci.adj]
  
  lines <- means[product_sHET.cut=="(-1,0]"]
  
  if (v == "DEL") {
    label.x <- expression(bold(Deletion~s[het]~Burden))
  } else {
    label.x <- expression(bold(PTV~s[het]~Burden))
  }
  
  plot.means <- ggplot(means,aes(product_sHET.cut,mean,group=sexPulse,colour=as.factor(sexPulse))) +
    geom_hline(data=lines,aes(yintercept=mean,colour=as.factor(sexPulse)),linetype=2) +
    geom_point(position=position_dodge(0.5),shape=16,size=3) +
    geom_errorbar(aes(ymin=ci.lower,ymax=ci.upper),width=0,position=position_dodge(0.5),size=1) +
    scale_x_discrete(name = label.x,labels=x.axis.labels.2) +
    scale_y_continuous(name="Percentage of Individuals\nWith Children",limits=c(0,100)) +
    sex.colours.colour +
    theme.figures
  
  return(list(plot.dist,plot.means))
  
}

del.plots <- plot.dist.mean("DEL")
lof.plots <- plot.dist.mean("LOF_HC")
```

```{r Figure 1, fig.height=9, fig.width=8}

top <- (plot.a[[2]] + plot_spacer()) + plot_layout(widths=c(1,0.05))  

middle <- (del.plots[[1]] + lof.plots[[1]]) + plot_layout(widths=c(1,0.8))  

bottom <- (del.plots[[2]] + lof.plots[[2]]) + plot_layout(widths=c(1,0.8))

figure.1 <- top / middle / bottom  + plot_layout(guides="keep",nrow=3,heights = c(2.5,3,4)) + plot_annotation(tag_levels = "A")

figure.1

ggsave("figures/Figure1.svg",figure.1,width=8,height=9)

plot.a[[1]][ variant.type == "META",paste0(Sex, " OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

```

### Figure 2.

Effect of rare variants on various metrics:

```{r Main Text Figure 2, fig.height=8.5, fig.width=7}

fig.partner <- make.meta.table(results.partner, F, title = "Partner at Home",show.x=F,b=0.25)
fig.ea <- make.meta.table(results.ea, F, title = "Educational Attainment",b=0.25)
fig.hhi <- make.meta.table(results.household.income, T, title = "Household Income",show.x=F, ymin = -2.3, ymax= 0.5, block = -2, p.pos = -1.9, b = 0.5)
fig.cog <- make.meta.table(results.cog[sex==1 | sex == 2], T, ymin = -2.3, ymax= 0.5, block = -2, p.pos = -1.9, b = 0.5, title = "Fluid Intelligence")

figure.2 <- fig.partner[[2]] + fig.ea[[2]] + fig.hhi[[2]] + fig.cog[[2]] + plot_layout(nrow=4, guides = "collect") + plot_annotation(tag_levels = "A")

figure.2

ggsave("figures/Figure2.svg",figure.2,width=7,height=8.5)

fig.partner[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Partner OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

paste0("Number of Fluid Intel Indv: ", sum(fig.cog[[1]][variant.type == "META",n.indvs]), " (Male: ",fig.cog[[1]][Sex == "Male" & variant.type == "META",n.indvs],"; Female: ", fig.cog[[1]][Sex == "Female" & variant.type == "META",n.indvs], ")")
```

### Figure 3.

```{r Main Text Figure 3, fig.height=3, fig.width=4}

figure.3 <- ggplot(model.fertility, aes(x = shet, group = sexPulse, fill = sexPulse)) + 
  geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + 
  geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + 
  scale_alpha_continuous(range = c(0,1)) + 
  sex.colours.colour + 
  sex.colours.fill + 
  geom_abline(intercept=1,slope=-1,linetype=2) + 
  scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + 
  scale_y_continuous(name = "Predicted Reduction in Fitness", limits = c(0,1.05)) + 
  theme.figures.legend

figure.3

ggsave("figures/Figure3.svg",figure.3,width=4,height=3,units = "in")

```

### Figure X.

```{r Main Text Figure X, fig.height=5, fig.width=8}

hes.plot.table <- hes.analysis.table[variant.type == "META" & level == 3]
hes.plot.table[,icd.p.log:=if_else(icd.p.log > 100 | icd.p.log == 0,100,icd.p.log)]

male.icd <- ggplot(hes.plot.table[sex == "MALE"],aes(var.p.log,factor*icd.p.log,colour=chapter)) + 
  geom_point(size=0.5) +
  scale_x_continuous(name = "", breaks = c(13,13.4,13.8,14.2,14.6), limits = c(12.9,14.7)) +
  scale_y_continuous(name = expression(bold(-log[10]~p~value~`for`~`ICD-10`~code~on~having~children)), limits = c(-100,100), labels = c("p ≥ 100","50","0","50","p ≥ 100")) +
  geom_text(data = hes.plot.table[sex == "MALE" & (var.p.log < 13.9 | icd.p.log > 25)],aes(label=meaning),size=3) +
  ggtitle("Males") +
  theme.figures + theme(plot.title = element_text(hjust = 0.5))

male.icd

female.icd <- ggplot(hes.plot.table[sex == "FEMALE"],aes(var.p.log,factor*icd.p.log,colour=chapter)) + 
  geom_point(size=0.5) + 
  scale_x_continuous(name = "") +
  scale_y_continuous(name = "", limits = c(-100,100)) +
  geom_text(data = hes.plot.table[sex == "FEMALE" & (var.p.log < 1.35 | icd.p.log > 25)],aes(label=meaning),size=3) +
  ggtitle("Females") +
  theme.figures + theme(plot.title = element_text(hjust = 0.5), axis.text.y=element_blank())

female.icd

combined.icd.top <- male.icd + female.icd
combined.icd.bottom <- grid::textGrob(expression(bold(-log[10]~p~value~`for`~`ICD-10`~code~on~having~children)))

combined.icd <- combined.icd.top / combined.icd.bottom + plot_layout(heights=c(5,0.05)) + plot_annotation(tag_levels = "A")
combined.icd

ggsave("figures/FigureX.svg",combined.icd,width=10,height=6)

combined.icd <- male.icd + female.icd + plot_layout(nrow = 2, ncol = 1) + plot_annotation(tag_levels = "A")
combined.icd



```

```{r Main Text Figure Xv2, fig.height=5, fig.width=8}

fi.plot.table <- fi.analysis.table[variant.type == "META" & level == 3]
fi.plot.table[,icd.p.log:=if_else(icd.p.log > 100 | icd.p.log == 0,100,icd.p.log)]

male.fi <- ggplot(fi.plot.table[sex == "MALE"],aes(var.p.log,factor*icd.p.log,colour=chapter)) + 
  geom_point(size=0.5) +
  scale_x_continuous(name = "") +
  scale_y_continuous(name = expression(bold(-log[10]~p~value~`for`~`ICD-10`~code~on~having~children)), limits = c(-100,100)) +
  geom_text(data = fi.plot.table[sex == "MALE" & (var.p.log < 8 | var.p.log > 8.4 | icd.p.log > 25)],aes(label=meaning),size=3,nudge_y=0.15) +
  ggtitle("Males") +
  theme.figures + theme(plot.title = element_text(hjust = 0.5))

male.fi

female.fi <- ggplot(fi.plot.table[sex == "FEMALE"],aes(var.p.log,factor*icd.p.log,colour=chapter)) + 
  geom_point(size=0.5) + 
  scale_x_continuous(name = "") +
  scale_y_continuous(name = "", limits = c(-100,100)) +
  geom_text(data = fi.plot.table[sex == "FEMALE" & (var.p.log < 0.57 | icd.p.log > 25)],aes(label=meaning),size=3,nudge_y=0.15) +
  ggtitle("Females") +
  theme.figures + theme(axis.text.y = element_blank(), plot.title = element_text(hjust = 0.5))

female.fi

combined.fi.top <- male.fi + female.fi
combined.fi.bottom <- grid::textGrob(expression(bold(-log[10]~p~value~`for`~the~effect~of~s[het]~burden==1~on~having~children)))

combined.fi <- combined.fi.top / combined.fi.bottom + plot_layout(heights=c(5,0.05)) + plot_annotation(tag_levels = "A")
combined.fi

```

```{r Main Text Figure Xv2, fig.height=5, fig.width=8}

male.fi.young <- ggplot(fi.young.analysis.table[variant.type == "META" & sex == "MALE" & level == 2],aes(var.p.log,factor*icd.p.log,colour=chapter)) + 
  geom_point(size=0.5) +
  scale_x_continuous(name = "") +
  scale_y_continuous(name = expression(bold(-log[10]~p~value~`for`~`ICD-10`~code~on~having~children)), limits = c(-100,100)) +
  geom_text(data = fi.young.analysis.table[variant.type == "META" & level == 2 & sex == "MALE" & (var.p.log < 8.1 | var.p.log > 8.4 | icd.p.log > 40)],aes(label=meaning),size=3,nudge_y=0.15) +
  ggtitle("Males") +
  theme.figures + theme(plot.title = element_text(hjust = 0.5))

male.fi.young

female.fi.young <- ggplot(fi.young.analysis.table[variant.type == "META" & sex == "FEMALE" & level == 2],aes(var.p.log,factor*icd.p.log,colour=chapter)) + 
  geom_point(size=0.5) + 
  scale_x_continuous(name = "") +
  scale_y_continuous(name = "", limits = c(-100,300)) +
  geom_text(data = fi.young.analysis.table[variant.type == "META" & level == 2 & sex == "FEMALE" & (var.p.log < 0.57 | icd.p.log > 40)],aes(label=meaning),size=3,nudge_y=0.15) +
  ggtitle("Females") +
  theme.figures + theme(axis.text.y = element_blank(), plot.title = element_text(hjust = 0.5))

female.fi.young

combined.fi.young.top <- male.fi.young + female.fi.young
combined.fi.young.bottom <- grid::textGrob(expression(bold(-log[10]~p~value~`for`~the~effect~of~s[het]~burden==1~on~having~children)))

combined.fi.young <- combined.fi.young.top / combined.fi.young.bottom + plot_layout(heights=c(5,0.05)) + plot_annotation(tag_levels = "A")
combined.fi.young

# ggsave("figures/FigureX.svg",combined.icd,width=10,height=6)

```

### Text-based ORs

```{r Text Based ORs}

## no male fertility genes
no.male.fertility.plot <- make.meta.table(results.excl.male, F, gene.list = "product_sHET_no_male_infertility")

no.male.fertility.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Fertility Gene OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

## no mouse fertility genes
mouse.data <- make.meta.table(results.excl.mouse, F, gene.list = "product_sHET_no_mouse_infertility")

mouse.data[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

## no pathogenic CNV carriers
no.path.cnvs.plot <- make.meta.table(results.fertility.no.path, F)

no.path.cnvs.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," No Path CNVs OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

## Exclude MH patients
no.mh.patients.plot <- make.meta.table(results.fertility.no.mhq, F)

no.mh.patients.plot[[1]][variant.type == "META",paste0(Sex," No MH Patients OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

## Exclude Disease Genes
no.disease.plot <- make.meta.table(results.excl.disease, F, gene.list = "product_sHET_no_disease", ymax = 1.6)

no.disease.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," Disease Gene OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

## Exclude same sex individuals
no.same.sex.plot <- make.meta.table(results.fertility.no.same.sex, F, gene.list = "product_sHET", ymax = 1.6)

no.same.sex.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," Exclude Same Sex OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
```

## 7C. Supplement

### Figures

#### Figure 1.

CNVs Per Individual Figures

```{r Supp Fig 1, fig.height=8, fig.width=8}

ukbb.annotated.cnvs.qcd[,dummy:=1]

totals.delhom <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number==0 & filter.0.95.wes.support.score == T,.(num.del.hom=sum(dummy)),by=c("eid")]
totals.delhet <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number==1 & filter.0.95.wes.support.score == T,.(num.del.het=sum(dummy)),by=c("eid")]
totals.duphet <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number==3 & filter.0.95.wes.support.score == T,.(num.dup.het=sum(dummy)),by=c("eid")]
totals.duphom <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number==4 & filter.0.95.wes.support.score == T,.(num.dup.hom=sum(dummy)),by=c("eid")]
totals.len.del <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number<2 & filter.0.95.wes.support.score == T,.(len.del=sum(Length_bp* abs(Copy_Number - 2))),by=c("eid")]
totals.len.dup <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number>2 & filter.0.95.wes.support.score == T,.(len.dup=sum(Length_bp * abs(Copy_Number - 2))),by=c("eid")]
  
totals.filtered <- merge(totals.delhom,totals.delhet,by="eid",all=T)
totals.filtered <- merge(totals.filtered,totals.duphet,by="eid",all=T)
totals.filtered <- merge(totals.filtered,totals.duphom,by="eid",all=T)
totals.filtered <- merge(totals.filtered,totals.len.del,by="eid",all=T)
totals.filtered <- merge(totals.filtered,totals.len.dup,by="eid",all=T)

totals.filtered <- merge(samples.UKBB.cnv,totals.filtered,by="eid",all.x=T)

totals.filtered[is.na(totals.filtered)] <- 0

totals.filtered[,num.del.sites:=num.del.het+num.del.hom]
totals.filtered[,num.dup.sites:=num.dup.het+num.dup.hom]
totals.filtered[,total:=num.del.sites+num.dup.sites]

## Plot to just do histogram of total sites:
print(paste0("Total Sites    : ", sum(totals.filtered[,total])))
print(paste0("Mean Total     : ", sprintf("%0.02f",mean(totals.filtered[,total])), "±", sprintf("%0.02f",sd(totals.filtered[,total]))))
print(paste0("Median Total   : ", median(totals.filtered[,total])))
print("")
print(paste0("Total DEL Sites : ", sum(totals.filtered[,num.del.sites])))
print(paste0("Mean DEL        : ", sprintf("%0.02f",mean(totals.filtered[,num.del.sites])), "±", sprintf("%0.02f",sd(totals.filtered[,num.del.sites]))))
print(paste0("Median DEL      : ", median(totals.filtered[,num.del.sites])))
print(paste0("Mean DEL Len    : ", sprintf("%0.01f",mean(totals.filtered[,len.del])/1000), "±", sprintf("%0.01f",sd(totals.filtered[,len.del])/1000)))
print("")
print(paste0("Total DUP Sites : ", sum(totals.filtered[,num.dup.sites])))
print(paste0("Mean DUP        : ", sprintf("%0.02f",mean(totals.filtered[,num.dup.sites])), "±", sprintf("%0.02f",sd(totals.filtered[,num.dup.sites]))))
print(paste0("Median DUP      : ", median(totals.filtered[,num.dup.sites])))
print(paste0("Mean DUP Len    : ", sprintf("%0.01f",mean(totals.filtered[,len.dup])/1000), "±", sprintf("%0.01f",sd(totals.filtered[,len.dup])/1000)))

ggplot(totals.filtered, aes(total)) + geom_histogram(binwidth=1,fill="grey",colour="black",size=2) + geom_vline(aes(xintercept=mean(totals.filtered[,total])),colour="red",size=2) + xlab("Sites Per Individual") + ylab("# of Individuals") + theme

## DELs
x.lim<-max(totals.filtered[,num.del.sites])
y.lim<-3.0e6
plot1 <- ggplot(totals.filtered,aes(num.del.sites,len.del)) + geom_point(colour=del.line,size=0.5) + xlim(-1,x.lim) + ylim(-100000,y.lim) + xlab("Total Deletion Sites") + ylab("Cumulative Deletion Length") + theme.figures
x.hist <- ggplot(totals.filtered,aes(num.del.sites)) + geom_histogram(binwidth=1, colour=del.line, fill=del.fill) + xlim(-1,x.lim) + ylab("Count") + theme.figures + theme(axis.title.x=element_blank(),axis.text.x=element_blank())
y.hist <- ggplot(totals.filtered,aes(len.del)) + geom_histogram(binwidth=100000, colour=del.line, fill=del.fill) + xlim(-100000,y.lim) + ylab("Count") + coord_flip() + theme.figures + theme(axis.title.y=element_blank(),axis.text.y=element_blank())

## All the "empty" plots here are just used to push the graphs together.
del.plot <- x.hist + plot_spacer() + plot1 + y.hist + plot_layout(ncol = 2, nrow = 2, widths = c(2,1), heights = c(1,2), tag_level="keep")
del.plot

## DUPs
x.lim<-max(totals.filtered[,num.dup.sites])
y.lim<- 1e7
plot1 <- ggplot(totals.filtered,aes(num.dup.sites,len.dup)) + geom_point(colour=dup.line,size=0.5) + xlim(-1,x.lim) + ylim(-500000,y.lim) + xlab("Total Duplication Sites") + ylab("Cumulative Duplication Length") + theme.figures
x.hist <- ggplot(totals.filtered,aes(num.dup.sites)) + geom_histogram(binwidth=1,colour=dup.line,fill=dup.fill) + xlim(-1,x.lim) + ylab("Count") + theme.figures + theme(axis.title.x=element_blank(),axis.text.x=element_blank())
y.hist <- ggplot(totals.filtered,aes(len.dup)) + geom_histogram(binwidth=500000,colour=dup.line,fill=dup.fill) + xlim(-500000,y.lim) + ylab("Count") + coord_flip() + theme.figures + theme(axis.title.y=element_blank(),axis.text.y=element_blank())

dup.plot <- x.hist + plot_spacer() + plot1 + y.hist + plot_layout(ncol = 2, nrow = 2, widths = c(2,1), heights = c(1,2))
dup.plot

## Calculate Singleton/Maf <1e-3 variants like for SNVs:

samp.size <- nrow(samples.UKBB.cnv)
test <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score == T & ct == "DEL"]

allele.frq <- test[ct=="DEL",sum(gt),by=c("locus")]
allele.frq[,frq:=V1/(samp.size*2)]
setnames(allele.frq,"V1","ac")

test <- merge(test,allele.frq[,c("locus","frq","ac")],by=c("locus"))

cnv.counts <- data.table()

counts <- test[ac == 1 & ct == "DEL", sum(dummy), by = "eid"]
counts <- merge(counts, samples.UKBB.cnv, all.y = T, by = "eid")
counts[,V1:=if_else(is.na(V1),0,V1)]
counts[,AF:="AC1"]
counts[,CSQ:="DEL"]
cnv.counts <- rbind(cnv.counts, counts)

counts <- test[frq <= 1e-3 & ct == "DEL", sum(dummy), by = "eid"]
counts <- merge(counts, samples.UKBB.cnv, all.y = T, by = "eid")
counts[,V1:=if_else(is.na(V1),0,V1)]
counts[,AF:="MAF1e-3"]
counts[,CSQ:="DEL"]
cnv.counts <- rbind(cnv.counts, counts)

samp.size <- nrow(samples.UKBB.cnv)
test <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score == T & ct == "DUP"]

allele.frq <- test[ct=="DUP",sum(gt),by=c("locus")]
allele.frq[,frq:=V1/(samp.size*2)]
setnames(allele.frq,"V1","ac")

test <- merge(test,allele.frq[,c("locus","frq","ac")],by=c("locus"))

counts <- test[ac == 1 & ct == "DUP", sum(dummy), by = "eid"]
counts <- merge(counts, samples.UKBB.cnv, all.y = T, by = "eid")
counts[,V1:=if_else(is.na(V1),0,V1)]
counts[,AF:="AC1"]
counts[,CSQ:="DUP"]
cnv.counts <- rbind(cnv.counts, counts)

counts <- test[frq <= 1e-3 & ct == "DUP", sum(dummy), by = "eid"]
counts <- merge(counts, samples.UKBB.cnv, all.y = T, by = "eid")
counts[,V1:=if_else(is.na(V1),0,V1)]
counts[,AF:="MAF1e-3"]
counts[,CSQ:="DUP"]
cnv.counts <- rbind(cnv.counts, counts)

cnv.counts[,CSQ:=if_else(CSQ == "DEL","Deletions","Duplications")]
cnv.counts[,AF:=if_else(AF=="AC1","Private Vars.","MAF ≤ 1e-3 Vars.")]
cnv.counts[,AF:=factor(AF,levels=c("Private Vars.","MAF ≤ 1e-3 Vars."))]
setnames(cnv.counts,"V1","count")

del.count.plot <- ggplot(cnv.counts[CSQ == "Deletions"],aes(count,fill=AF)) + geom_histogram(binwidth=1, position = "identity", alpha = 0.5) + scale_y_continuous(name = "Number of Individuals") + scale_x_continuous(name = "# of Deletions.",limits = c(-1,6)) + scale_alpha_continuous(range=c(0,1)) + scale_fill_discrete(guide=guide_legend(title="")) + theme.figures.legend
del.count.plot

dup.count.plot <- ggplot(cnv.counts[CSQ == "Duplications"],aes(count,fill=AF)) + geom_histogram(binwidth=1, position = "identity", alpha = 0.5) + scale_y_continuous(name = "") + scale_x_continuous(name = "# of Duplications",limits = c(-1,6)) + scale_alpha_continuous(range=c(0,1)) + scale_fill_discrete(guide=guide_legend(title="")) + theme.figures.legend
dup.count.plot

bottom <- (del.count.plot | dup.count.plot) / guide_area() + plot_layout(guides="collect", heights=c(4,1))

total.plot <- (del.plot | dup.plot) / (bottom) + plot_layout(heights = c(1.7,1))
total.plot

ggsave("figures/supplement/SuppFig1.png",total.plot,dpi = 300,height = 8, width = 8, units = c("in"))

quant.table <- data.table(table(ukbb.annotated.cnvs.qcd[filter.0.95.wes.support.score==T,ct]))
paste0("Number of CNVs (Unfiltered Indiv)  : ",quant.table[,sum(N)], " (DEL: ", quant.table[V1 == "DEL",N], "; DUP: ", quant.table[V1 == "DUP",N],")")
quant.table <- data.table(table(ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score==T,ct]))
paste0("Number of CNVs (Filtered Indiv)    : ",quant.table[,sum(N)], " (DEL: ", quant.table[V1 == "DEL",N], "; DUP: ", quant.table[V1 == "DUP",N],")")
paste0("Number of CNV Loci                 : ",nrow(data.table(table(ukbb.annotated.cnvs.qcd[,locus]))))
rm(quant.table)
```

#### Figure 2.

SNV Counts Per Individual.

```{r Supp Fig 2, fig.height=5, fig.width=8.5}

UKBB.counts <- count.variants(variants.UKBB,samples.UKBB,0.001)
UKBB.counts[,CSQ:=if_else(CSQ == "LOF_HC","PTVs",if_else(CSQ == "MIS","Missense",if_else(CSQ == "SYN","Synonymous",as.character(NA))))]
UKBB.counts[,AF:=if_else(AF=="AC1","Private Vars.","MAF ≤ 1e-3 Vars.")]
UKBB.counts[,AF:=factor(AF,levels=c("Private Vars.","MAF ≤ 1e-3 Vars."))]

all.plot <- ggplot(UKBB.counts,aes(CSQ,count,colour=AF)) + geom_boxplot() + scale_x_discrete(name = "Variant Class") + scale_y_log10(name = "# of Variants") + scale_colour_discrete(guide=guide_legend(title="")) + theme.figures
all.plot

missense.plot <- ggplot(UKBB.counts[CSQ == "Missense"],aes(count,fill=AF)) + geom_histogram(binwidth=1, position = "identity", alpha = 0.5) + scale_y_continuous(name = "Number of Individuals") + scale_x_continuous(name = "# of CADD > 25,\nMPC > 2 Missense Vars.") + scale_alpha_continuous(range=c(0,1)) + scale_fill_discrete(guide=guide_legend(title="")) + theme.figures.legend
missense.plot

ptv.plot <- ggplot(UKBB.counts[CSQ == "PTVs"],aes(count,fill=AF)) + geom_histogram(binwidth=1, position = "identity", alpha = 0.5) + scale_y_continuous(name = "") + scale_x_continuous(name = "# of PTVs") + scale_alpha_continuous(range=c(0,1)) + scale_fill_discrete(guide=guide_legend(title="")) + theme.figures.legend
ptv.plot

syn.plot <- ggplot(UKBB.counts[CSQ == "Synonymous"],aes(count,fill=AF)) + geom_histogram(binwidth=1, position = "identity", alpha = 0.5) + scale_y_continuous(name = "") + scale_x_continuous(name = "# of Synonymous Vars.") + scale_alpha_continuous(range=c(0,1)) + scale_fill_discrete(guide=guide_legend(title="")) + theme.figures.legend
syn.plot

snv.count.plot <- ((missense.plot | ptv.plot | syn.plot | all.plot) / (guide_area())) + plot_layout(guides = "collect", nrow = 2,heights = c(4,1)) + plot_annotation(tag_levels = 'A')
snv.count.plot

ggsave("figures/supplement/SuppFig2.png",snv.count.plot, dpi = 600, height = 5, width = 8.5, units = "in")

paste0("Number of SNV/INDel Variants: ", nrow(variants.UKBB[,]))
```

#### Figure 3.

```{r Supp Fig 3, fig.height=3, fig.width=8.5}

linear.data <- make.meta.table(results.fertility.linear, T, ymin = -1.15, ymax= 0.25, block = -1, p.pos = -1)
linear.data

ggsave("figures/supplement/SuppFig3.png",linear.data[[2]], dpi = 600, height = 3, width = 8.5, units = "in")

linear.data[[1]][variant.type == "META",paste0(Sex, "s have ",sprintf("%0.2f",abs(var.beta))," fewer children", " [95% CI ",sprintf("%0.2f",abs(var.beta+(1.96*var.stderr))), "-",sprintf("%0.2f",abs(var.beta-(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

```

#### Figure 4.

```{r Supp Fig 4, fig.height=3, fig.width=8.5}

remove.zero <- make.meta.table(results.fertility.zero, T, ymin = -1.15, ymax= 0.25, block = -1, p.pos = -1)
remove.zero

ggsave("figures/supplement/SuppFig4.png",remove.zero[[2]], dpi = 600, height = 3, width = 8.5, units = "in")

```

#### Figure 5.

```{r Supp Fig 5, fig.height=6, fig.width=8.5}

gene.data.pli <- make.meta.table(results.fertility.genelists[gene.list == "highPLI"], F, gene.list = "highPLI", alt.y.axis = "Odds Ratio for loss of 1 high (>0.9) pLI gene",ymin=0.4,ymax=1.25,p.pos = 0.5,block = 0.4)
gene.data.pli[[2]] <- gene.data.pli[[2]] + theme(legend.position="blank")

alt.y <- expression(bold(Odds~Ratio~`for`~loss~of~"1"~high~"(" >= 0.15~")"~s[het]~gene))
gene.data.shet <- make.meta.table(results.fertility.genelists[gene.list == "highsHET"], F, gene.list = "highsHET", alt.y.axis = alt.y,ymin=0.4,ymax=1.25,p.pos = 0.5,block = 0.4)
gene.data.shet

combined.gene <- gene.data.pli[[2]] + gene.data.shet[[2]] + plot_layout(nrow = 2, guides = "collect") + plot_annotation(tag_levels = 'A')
combined.gene

ggsave("figures/supplement/SuppFig5.png",combined.gene, dpi = 600, height = 5, width = 8.5, units = "in")
```

#### Figure 6.

```{r Supp Fig 6, fig.height=3, fig.width=8.5}

high.maf.data <- make.meta.table(results.fertility, F, allele.freq = 1e-3, b=0.25)
high.maf.data

ggsave("figures/supplement/SuppFig6.png",high.maf.data[[2]], dpi = 600, height = 3, width = 8.5, units = "in")

```

#### Figure 7.

```{r Supp Fig 7, fig.height=6, fig.width=8.5}

res.age[,Sex:=factor(y.var,levels=c("children.fathered","live.births"),labels=c("Male","Female"))]
res.age[,agePulse:=factor(age,levels=c("ALL","60","50","40"),labels=c("All Ages","60-70","50-60","40-50"))]
res.age[,variantPulse:=factor(variant.type,levels=c("META","LOF_HC","DEL"),labels=c("Meta","PTVs","Dels"))]

ylab <- "Odds Ratio"
yline <- 1
y.axis <- expression(bold(Odds~Ratio~`for`~1~Unit~of~Quantified~s[het]))

plot.breaks <- c(seq(1,-0.75,by=-1 * 0.5),seq(1,2.75,by=0.5))
plot.breaks <- plot.breaks[plot.breaks != -0.5]

plot.ages <- ggplot(res.age,aes(agePulse,var.beta,group=interaction(Sex,variantPulse),colour=Sex,linetype=variantPulse)) +
  geom_hline(aes(yintercept=1),colour="red",linetype=2,size=1) +
  geom_point(aes(size=n.indvs,shape=18),position=position_dodge(0.65)) +
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),width=0.1,position=position_dodge(0.65)) +
  geom_text(aes(y = -0.15, label=paste0("p = ", sprintf("%0.2g",var.p))),position=position_dodge(0.65),size=4,hjust=1,show.legend = F) +
  scale_x_discrete(name = "", position = "top") +
  scale_y_continuous(name=y.axis,limits = c(-0.5,2.75), breaks=plot.breaks) +
  scale_shape_identity() +
  scale_size_area(breaks=c(50000,100000,150000),guide=guide_legend(title="# of Indivs.")) +
  scale_linetype_discrete(guide=guide_legend(reverse = T, title = "Variant Class")) +
  sex.colours.colour.rev +
  coord_flip() +
  theme.figures.legend + theme(panel.grid.major.y = element_blank(), legend.background=element_rect(fill="white"))
plot.ages

ggsave("figures/supplement/SuppFig7.png",plot.ages, dpi = 600, height = 6, width = 8.5, units = "in")
```


#### Figure 8.

```{r Supp Fig 8, fig.height=4, fig.width=8.5}

plottable <- copy(results.fertility)

plottable[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
plottable[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
plottable[,sig.pos:=if_else(var.beta<0,var.ci.lower-0.1,var.ci.upper+0.1)]

plottable[,var.beta:=exp(var.beta)]
plottable[,Sex:=factor(sex,levels=c("1","2"),labels = c("Male","Female"))]
ylab <- "Odds Ratio"
yline <- 1
y.axis <- expression(bold(Odds~Ratio~`for`~1~Unit~of~Quantified~s[het]))

plot.breaks <- c(seq(1,-0.15,by=-1 * 0.25),seq(1,1.25,by=0.25))
plot.breaks <- plot.breaks[plot.breaks != 0]

plot.all.variants <- ggplot(plottable[maf == 0],aes(variant.type,var.beta,group=Sex,colour=Sex)) +
    geom_hline(aes(yintercept=1),colour="red",linetype=2,size=1) +
    geom_point(aes(size=n.indvs,shape=18),position=position_dodge(0.5)) +
    geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),width=0.1,position=position_dodge(0.5)) +
    geom_text(aes(y = 0.05, label=paste0("p = ", sprintf("%0.2g",var.p))),position=position_dodge(0.5),size=4,hjust=1,show.legend = F) +
    scale_x_discrete(name = "", position = "top",labels=c("Dels","Dups","PTVs","Missense\n(CADD > 25, MPC > 2)","Synonymous")) +
    scale_y_continuous(name=y.axis,limits = c(-0.15,1.35), breaks=plot.breaks) +
    scale_shape_identity() +
    scale_size_area(breaks=c(50000,100000,150000),guide=guide_legend(title="# of Indivs.")) +
    sex.colours.colour.rev +
    coord_flip() +
    theme.figures.legend + theme(panel.grid.major.y = element_blank())

plot.all.variants

ggsave("figures/supplement/SuppFig8.png",plot.all.variants, dpi = 600, height = 4, width = 8.5, units = "in")

```

#### Figure 9.

```{r Supp Fig 9, fig.height=5, fig.width=10}

## Has a Private DEL
plot.testis.del.shet.wilcox <- wilcox.test(log.mean ~ has.del, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))
plot.testis.del.shet <- ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(has.del), log.mean, group = as.factor(has.del))) +
  geom_boxplot() +
  scale_x_discrete(name = expression(bold(atop(s[het]>0.15~gene,with~private~Deletion)))) +
  scale_y_continuous(name = expression(bold(Median~log[e]~Testis~Expr.))) +
  annotate("text", x = 1.5, y = 6, size = 4, label = if_else(plot.testis.del.shet.wilcox$p.value < 0.05, paste0("p = ", sprintf("%0.1e", plot.testis.del.shet.wilcox$p.value)),"p > 0.05")) +
  theme

## Has a Private PTV
plot.testis.ptv.shet.wilcox <- wilcox.test(log.mean ~ has.ptv, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))
plot.testis.ptv.shet <- ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(has.ptv), log.mean, group = as.factor(has.ptv))) +
  geom_boxplot() +
  scale_x_discrete(name = expression(bold(atop(s[het]>0.15~gene,with~private~PTV)))) +
  scale_y_continuous(name = "") +
  annotate("text", x = 1.5, y = 6, size = 4, label = if_else(plot.testis.ptv.shet.wilcox$p.value < 0.05, paste0("p = ", sprintf("%0.1e", plot.testis.ptv.shet.wilcox$p.value)),"p > 0.05")) +
  theme

## Is a male infertility gene
plot.male.wilcox <- wilcox.test(log.mean ~ male.infertility, data = shet.genes.expr,alternative=c("less"))
plot.male <- ggplot(shet.genes.expr, aes(as.factor(male.infertility), log.mean, group = as.factor(male.infertility))) + 
  geom_boxplot() +
  scale_x_discrete(name = "Is Male Infertility Gene?") +
  scale_y_continuous(name = "") + 
  annotate("text", x = 1.5, y = 6, size = 4, label = if_else(plot.male.wilcox$p.value < 0.05, paste0("p = ", sprintf("%0.1e", plot.male.wilcox$p.value)),"p > 0.05")) +
  theme

plot.testis <- plot.testis.del.shet + plot.testis.ptv.shet + plot.male + plot_layout(ncol=3, guides = "collect") + plot_annotation(tag_levels='A')
plot.testis

ggsave("figures/supplement/SuppFig9.png",plot.testis, dpi = 300, height = 5, width = 10, units = "in")

```


#### Figure 10.

```{r Supp Fig 10, fig.height=6, fig.width=8}

plot.betas <- function(x.var, type, add.covars = c(), ymin = 0, ymax = 2) {
  
  data <- data.table(sexPulse=c(1,2))
  data[,c("beta","std.error","p.val","tab","model"):=run.lm(sexPulse,x.var,add.covars = add.covars, inc.PCs = T),by=1:nrow(data)]
  
  data <- copy(data)
  data[,var.ci.upper:=exp(beta + (1.96*std.error))]
  data[,var.ci.lower:=exp(beta - (1.96*std.error))]
  data[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
  data[,beta:=exp(beta)]
  data[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
  data[,N:=nrow(tab[[1]]),by=1:nrow(data)]

  ylab <- "Effect on having children (Odds Ratio)"
  
  plot <- ggplot(data,aes(sexPulse,beta,colour=sexPulse)) +
    geom_hline(aes(yintercept=1),colour="red",linetype=2) +
    geom_point() +
    geom_errorbar(aes(ymin=var.ci.lower, ymax=var.ci.upper,colour=sexPulse),width=0) +
    scale_x_discrete(name = "") +
    scale_y_continuous(name = ylab, limits = c(ymin,ymax)) +
    sex.colours.colour.rev +
    coord_flip() +
    theme.figures.legend + 
    ggtitle(type) + 
    theme(panel.grid.major.y=element_blank())
    
  return(list(data,plot))
  
}

partner.beta.plot <- plot.betas("partner.in.house", "Having a Partner at Home",ymax=6)
cog.beta.plot <- plot.betas("fluid.intel", "Fluid Intelligence")
ea.beta.plot <- plot.betas("completed.college", "Completing University")
mhq.beta.plot <- plot.betas("ganna.binary", "Having a Severe MH Trait")
hhi.beta.plot <- plot.betas("household.income", "Household Income", c("partner.in.house","partner.in.house*household.income"))
same.sex.beta.plot <- plot.betas("same.sex", "Engaging in Same Sex Sexual Behaviour")

plot.betas <- partner.beta.plot[[2]] +
  cog.beta.plot[[2]] +
  ea.beta.plot[[2]] +
  mhq.beta.plot[[2]] +
  hhi.beta.plot[[2]] +
  same.sex.beta.plot[[2]] + 
  plot_layout(ncol = 2, guides="collect") + plot_annotation(tag_levels = 'A')

plot.betas

ggsave("figures/supplement/SuppFig10.png",plot.betas, dpi = 600, height = 6, width = 8, units = "in")

same.sex.beta.plot[[1]][,paste0(sexPulse, " Same Sex OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]

mhq.beta.plot[[1]][,paste0(sexPulse, " MH OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]
```

#### Figure 11.

```{r Supp Fig 11, fig.height=3, fig.width=8.5}

same.sex <- make.meta.table(results.same.sex, F, b=0.5, ymin=-0.8, ymax = 4.5, p.pos = -0.2, block = -0.5)
same.sex

ggsave("figures/supplement/SuppFig11.png",same.sex[[2]], dpi = 600, height = 3, width = 8.5, units = "in")

same.sex[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Same Sex OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
```

#### Figure 12a.

```{r Supp Fig 12a, fig.height=3, fig.width=4}

plot.child.fert <- ggplot(model.fertility, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.childlessness_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.childlessness_lower, ymax = mean.childlessness_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Childlessness", limits = c(0.1,0.6)) + theme.figures.legend

plot.child.fert

ggsave("figures/supplement/SuppFig12a.png",plot.child.fert,width=4,height=3,units = "in")

```

#### Figure 12b.

```{r Supp Fig 12b, fig.height = 3, fig.width = 8.5}

## Partner at home
plot.partner <- ggplot(model.partner, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = expected.without.partner_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= expected.without.partner_lower, ymax = expected.without.partner_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Without A Partner") + theme.figures.legend

plot.fert.partner <- ggplot(model.partner, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Fitness", limits = c(0,1.05)) + theme.figures.legend

plot.child.partner <- ggplot(model.partner, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.childlessness_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.childlessness_lower, ymax = mean.childlessness_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Childlessness", limits = c(0.1,0.6)) + theme.figures.legend

partner.fertility.plot <- plot.partner + plot.child.partner + plot.fert.partner + ## Partner at home
  plot_layout(nrow = 1, ncol = 3, guides = "collect") + plot_annotation(tag_levels = 'A')

partner.fertility.plot

ggsave("figures/supplement/SuppFig12b.png",partner.fertility.plot,width=8.5,height=3,units = "in")

```

#### Figure 12c.

```{r Supp Fig 12c, fig.height = 3, fig.width = 8.5}

## Educational Attainment
plot.college <- ggplot(model.ea, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = expected.completed.college_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= expected.completed.college_lower, ymax = expected.completed.college_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted College Completion") + theme.figures.legend

plot.fert.ea <- ggplot(model.ea, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Fitness", limits = c(0,1.05)) + theme.figures.legend

plot.child.ea <- ggplot(model.ea, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.childlessness_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.childlessness_lower, ymax = mean.childlessness_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Childlessness", limits = c(0.1,0.6)) + theme.figures.legend

college.fertility.plot <- plot.college + plot.child.ea + plot.fert.ea + ## EA
  plot_layout(nrow = 1, ncol = 3, guides = "collect") + plot_annotation(tag_levels = 'A')

college.fertility.plot

ggsave("figures/supplement/SuppFig12c.png",college.fertility.plot,width=8.5,height=3,units = "in")
```

#### Figure 12d.

```{r Supp Fig 12d, fig.height = 3, fig.width = 8.5}

## Cognition
plot.iq <- ggplot(model.cog, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = expected.iq_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= expected.iq_lower, ymax = expected.iq_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted IQ") + theme.figures.legend

plot.fert.iq <- ggplot(model.cog, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Fitness", limits = c(0.9,1.05)) + theme.figures.legend

plot.child.iq <- ggplot(model.cog, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.childlessness_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.childlessness_lower, ymax = mean.childlessness_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Childlessness", limits = c(0.1,0.3)) + theme.figures.legend

cognition.fertility.plot <- plot.iq + plot.child.iq + plot.fert.iq + ## Cognition
  plot_layout(nrow = 1, ncol = 3, guides = "collect") + plot_annotation(tag_levels = 'A')

cognition.fertility.plot

ggsave("figures/supplement/SuppFig12d.png",cognition.fertility.plot,width=8.5,height=3,units = "in")
```

#### Figure 12e.

```{r Supp Fig 12d, fig.height = 6, fig.width = 8.5}

plot.mh <- ggplot(model.mhq, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.has.disorder_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.has.disorder_lower, ymax = mean.has.disorder_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "", limits = c(0,0.125)) + ggtitle("Combined") + theme.figures + theme(plot.title = element_text(hjust=0.5, size = 10))

plot.fert.mh <- ggplot(model.mhq, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Fitness", limits = c(0.8,1.05)) + theme.figures.legend

inc.plot.scizo <- ggplot(inc.mht[condition == "scizo"], aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= lower, ymax = upper),alpha=0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Incidence", limits = c(0,0.125)) + theme.figures + ggtitle ("Schizophrenia") + theme(plot.title = element_text(hjust=0.5, size = 10))

inc.plot.asd <- ggplot(inc.mht[condition == "asd"], aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= lower, ymax = upper),alpha=0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "", limits = c(0,0.125)) + theme.figures + ggtitle ("ASD") + theme(plot.title = element_text(hjust=0.5, size = 10))

inc.plot.bipolar <- ggplot(inc.mht[condition == "bipolar"], aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= lower, ymax = upper),alpha=0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "", limits = c(0,0.125)) + ggtitle ("Bipolar Disorder") + theme.figures + theme(plot.title = element_text(hjust=0.5, size = 10))

mh.fertility.plot.top <- inc.plot.scizo + inc.plot.asd + inc.plot.bipolar + plot.mh + plot_layout(nrow = 1, ncol = 4, guides = "collect") ## MH Incidence
mh.fertility.plot.bottom <- plot_spacer() + plot.fert.mh + guide_area() + plot_layout(nrow = 1, ncol = 3, guides = "collect") ## MH

mh.fertility.plot <- mh.fertility.plot.top / mh.fertility.plot.bottom + plot_annotation(tag_levels = 'A') + plot_layout(guides = "collect")
mh.fertility.plot

ggsave("figures/supplement/SuppFig12e.png",mh.fertility.plot, dpi = 300, height = 6, width = 8.5, units = "in")

```

#### Figure 13.

```{r Supp Fig 13, fig.height=4, fig.width=8}

cog.fit.plot <- ggplot(cog.raw) + geom_ribbon(data = cog.raw[newiq<120],aes(x=newiq, ymin=Mean-ci,ymax=Mean+ci),colour="grey",alpha=0.3) + geom_line(data = cog.raw[newiq<120],aes(x=newiq, y=Mean),colour="black", size = 1) + geom_line(aes(x = newiq, y=pred.log),colour="red", size = 0.8, linetype = 2) + scale_x_continuous(name = "IQ", limits=c(0,140)) + scale_y_continuous(name = "Average Children", limits=c(-0.1,2)) + scale_alpha_continuous(range=c(0,1)) + theme.figures.legend

child.fit.plot <- ggplot(childless.raw) + geom_ribbon(data = childless.raw[iq<120],aes(x= iq,ymin=ci.lower,ymax=ci.upper),colour="grey",alpha=0.3) + geom_line(data = childless.raw[iq<120],aes(x=iq, y=inc.childlessness),colour="black", size = 1) + geom_line(aes(x = iq, y=pred.log.inv),colour="red", size = 0.8, linetype = 2) + scale_x_continuous(name = "IQ", limits=c(0,140)) + scale_y_continuous(name = "Increased Childlessness from Baseline", limits=c(-0.1,1)) + scale_alpha_continuous(range=c(0,1)) + theme.figures.legend

cog.fit.plots <- cog.fit.plot + child.fit.plot + plot_layout(nrow=1, guides = "collect") + plot_annotation(tag_levels = 'A')

cog.fit.plots

ggsave("figures/supplement/SuppFig13.png",cog.fit.plots, dpi = 600, height = 5, width = 8, units = "in")
```


#### Figure 14.

```{r Supp Fig 14, fig.height=6, fig.width=8.5}

email.data <- make.meta.table(results.email, F, b=0.25, ymax = 1.3,title = "Has Email?")
email.data

answered.mhq.data <- make.meta.table(results.answered.mhq, F, b=0.25, ymax = 1.3, title = "Answered MH Questionnaire?")
answered.mhq.data

bias.plots <- email.data[[2]] + answered.mhq.data[[2]] + plot_layout(guides = "collect", nrow = 2) + plot_annotation(tag_levels = 'A')
bias.plots

ggsave("figures/supplement/SuppFig14.png",bias.plots, dpi = 600, height = 6, width = 8.5, units = "in")

email.data[[1]][ variant.type == "META",paste0(Sex, " Email OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

answered.mhq.data[[1]][ variant.type == "META",paste0(Sex, " MHQ OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
```

#### Figure 15.

```{r Supp Fig 15, fig.height=5, fig.width=8}

## Grab relevant columns from phenotype data
birth.stats <- UKBB.phenotype.data[,c("eid","children.fathered","live.births","sexPulse","agePulse")]
birth.stats[,dummy:=1]

## Tabualte if individuals had children dependent on their sex
birth.stats <- birth.stats[!is.na(children.fathered) | !is.na(live.births)]
birth.stats[,has.children:=if_else(sexPulse == 1, if_else(children.fathered>0,1,0), if_else(live.births>0,1,0))]

## Calulcate birth stats for...
# men
men <- birth.stats[(children.fathered >= 0 & sexPulse == 1),list(mean(children.fathered),sd(children.fathered),mean(has.children),sd(has.children),sum(dummy)),by="agePulse"]
men[,y.var:="children.fathered"]

# women
women <- birth.stats[(live.births >= 0 & sexPulse == 2),list(mean(live.births),sd(live.births),mean(has.children),sd(has.children),sum(dummy)),by="agePulse"]
women[,y.var:="live.births"]

agePlot <- bind_rows(men,women)
setnames(agePlot,c("V1","V2","V3","V4","V5"),c("mean.births","sd.births","mean.childlessness","sd.childlessness","n"))
agePlot[,ci.births:=1.96*(sd.births/sqrt(n))]
agePlot[,ci.childlessness:=1.96*(sd.childlessness/sqrt(n))]

## Get rid of categories with < 10 individuals
agePlot <- agePlot[n >= 10]

## Invert childlessness for plotting purposes
agePlot[,mean.childlessness:=1-mean.childlessness]

## Factorize sex
agePlot[,sexPulse:=factor(y.var,levels=c("children.fathered","live.births"),labels=c("Male","Female"))]

## Plot of mean number of children
plot.children <- ggplot(agePlot,aes(agePulse,mean.births,group=y.var,colour=sexPulse)) + geom_point(position=position_dodge(0.5)) + geom_errorbar(aes(ymin=mean.births-ci.births,ymax=mean.births+ci.births),width=0.1,position=position_dodge(0.5)) + xlab("") + ylab("Average Births") + sex.colours.colour + theme.figures.legend + theme(axis.text.x=element_blank())

## Plot of mean childlessness
plot.childlessness <- ggplot(agePlot,aes(agePulse,mean.childlessness*100,group=y.var,colour=sexPulse)) + geom_point(position=position_dodge(0.5)) + geom_errorbar(aes(ymin=(mean.childlessness-ci.childlessness)*100,ymax=(mean.childlessness+ci.childlessness)*100),width=0.1,position=position_dodge(0.5)) + xlab("Age") + ylab("% Childless") + sex.colours.colour + theme.figures.legend

## Use patchwork to mash them together
children.plots <- plot.children / plot.childlessness + plot_layout(guides="collect") + plot_annotation(tag_levels = 'A')
children.plots

ggsave("figures/supplement/SuppFig15.png",children.plots, dpi = 600, height = 5, width = 8, units = "in")
```

#### Figure X1.

```{r Supp Fig XX, fig.height=7.5, fig.width=8.5}

cassa.data <- make.meta.table(results.fertility.cassa, F, allele.freq = 0, b=0.25)

del.shet.r2 <- sprintf("%0.3f",summary(lm(product_sHET ~ product_sHET_old,data = variant.counts[type == "DEL" & allele.freq == 0]))$r.squared)

del.shet.plot <- ggplot(variant.counts[type == "DEL" & allele.freq == 0],aes(product_sHET, product_sHET_old)) + 
  geom_point(size=0.25) + 
  scale_x_continuous(name = expression(bold(s[het]~burden~Weghorn~et~al.)),limits=c(0,1)) +
  scale_y_continuous(name = expression(bold(s[het]~burden~Cassa~et~al.)),limits=c(0,1)) +
  annotate("text",label = bquote(r^2 == .(del.shet.r2)), x = 0.12,y=0.9,size=3.5,colour="red") + 
  ggtitle(expression(bold(Deletion~s[het]))) +
  theme.figures + theme(plot.title = element_text(hjust = 0.5))

ptv.shet.r2 <- sprintf("%0.3f",summary(lm(product_sHET ~ product_sHET_old,data = variant.counts[type == "LOF_HC" & allele.freq == 0]))$r.squared)

ptv.shet.plot <- ggplot(variant.counts[type == "LOF_HC" & allele.freq == 0],aes(product_sHET, product_sHET_old)) + 
  geom_point(size=0.25) + 
  scale_x_continuous(name = expression(bold(s[het]~burden~Weghorn~et~al.)),limits=c(0,1)) +
  scale_y_continuous(name = expression(bold(s[het]~burden~Cassa~et~al.)),limits=c(0,1)) +
  annotate("text",label = bquote(r^2 == .(ptv.shet.r2)), x = 0.12,y=0.9,size=3.5,colour="red") + 
  ggtitle(expression(bold(PTV~s[het]))) +
  theme.figures + theme(plot.title = element_text(hjust = 0.5))

top <- del.shet.plot + ptv.shet.plot + plot_layout(ncol = 2, nrow = 1)
bottom <- cassa.data[[2]] + plot_spacer() + plot_layout(ncol = 2, nrow = 1, widths = c(1,0.001))

shet.comp.plot <- (top / bottom) + plot_layout(heights = c(2,1)) + plot_annotation(tag_levels = 'A')
shet.comp.plot

ggsave("figures/supplement/SuppFigX1.png",shet.comp.plot, dpi = 600, height = 7.5, width = 8.5, units = "in")

cassa.data[[1]][ variant.type == "META",paste0(Sex, " OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

```

#### Figure X2. 

```{r Figure X2, fig.height=7, fig.width=8.5}

plot.fruit <- make.meta.table(results.fruit, T, ymin = -0.7, ymax= 0.4, block = -1, p.pos = -0.6, title = "Fresh Fruit Intake\nPer Day")
plot.hands <- make.meta.table(results.handedness, F, b = 0.25, title = "Is Left Handed?", ymax = 3.0)
plot.hair <- make.meta.table(results.hair, F, b = 0.25, title = "Blonde Hair?", ymax = 3.0)

plot.neutrals <- plot.fruit[[2]] + plot.hands[[2]] + plot.hair[[2]] + plot_layout(nrow = 3, ncol = 1, guides = 'collect') + plot_annotation(tag_levels = 'A')
plot.neutrals

ggsave("figures/supplement/SuppFigX2.png",plot.neutrals, dpi = 600, height = 7, width = 8.5, units = "in")
```

#### Figure X3.

```{r Figure X3, fig.height=5, fig.width=7}

pc.effect.plot <- ggplot(pc.effects.table,aes(pc.num,`var.beta`)) + 
  geom_point() + 
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),width=0) + 
  scale_x_continuous(name = "Ancestry Principal Component", limits = c(1,30)) +
  scale_y_continuous(name = "OR for effect the of PC\non having children") +
  theme.figures

pc.num.plot <- ggplot(results.pcs.meta,aes(PCs,log.p)) + 
  geom_point(size = 2) + 
  scale_x_discrete(name = "PCs Included in Regression", limits=results.pcs.meta[,PCs]) + 
  scale_y_continuous(name = expression(bold(atop(-log[10]~p~from,meta~analysis))), limits = c(0,15)) +
  theme.figures

pc.plots <- pc.effect.plot + pc.num.plot + plot_annotation(tag_levels = 'A') + plot_layout(nrow = 2, heights = c(2,1))
pc.plots

ggsave("figures/supplement/SuppFigX3.png",pc.plots, dpi = 600, height = 5, width = 7, units = "in")

```

#### Figure X4 & X5.

This plots ALL ICD-10 code associations with corresponding p-value

```{r Supp Fig X5, fig.height=11, fig.width=8}

plot.icd <- function(l, s, icd.data, lims, p.lim, show.x = F) {
  
  if (l == 4) {
    t <- "Level 4 - Disease Subtypes/Body Sites"
  } else if (l == 3) {
    t <- "Level 3 - Specific Diseases"
  } else if (l == 2) {
    t <- "Level 2 - Disease Blocks"
  } else if (l == 1) {
    t <- "Level 1 - ICD Chapters"
  }
  
  adj.theme <- theme.figures + theme(panel.grid.major.x = element_blank(), panel.grid.minor.x=element_line(colour="grey",size=0.5))
  if (show.x == F) {
    adj.theme <- adj.theme + theme(axis.text.x = element_blank())
  }
  
  icd.plot <- ggplot(icd.data[variant.type == "META" & level==l & sex == s],aes(chapter,var.or,colour=chapter,group=coding,shape=sex)) + 
    geom_point(position=position_dodge(1)) + 
    scale_x_discrete(drop = F, name = if_else(show.x == T, "ICD-10 Chapter", "")) +
    scale_y_continuous(name = "Meta-analysis Odds Ratio", limits = lims) +
    geom_text(data = icd.data[variant.type == "META" & level == l & sex == s & var.p.log < p.lim],aes(label=meaning),size=3,nudge_y=0.0005) +
    ggtitle(t) +
    adj.theme
    
  return(icd.plot)
  
}

meta.icd.plot.male <- plot.icd(4, "MALE", hes.analysis.table, c(0.28,0.291), 13.85) +
  plot.icd(3, "MALE", hes.analysis.table, c(0.28,0.291), 13.85) +
  plot.icd(2, "MALE", hes.analysis.table, c(0.28,0.291), 13.85) +
  plot.icd(1, "MALE", hes.analysis.table, c(0.28,0.291), 13.85, show.x = T) +
  plot_layout(nrow = 4)

meta.icd.plot.male
ggsave("figures/supplement/SuppFigX4.png",meta.icd.plot.male,width=8,height=11)

meta.icd.plot.female <- plot.icd(4, "FEMALE", hes.analysis.table, c(0.67,0.72), 1.34) +
  plot.icd(3, "FEMALE", hes.analysis.table, c(0.67,0.72), 1.34) +
  plot.icd(2, "FEMALE", hes.analysis.table, c(0.67,0.72), 1.34) +
  plot.icd(1, "FEMALE", hes.analysis.table, c(0.67,0.72), 1.34, show.x = T) +
  plot_layout(nrow = 4)

meta.icd.plot.female
ggsave("figures/supplement/SuppFigX5.png",meta.icd.plot.female,width=8,height=11)

```


```{r Supp Fig X5, fig.height=8.5, fig.width=8}

meta.fi.plot.male <- plot.icd(3, "MALE", fi.analysis.table, c(0.270,0.286), 8.1) +
  plot.icd(2, "MALE", fi.analysis.table, c(0.270,0.286), 8.1) +
  plot.icd(1, "MALE", fi.analysis.table, c(0.270,0.286), 8.1, show.x = T) +
  plot_layout(nrow = 3)

meta.fi.plot.male

meta.fi.plot.female <- plot.icd(3, "FEMALE", fi.analysis.table, c(0.73,0.795), 0.57) +
  plot.icd(2, "FEMALE", fi.analysis.table, c(0.73,0.795), 0.5) +
  plot.icd(1, "FEMALE", fi.analysis.table, c(0.73,0.795), 0.5, show.x = T) +
  plot_layout(nrow = 3)

meta.fi.plot.female

```

```{r Supp Fig X5, fig.height=8.5, fig.width=8}

meta.fi.young.plot.male <- plot.icd(3, "MALE", fi.young.analysis.table, c(0.270,0.286), 8.1) +
  plot.icd(2, "MALE", fi.young.analysis.table, c(0.270,0.286), 8.1) +
  plot.icd(1, "MALE", fi.young.analysis.table, c(0.270,0.286), 8.1, show.x = T) +
  plot_layout(nrow = 3)

meta.fi.young.plot.male

meta.fi.young.plot.female <- plot.icd(3, "FEMALE", fi.young.analysis.table, c(0.73,0.795), 0.57) +
  plot.icd(2, "FEMALE", fi.young.analysis.table, c(0.73,0.795), 0.5) +
  plot.icd(1, "FEMALE", fi.young.analysis.table, c(0.73,0.795), 0.5, show.x = T) +
  plot_layout(nrow = 3)

meta.fi.young.plot.female


```

#### Figure X6

```{r Figure X6, fig.height=3, fig.width=8.5}

fi.only.data <- make.meta.table(results.fertility.FI.only, F, ymax = 1.7, b=0.25)
fi.only.data

ggsave("figures/supplement/SuppFigX6.png",fi.only.data[[2]], dpi = 600, height = 3, width = 8.5, units = "in")

fi.only.data[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," Exclude non-FI OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

```

### Tables

#### Table 1

This table was manually created. Not necessary to automate the process.

#### Table 2

This table was manually created. Not necessary to automate the process.

#### Table 3

Tabulate ORs and Effect Sizes estimated in this manuscript:

```{r Supp Table 3}

format.table <- function(t, var, is.OR, rel.fig) {
  
  t <- copy(t)
  t <- t[,c("variant.type","var.beta","var.stderr","var.p","n.indvs","Sex")]
  t[,variant.type:=if_else(variant.type=="LOF_HC","PTV",
                           if_else(variant.type=="DEL","Deletion",
                                   if_else(variant.type=="DUP","Duplication",
                                           if_else(variant.type=="MIS","Missense",
                                                   if_else(variant.type=="SYN","Synonymous",
                                                           if_else(variant.type=="META","Meta-analysis (PTV+Deletion)","ERR"))))))]
  setnames(t,names(t),c("Variant Type","Effect (OR/Beta)","std. err.","p. value","N","Sex"))
  t[,`Effect Type`:=if_else(is.OR==T,"OR","beta")]
  t[,Phenotype:=var]
  t[,`Relevant Figure`:=rel.fig]
  return(t)
  
}

# shet on phenotype
## Figure 1
supptable3a <- format.table(plot.a[[1]],"Childlessness",T,"Figure1A") ## Main fertility

## Figure 2
supptable3a <- bind_rows(supptable3a,format.table(fig.partner[[1]],"Partner At Home",T,"Figure2A")) ## Partner at home
supptable3a <- bind_rows(supptable3a,format.table(fig.ea[[1]],"Educational Attainment",T,"Figure2B")) ## EA
supptable3a <- bind_rows(supptable3a,format.table(fig.hhi[[1]],"Household Income",F,"Figure2C")) ## HHI
supptable3a <- bind_rows(supptable3a,format.table(fig.cog[[1]],"Fluid Intel.",F,"Figure2D")) ## Cognition

## Supp Fig 3
supptable3a <- bind_rows(supptable3a,format.table(linear.data[[1]],"Num. Children",F,"SupFig3")) ## Linear rather than logistic fertility

## Sup Fig 4
supptable3a <- bind_rows(supptable3a,format.table(remove.zero[[1]],"Indv. w/children only",F,"SupFig4")) ## no childless individuals

## Supp Fig 5
supptable3a <- bind_rows(supptable3a,format.table(gene.data.pli[[1]],"high pLI",T,"SupFig5A")) ## pli on childlessness
supptable3a <- bind_rows(supptable3a,format.table(gene.data.shet[[1]],"high sHET",T,"SupFig5B")) ## shet on childlessness

## Supp Fig 6
supptable3a <- bind_rows(supptable3a,format.table(high.maf.data[[1]],"MAF ≤1e-3",T,"SupFig6")) ## maf ≤1e-3 variants

## Sup Fig 7
supptable3a <- bind_rows(supptable3a,format.table(res.age[age==40],"Age Group 40-50",T,"SupFig7")) ## age 40-50
supptable3a <- bind_rows(supptable3a,format.table(res.age[age==50],"Age Group 50-60",T,"SupFig7")) ## age 50-60
supptable3a <- bind_rows(supptable3a,format.table(res.age[age==60],"Age Group 60-70",T,"SupFig7")) ## age 60-70

## Sup Fig 7
supptable3a <- bind_rows(supptable3a,format.table(plottable[maf == 0],"All Variant Classes",T,"SupFig8")) ## All variant classes

## Sup Fig 11
supptable3a <- bind_rows(supptable3a,format.table(same.sex[[1]],"Same Sex Sexual Behaviour",T,"SupFig11")) ## Same sex sexual behaviour

## Sup Fig 14
supptable3a <- bind_rows(supptable3a,format.table(email.data[[1]],"Has Email",T,"SupFig14A")) ## email
supptable3a <- bind_rows(supptable3a,format.table(answered.mhq.data[[1]],"Answered MHQ",T,"SupFig14B")) ## answered MHQ

## Text-based
supptable3a <- bind_rows(supptable3a,format.table(no.male.fertility.plot[[1]],"No Male Infertility Genes",T,"TextOnly")) ## result w/o male infertility genes
supptable3a <- bind_rows(supptable3a,format.table(no.path.cnvs.plot[[1]],"No Pathogenic CNV carriers",T,"TextOnly")) ## no pathogenic CNV carriers
supptable3a <- bind_rows(supptable3a,format.table(no.mh.patients.plot[[1]],"No MH Patients",T,"TextOnly")) ## no MH patients
supptable3a <- bind_rows(supptable3a,format.table(no.disease.plot[[1]],"No Disease Genes",T,"TextOnly")) ## no Disease genes
supptable3a <- bind_rows(supptable3a,format.table(mouse.data[[1]],"No Mouse Infertility",T,"TextOnly")) ## no mouse infertility
supptable3a <- bind_rows(supptable3a,format.table(no.same.sex.plot[[1]],"No Same Sex Individuals",T,"TextOnly")) ## no same sex individuals

format.table <- function(t, var, rel.fig) {
  
  t <- copy(t)
  t <- t[,c("beta","std.error","p.val","N","sexPulse")]
  setnames(t,names(t),c("Effect (OR/Beta)","std. err.","p. value","N","Sex"))
  t[,`Variant Type`:='NA']
  setcolorder(t,c("Variant Type","Effect (OR/Beta)","std. err.","p. value","N","Sex"))
  t[,`Effect Type`:="OR"]
  t[,Phenotype:=var]
  t[,`Relevant Figure`:=rel.fig]
  
  return(t)
  
}

supptable3b <- format.table(partner.beta.plot[[1]], "Partner  At Home","SupFig10A")
supptable3b <- bind_rows(supptable3b,format.table(cog.beta.plot[[1]], "Fluid Intel.","SupFig10B"))
supptable3b <- bind_rows(supptable3b,format.table(ea.beta.plot[[1]], "Educational Attainment","SupFig10C"))
supptable3b <- bind_rows(supptable3b,format.table(mhq.beta.plot[[1]], "Mental Health Traits","SupFig10D"))
supptable3b <- bind_rows(supptable3b,format.table(hhi.beta.plot[[1]], "Household Income","SupFig10E"))
supptable3b <- bind_rows(supptable3b,format.table(same.sex.beta.plot[[1]], "Same Sex Sexual Behaviour","SupFig10F"))

write.table(supptable3a,"figures/supplement/SuppTable3a.tsv",col.names=T,row.names=F,sep="\t",quote=F)
write.table(supptable3b,"figures/supplement/SuppTable3b.tsv",col.names=T,row.names=F,sep="\t",quote=F)

supptable3a[,formated:=if_else(`Effect Type`=="OR",
                     paste0("OR=",sprintf("%0.2f",`Effect (OR/Beta)`), " [95% CI ",sprintf("%0.2f",exp(log(`Effect (OR/Beta)`)-(1.96*`std. err.`))), "-",sprintf("%0.2f",exp(log(`Effect (OR/Beta)`)+(1.96*`std. err.`))),"]", " p=",if_else(`p. value`<=1e-2,sprintf("%0.1e",`p. value`),sprintf("%0.2f",`p. value`))),
                     paste0("Beta=",sprintf("%0.2f",`Effect (OR/Beta)`), " [95% CI ",sprintf("%0.2f",`Effect (OR/Beta)`-(1.96*`std. err.`)), "-",sprintf("%0.2f",`Effect (OR/Beta)`+(1.96*`std. err.`)),"]", " p=",if_else(`p. value`<=1e-2,sprintf("%0.1e",`p. value`),sprintf("%0.2f",`p. value`))))]

supptable3b[,formated:=paste0("OR=",sprintf("%0.2f",`Effect (OR/Beta)`), " [95% CI ",sprintf("%0.2f",exp(log(`Effect (OR/Beta)`)-(1.96*`std. err.`))), "-",sprintf("%0.2f",exp(log(`Effect (OR/Beta)`)+(1.96*`std. err.`))),"]", " p=",if_else(`p. value`<=1e-2,sprintf("%0.1e",`p. value`),sprintf("%0.2f",`p. value`)))]


```

#### Table 4

```{r Supp Table 4}

supptable4 <- merge(cog.raw[,c("newiq","Obs","Mean","SD","pred.log")],childless.raw[,c("iq","inc.childlessness","std. err.","pred.log.inv")],by.x="newiq",by.y="iq")
supptable4[,sd_childlessness:=`std. err.`*sqrt(Obs)]
supptable4[,`std. err.`:=NULL]

setnames(supptable4,names(supptable4),c("IQ","n_individuals","observed_fertility_mean","observed_fertility_sd","predicted_fertility","observed_increased_childlessness","predicted_increased_childlessness","observed_increased_childlessness_sd"))
setcolorder(supptable4,c("IQ","n_individuals","observed_fertility_mean","observed_fertility_sd","predicted_fertility","observed_increased_childlessness","observed_increased_childlessness_sd","predicted_increased_childlessness"))

write.table(supptable4,"figures/supplement/SuppTable4.tsv",col.names=T,row.names=F,sep="\t",quote=F)

```

#### Table 5

```{r Supp table 5}

supptable5 <- modeling[,c("or","or.upper","n.indv","sex.ratio","ratio","trait","sex","mean.children","incidence","or.lower")]
setnames(supptable5,names(supptable5),c("OR.ganna","OR.upper.ganna","N.power","sex.ratio.power","fertility.ratio.power","trait","sex","mean.children.power","incidence.power","OR.lower.ganna"))
setcolorder(supptable5,c("sex","trait","OR.ganna","OR.lower.ganna","OR.upper.ganna","N.power","sex.ratio.power","incidence.power","fertility.ratio.power","mean.children.power"))
write.table(supptable5,"figures/supplement/SuppTable5.tsv",col.names=T,row.names=F,quote=F,sep="\t")

```

#### Table X

```{r Supp table X}

## HES Data
supptable6a <- data.table(pivot_wider(hes.analysis.table[variant.type == "META",c("sex","coding","meaning","chapter","level","var.or","var.err","var.p","icd.or","icd.err","icd.p","N")],names_from=sex, values_from = starts_with(c("var","icd","N")), names_sep = "."))

col.order <- c(names(supptable6a)[grepl("var|icd|N",names(supptable6a)) == F],names(supptable6a)[grepl("\\.MALE",names(supptable6a),perl = T)],names(supptable6a)[grepl("FEMALE",names(supptable6a))])

setcolorder(supptable6a, col.order)

write.table(supptable6a, "figures/supplement/SuppTableXa.tsv",col.names=T,row.names=F,quote=F,sep="\t")

## FI Data
supptable6b <- data.table(pivot_wider(fi.analysis.table[variant.type == "META",c("sex","coding","meaning","chapter","level","var.or","var.err","var.p","icd.or","icd.err","icd.p","N")],names_from=sex, values_from = starts_with(c("var","icd","N")), names_sep = "."))

col.order <- c(names(supptable6b)[grepl("var|icd|N",names(supptable6b)) == F],names(supptable6b)[grepl("\\.MALE",names(supptable6b),perl = T)],names(supptable6b)[grepl("FEMALE",names(supptable6b))])

setcolorder(supptable6b, col.order)

write.table(supptable6b, "figures/supplement/SuppTableXb.tsv",col.names=T,row.names=F,quote=F,sep="\t")
```

## 7D. Numbers Catalogue

This documents all numbers in the manuscript printed in rough order. These are just replicated from above.

```{r Numbers Catalogue}

## Median age and range
paste0("Median age                                     : ", UKBB.phenotype.data[,median(agePulse)], " (range ", UKBB.phenotype.data[,min(agePulse)], "-", UKBB.phenotype.data[,max(agePulse)],")")
paste0("")

## Number of Individuals per datatype:
paste0("Number of individuals with CNV data            : ", length(unique(variant.counts[type == "DEL" & allele.freq == 0,sample_id])))
paste0("Number of individuals with SNV data            : ", length(unique(variant.counts[type == "LOF_HC" & allele.freq == 0,sample_id])))
paste0("")

## Sex Burden of sHET:
format.sex.burden.DEL
format.sex.burden.PTV
paste0("")

## Linear Fertility Model (# Children ~ sHET Burden):
linear.data[[1]][variant.type == "META",paste0(Sex, "s have ",sprintf("%0.2f",abs(var.beta))," fewer children", " [95% CI ",sprintf("%0.2f",abs(var.beta+(1.96*var.stderr))), "-",sprintf("%0.2f",abs(var.beta-(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## Logistic Fertility Model (Childless ~ sHET Burden):
plot.a[[1]][ variant.type == "META",paste0(Sex, " OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## Sex of participants:
paste0("Percentage of females                          : ", sprintf("%0.0f", (nrow(UKBB.phenotype.data[sexPulse == 2]) / nrow(UKBB.phenotype.data))*100), "%")
paste0("")

## No Disease Genes:
no.disease.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," Disease Gene OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## No Male Infertility Genes:
print(paste0("Number of male infertility genes: ", nrow(male.infertility.genes)))
no.male.fertility.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Fertility Gene OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## No Mouse Infertility Genes:
print(paste0("Number of mouse infertility genes: ", nrow(mouse.infertility.genes)))
mouse.data[[1]][ variant.type == "META",paste0(Sex, " OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## Male Infertility
## HES
hes.analysis.table[coding == "N46" & sex == "MALE" & variant.type == "META", paste0("OR=",sprintf("%0.2f",var.or), " [95% CI ",sprintf("%0.2f",exp(log(var.or)-(1.96*var.err))), "-",sprintf("%0.2f",exp(log(var.or)+(1.96*var.err))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")
## FI
fi.analysis.table[coding == "N46" & sex == "MALE" & variant.type == "META", paste0("OR=",sprintf("%0.2f",var.or), " [95% CI ",sprintf("%0.2f",exp(log(var.or)-(1.96*var.err))), "-",sprintf("%0.2f",exp(log(var.or)+(1.96*var.err))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

## Living with a Partner and having children:
partner.beta.plot[[1]][sexPulse == "Male",paste0(sexPulse, " MH OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]
paste0("")

## No Partner ICD-10
hes.analysis.table[meaning == "Z60.2 Living alone" & sex == "MALE" & variant.type == "META", paste0("OR=",sprintf("%0.2f",icd.or), " [95% CI ",sprintf("%0.2f",exp(log(icd.or)-(1.96*icd.err))), "-",sprintf("%0.2f",exp(log(icd.or)+(1.96*icd.err))),"]", " p=",if_else(icd.p<=1e-2,sprintf("%0.1e",icd.p),sprintf("%0.2f",icd.p)))]
paste0("")

## Same Sex
same.sex[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Same Sex sHET OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
same.sex.beta.plot[[1]][,paste0(sexPulse, " Same Sex Phenotype OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]
no.same.sex.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," Exclude Same Sex OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

##Fluid Intel Contrib to Fitness:
paste0("Number of Fluid Intel Indv: ", sum(fig.cog[[1]][variant.type == "META",n.indvs]), " (Male: ",fig.cog[[1]][Sex == "Male" & variant.type == "META",n.indvs],"; Female: ", fig.cog[[1]][Sex == "Female" & variant.type == "META",n.indvs], ")")
paste0("Contribution of Cognition to Fitness: ",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       "% (",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       "%)")
paste0("")

## UKBB Biases
email.data[[1]][ variant.type == "META",paste0(Sex, " Email OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
answered.mhq.data[[1]][ variant.type == "META",paste0(Sex, " MHQ OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## MH Childlessness:
mhq.beta.plot[[1]][,paste0(sexPulse, " MH OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]
paste0("")

## Path CNV Counts/Tests:
paste0("CNV Carriers account for ",sprintf("%0.1f",(length(unique(path.cnv.counts[,eid]))/nrow(samples.UKBB.cnv)*100)),"% (", length(unique(path.cnv.counts[,eid])),") of individuals.)")
no.path.cnvs.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," No Path CNVs OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## MH Contribution to Fitness:
no.mh.patients.plot[[1]][variant.type == "META",paste0(Sex," No MH Patients OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("Contribution of MHTs to Fitness: ",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       "% (",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       "%)")
paste0("")

## Partner at Home Contribution to Fitness:
paste0("Contribution of Partner at Home to Fitness: ",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       "% (",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       "%)")
paste0("")

## Overall contribution to Fitness:
paste0("Contribution of sHET to Fitness (sex averaged): ",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_mid)])*100)),
       "% (",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_upper)])*100)),
       " - ",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_lower)])*100)),
       "%)")
paste0("")

## Number of Individuals
paste0("Number of Broadly Euro Indiv                   : ", table(UKBB.raw.phenotypes[,`22006-0.0`]))
paste0("Number of Individuals after filtering relateds : ", nrow(UKBB.phenotype.data))
paste0("")

## Total CNVs:
paste0("Number of raw CNVs: ",nrow(ukbb.annotated.cnvs.qcd[eid %in% has.cnv.data[has_cnvs==1,eid]]))
quant.table <- data.table(table(ukbb.annotated.cnvs.qcd[filter.0.95.wes.support.score==T,ct]))
paste0("Number of CNVs (Unfiltered Indiv)  : ",quant.table[,sum(N)], " (DEL: ", quant.table[V1 == "DEL",N], "; DUP: ", quant.table[V1 == "DUP",N],")")
quant.table <- data.table(table(ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score==T,ct]))
paste0("Number of CNVs (Filtered Indiv)    : ",quant.table[,sum(N)], " (DEL: ", quant.table[V1 == "DEL",N], "; DUP: ", quant.table[V1 == "DUP",N],")")
paste0("Number of CNV Loci                 : ",nrow(data.table(table(ukbb.annotated.cnvs.qcd[,locus]))))
paste0("")
rm(quant.table)

## Total SNVs:
paste0("Number of SNV/INDel Variants: ", nrow(variants.UKBB[,]))
paste0("")

## UKBB Unmapped Regions:
paste0("Number of genes affected by UKBB Issue : XXX")
paste0("Go to the UKBB Unmapped Regions section for these numbers!!!")
paste0("")

## Total sHET Genes:
paste0("Total number of genes with sHET value                       : ", nrow(shet.genes))
paste0("Total number of genes with sHET value in both hg19 and hg38 : ", nrow(merge(shet.genes,gene.translate)))
paste0("")

## Total Disease Genes:
print(paste0("Number of male infertility genes: ", nrow(male.infertility.genes)))
paste0("")

## Total Indiv Lost with >3 filter:
paste0("Number of DEL Individuals Lost, pLI ≥ 0.9  : ", results.fertility[variant.type == "DEL" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "DEL" & maf == 0 & gene.list == "highPLI",sum(n.indvs)])
paste0("Number of DEL Individuals Lost, sHET ≥ 0.9 : ", results.fertility[variant.type == "DEL" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "DEL" & maf == 0 & gene.list == "highsHET",sum(n.indvs)])

paste0("Number of PTV Individuals Lost, pLI ≥ 0.9  : ", results.fertility[variant.type == "LOF_HC" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "LOF_HC" & maf == 0 & gene.list == "highPLI",sum(n.indvs)])
paste0("Number of PTV Individuals Lost, sHET ≥ 0.9 : ", results.fertility[variant.type == "LOF_HC" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "LOF_HC" & maf == 0 & gene.list == "highsHET",sum(n.indvs)])
paste0("")

## Base Fertility Stats:
paste0("Base Childlessness Male             : ", sprintf("%0.1f",base.childlessness.male*100))
paste0("Base Childlessness Female           : ", sprintf("%0.1f",base.childlessness.female*100))

paste0("Base Children Among Males w/Child   : ", sprintf("%0.2f",base.fertilities[sex == 1 & inc.zero == F,fertility]))
paste0("Base Children Among Females w/Child : ", sprintf("%0.2f",base.fertilities[sex == 2 & inc.zero == F,fertility]))

paste0("Base Children Among Males          : ", sprintf("%0.2f",base.fertilities[sex == 1 & inc.zero == T,fertility]))
paste0("Base Children Among Females        : ", sprintf("%0.2f",base.fertilities[sex == 2 & inc.zero == T,fertility]))
paste0("")

## Change in cognition:
paste0("Predicted drop in IQ for sHET = 1 male: " ,sprintf("%0.2f", model.cog[shet == 1 & sex == 1,100 - expected.iq_mid]))
paste0("")

## Median high pLI Gene:
paste0("high pLI genes (≥ 0.9) have a mean sHET value of : ",sprintf("%0.3f",mean.highpLI))
paste0("")
```

# Testing Ground

```{r}

male.infert <- first.incidence.data[code == "N46", eid]
test.table <- merge(UKBB.phenotype.data[sexPulse == 1 & has.first.incidence.data == T], variant.counts[allele.freq == 0 & type == "DEL", c("sample_id","product_sHET")], by.x = "eid", by.y = "sample_id")

test.table[,has.infertility:=if_else(eid %in% male.infert, 1, 0)]
test.table[,has.children:=if_else(children.fathered>0,1,0)]

summary(glm(has.infertility ~ product_sHET + agePulse + agePulse.squared + PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10 + PC11 + PC12 + PC13 + PC14 + PC15 + PC16 + PC17 + PC18 + PC19 + PC20 + PC21 + PC22 + PC23 + PC24 + PC25 + PC26 + PC27 + PC28 + PC29 + PC30, family = "binomial", data = test.table))

```




