---
title: "PhenotypeTesting"
author: "Eugene Gardner"
date: "22/04/2020"
output: html_document
  html_document:
    toc: true
---

# 1. Startup and Introduction

This document contains data UKBB and comparisons between and within this data to the trait of interest, Fertility. If using data produced by this repo, please cite [our manuscript](https:tbd).

*BIG Note:* The first part of this document involves running scripts to generate text files required for downstream analysis. _PLEASE_ start there and make sure all scripts ran successfully. All scripts for this section are available in the folder `./scripts/`. These scripts _will not_ run as part of this document. There is an additional resource that you need to download -- the OMIM morbid map -- which requires registration. See the section [on OMIM](#disease_genes) below.

This script is agnostic to the UKBiobank application number. You should be able to download a bulk phenotype file and, if it contains the correct phenotypes as referred to in the manuscript and in the file `rawdata/phenofiles/fields_to_extract.txt`, you should be able to reproduce our data and figures. 

## 1A. Libraries

```{r setup}

knitr::opts_chunk$set(
	echo = TRUE,
)

library(biomaRt) ## Get gene lists we need
library(readxl) ## Read Supplemental Excel tables
library(data.table) ## Better than data.frame
library(patchwork) ## Arranging ggplots
library(broom) ## Makes getting covars out of lm much tidier
library(meta) ## For doing meta analysis
library(mratios) ## Need this to calculate 95% CIs for ratios of two means
library(svglite) ## Need to create figure 3 properly (ggsave doesn't like anything with an alpha)
library(tidyverse) ## Takes care of ggplot, tidyr, dplyr, and stringr
```

## 1B. Themes

Set themes for internal figures just for testing purposes:

```{r Base Themes}
theme <- theme(panel.background=element_rect(fill="white"),line=element_line(size=1,colour="black",lineend="round"),axis.line=element_line(size=1),text=element_text(size=16,face="bold",colour="black"),axis.text=element_text(colour="black"),axis.ticks=element_line(size=1,colour="black"),axis.ticks.length=unit(.1,"cm"),strip.background=element_rect(fill="white"),axis.text.x=element_text(angle=45,hjust=1),legend.position="blank",panel.grid.major=element_line(colour="grey",size=0.5))

## Default theme w/legend
theme.legend <- theme + theme(legend.position="right")

del.line <- "#4F7942"
del.fill <- "#77DD77"
dup.line <- "#0000FF"
dup.fill <- "#AEC6CF"
```

Theme for main text/supplemental figures (making font size smaller):

```{r Figure Themes}
theme.figures <- theme(panel.background=element_rect(fill="white"),line=element_line(size=1,colour="black",lineend="round"),axis.line=element_line(size=1),text=element_text(size=10,face="bold",colour="black"),axis.text=element_text(colour="black"),axis.ticks=element_line(size=1,colour="black"),axis.ticks.length=unit(.1,"cm"),strip.background=element_rect(fill="white"),axis.text.x=element_text(angle=45,hjust=1),legend.position="blank",panel.grid.major=element_line(colour="grey",size=0.5))

## Default theme w/legend
theme.figures.legend <- theme.figures + theme(legend.position="right")

## Colour Scheme:
male <- "#38BCA0"
female <- "#7B06F8"

sex.colours <- c(male, female)
names(sex.colours) <- c("Male","Female")
sex.colours.fill <- scale_fill_manual(name = "Sex",values=sex.colours,guide=guide_legend(reverse=F))
sex.colours.colour <- scale_colour_manual(name = "Sex",values=sex.colours, guide=guide_legend(reverse=F))
sex.colours.fill.rev <- scale_fill_manual(name = "Sex",values=sex.colours,guide=guide_legend(reverse=T))
sex.colours.colour.rev <- scale_colour_manual(name = "Sex",values=sex.colours, guide=guide_legend(reverse=T))

alt.colours <- c("#75485E","#CB904D","#DFCC74")
```

## 1C. Prepping Storage Directories

This just unpacks the tarball of provided data resources at `rawdata.tar.gz`

```{bash Prepare Storage}

tar -zxf rawdata.tar.gz

```

# 2. Generating Required Text Files

Example code for downloading and initial processing UKBB phenotype file. None of the code in this section will actually be run.

## 2A. Creating Master Phenotype File:

This code chunk is not evaluated here but is provided for replication purposes. This code chunk assumes that the user has already gained access to, and [downloaded](http://biobank.ndph.ox.ac.uk/showcase/), relevant phenotype fields and has aquired the encoded phenotype file (like ukb00000.enc). The tools used below are also available via the [UKBiobank datashowcase website](http://biobank.ndph.ox.ac.uk/showcase/download.cgi). More information on downloading can be found [here](https://biobank.ctsu.ox.ac.uk/~bbdatan/Accessing_UKB_data_v2.1.pdf).

```{bash get UKBB phenotype file, eval = F}

## First step involves downloading and decoding individual phenotype data. Keyvalue is the key provided via email when you apply for bulk download. This will create a decoded file ukb00000.enc_ukb
ukbunpack ukb00000.enc <keyvalue>

## Next, convert the file to a tab-delimited format:
ukbconv ukb00000.enc_ukb txt

## Create a data dictionary (so we know where phenotypes are in the file!)
ukbconv ukb00000.enc_ukb docs

## This should result in 2 required files for further processing:
# ukb00000.txt
# ukb00000.html
```

This code chunk extracts phenotypes of relevance from the master phenotype file that is downloaded and processed above. It is run with the script: `./scripts/extract_phenotypes.pl`.

This script is slower than it should be due to an issue with text format encoding of the UKBB-created TSV file on MacOS. If running this code on a UNIX system, would suggest switching the 'exec' call at the bottom of this script to use cut for additional speed. It should mean the script executes in ~30s rather than 5mins.

```{bash extract phenotypes, eval = F}

./scripts/extract_phenotypes.pl

```

## 2B. Setting Unrelated Individuals:

Again, this is just an example on how relatedness information is accquired from UKBB, code does not actually run. It proceeds in two basic steps:

1. Download the relatedness file using the (ukbgene)[http://biobank.ndph.ox.ac.uk/showcase/refer.cgi?id=664] tool
2. Running the provided script to generate a list of individuals to filter - at: `./scripts/get_relateds.R`.

```{bash process relatedness, eval = F}

## 1. Run ukbgene rel. This will download a file like: ukbXXXXX_rel_sYYYYYY.dat, where X represents your application ID, and 488288 represents the file version
ukbgene rel

## 2. Get related individuals to filter (change the name of the .dat to your specific file):
./scripts/get_relateds.R ukbXXXXX_rel_sYYYYYY.dat > raw_data/phenofiles/relateds.out
## Format the output file to be readable by R
perl -ne 'if ($_ =~ /\"(\d{7})\"/) {print "$1\n";}' raw_data/phenofiles/relateds.out > raw_data/phenofiles/relateds.txt

```

# 3. Phenotype Data

Read in the master phenotype and related individuals file that was created in [the previous section](#2._generating_required_text_files)

```{r load master phenotype file}

UKBB.raw.phenotypes <- fread("rawdata/phenofiles/ukbb_phenotypes.txt")
UKBB.raw.phenotypes[,eid:=as.character(eid)]

```

```{r load relatedness file}

related.individuals <- fread("rawdata/phenofiles/relateds.txt", header = F)
setnames(related.individuals,"V1","eid")
related.individuals[,eid:=as.character(eid)]

```

## 3A. Generic Phenotypes

Grabbing generic phenotypes age, sex, ancestry, European ancestry status and adding them to the main UKBB.phenotype.data table.

This also filters out individuals that are not broadly European.

```{r process generic phenotypes}

## Data table of all UKBB population data:
PCAs<-c(1:10)
for (i in PCAs) {
  PCAs[i] <- paste("22009-0",i,sep=".")
}
fields <- c("eid","22006-0.0","31-0.0","21022-0.0",PCAs)
UKBB.phenotype.data <- UKBB.raw.phenotypes[,..fields]

setnames(UKBB.phenotype.data,c(fields),c("eid","white.british.ancestry","sexPulse","agePulse","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10"))

## Remove all non-white British (determined direct by UKBB and taken from the pheno file)
UKBB.phenotype.data <- UKBB.phenotype.data[!is.na(white.british.ancestry)]
paste0("Number of Broadly Euro Indiv: ", table(UKBB.raw.phenotypes[,`22006-0.0`]))

## Remove all related individuals:
UKBB.phenotype.data <- UKBB.phenotype.data[!eid %in% related.individuals[,eid]]

## Change sex to be 1 = male, 2 = female instead of 0,1. 
## This is a distinction made for an old project to keep it consistent.
UKBB.phenotype.data[,sexPulse:=ifelse(sexPulse == 0, 2, 1)]

## Add agePulse.squared covar:
UKBB.phenotype.data[,agePulse.squared:=agePulse^2]
paste0("Number of Individuals after filtering: ",nrow(UKBB.phenotype.data))

rm(PCAs,fields,i)
```


## 3B. Fertility

```{r Load Data, fig.height=5, fig.width=4}

fertility.metrics <- UKBB.raw.phenotypes[,c("eid",
                                            "2405-0.0", ## Children Fathered
                                            "2734-0.0", ## Live Births
                                            "6141-0.0", ## Individuals in household
                                            "709-0.0", ## Number of individuals in household
                                            "2129-0.0", ## Answered Sex Questions
                                            "2159-0.0" ## Same sex behaviour
                                            )]

## Replace all NAs with a double value to make filtering easier
fertility.metrics[is.na(fertility.metrics)] <- -9

setnames(fertility.metrics,names(fertility.metrics),c("eid",
                                                      "children.fathered",
                                                      "live.births",
                                                      "in.household",
                                                      "number.in.household",
                                                      "answered.sex",
                                                      "same.sex"))
                                                     
# Number of live births:
fertility.metrics[,live.births:=if_else(live.births > 7, -9, live.births)]
fertility.metrics[,live.births:=if_else(live.births < 0, -9, live.births)]
                    
ggplot(fertility.metrics[live.births>=0],aes(live.births,..density..)) +
  geom_histogram(binwidth = 1,colour="black",fill=female) +
  xlab("Live Births") +
  scale_y_continuous(name = "Proportion of Females", limits=c(0,0.5), labels = paste0(c(0,10,20,30,40,50),"%")) +
  theme

# Children fathered
fertility.metrics[,children.fathered:=if_else(children.fathered > 7, -9, children.fathered)]
fertility.metrics[,children.fathered:=if_else(children.fathered < 0, -9, children.fathered)]

ggplot(fertility.metrics[children.fathered>=0],aes(children.fathered,..density..)) +
  geom_histogram(binwidth = 1,colour="black",fill=male) +
  xlab("Children Fathered") +
  scale_y_continuous(name = "Proportion of Males", limits=c(0,0.5), labels = paste0(c(0,10,20,30,40,50),"%")) +
  theme

## Who is in the household is stored in an array of up to 5 values (so can stored UP to 5 possible relationships)
## Is a follow-up question to "how many individuals are in your household?" and will be NA if they did not answer
## To make this simple, just taking the first response, the followup data is so small, isn't going to matter and it's taking me way too long to come up with all possible combinations
fertility.metrics[,partner.in.house:=if_else(number.in.household < 0,-9, ## Did not answer, did not know, did not want to answer
                                               if_else(number.in.household==1,0, ## individuals living by themselves
                                                       if_else(number.in.household > 1 & in.household == 1,1,0)))] ## Check if partner present

ggplot(merge(UKBB.phenotype.data,fertility.metrics,by="eid"),aes(as.factor(partner.in.house),group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  stat_count(position="identity",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_discrete(name="Has Partner In Home?",labels=c("Did Not Answ.","False","True")) +
  theme.legend

## Same sex sexual behaviour
fertility.metrics[,same.sex:=if_else(answered.sex == 1,
                                     if_else(same.sex == 0,0,
                                             if_else(same.sex == 1,1,-9)),
                                     -9)]

ggplot(merge(UKBB.phenotype.data,fertility.metrics,by="eid"),aes(as.factor(same.sex),group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  stat_count(position="identity",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_discrete(name="Engaged in Same Sex Behaviour?",labels=c("True","False","Did Not Answ.")) +
  theme.legend

## Now convert all the -9s back to NA
fertility.metrics <- fertility.metrics[,c("eid","children.fathered","live.births","partner.in.house","same.sex")]
fertility.metrics[,children.fathered:=if_else(children.fathered==-9,as.numeric(NA),children.fathered)]
fertility.metrics[,live.births:=if_else(live.births==-9,as.numeric(NA),live.births)]
fertility.metrics[,partner.in.house:=if_else(partner.in.house==-9,as.numeric(NA),partner.in.house)]
fertility.metrics[,same.sex:=if_else(same.sex==-9,as.numeric(NA),same.sex)]

UKBB.phenotype.data <- merge(UKBB.phenotype.data,fertility.metrics,by="eid")
rm(fertility.metrics)
```


## 3C. Fluid Intelligence

This section looks at UKBB "Fluid Intelligence". 

The field of relevance for us is 20016-0.0. There is no array data (only 1 test was done, but 3 instances - we're using instance 0).

```{r process fluid intelligence}

## Grab fluid intel from the raw phenotypes:
fluid.intel.table <- UKBB.raw.phenotypes[,c("eid","20016-0.0")]
fluid.intel.table[,fluid.intel:=if_else(is.na(`20016-0.0`),as.integer(NA),`20016-0.0`)]
ggplot(merge(UKBB.phenotype.data,fluid.intel.table,by="eid"),aes(fluid.intel,group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  geom_histogram(binwidth = 1, position="identity", alpha = 0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_continuous(name="Fluid Intel Score") +
  scale_y_continuous(name = "# of Individuals") +
  theme.legend

## Normalize fluid intelligence
fluid.intel.table[,fluid.intel:=(fluid.intel-mean(fluid.intel,na.rm=T))/sd(fluid.intel,na.rm=T)]
ggplot(merge(UKBB.phenotype.data,fluid.intel.table,by="eid"),aes(fluid.intel,group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  geom_histogram(binwidth = 1, position="identity", alpha = 0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_continuous(name="Normalized Fluid Intel Score") +
  scale_y_continuous(name = "# of Individuals") +
  theme.legend

## Merge with remaining phenotypes
UKBB.phenotype.data <- merge(UKBB.phenotype.data,fluid.intel.table[,c("eid","fluid.intel")],by="eid",all.x=T)

rm(fluid.intel.table)
```

## 3D. Educational Attainment

Analyzing fields for Educational Attainment.

6138-0/1/2 includes educational attainment measures. Looks like there are a max of 5 values for each instance (to accomodate multiple levels of qualifications). At this point I think we just try a binary for did/did not complete a college degree, which is high correlated accoring to [this](https://academic.oup.com/sf/article-abstract/92/1/109/2235872?redirectedFrom=fulltext) article (cannot actually read it as is behind a paywall, but was cited in [this](https://static-content.springer.com/esm/art%3A10.1038%2Fnature17671/MediaObjects/41586_2016_BFnature17671_MOESM48_ESM.pdf) study as an explanation for why they don't care about years schooling vs. college education.

```{r Educational Attainment, fig.height=3, fig.width=6}

educational.attainment <- UKBB.raw.phenotypes[,c("eid","6138-0.0")]

## only have to check the first array column as that is the only one that is ever == 1 (i.e. college education)
educational.attainment[,test.1:=if_else(is.na(`6138-0.0`),as.integer(NA),
                                        if_else(`6138-0.0` == -3,as.integer(NA),
                                                if_else(`6138-0.0` == 1,1L,0L)))]

## This is for just testing in center data
educational.attainment[,completed.college:=test.1]
educational.attainment <- educational.attainment[,c("eid","completed.college")]

ggplot(merge(UKBB.phenotype.data,educational.attainment,by="eid"),aes(as.factor(completed.college),group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  stat_count(position="identity",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_discrete(name="Completed College?",labels=c("False","True","NA")) +
  theme.legend

## Merge with remaining phenotypes
UKBB.phenotype.data <- merge(UKBB.phenotype.data,educational.attainment,by="eid",all.x=T)
rm(educational.attainment)
```

## 3E. Household Income

```{r income data}

income.data <- UKBB.raw.phenotypes[,c("eid","738-0.0")]

income.data[,household.income:=if_else(`738-0.0`>0,`738-0.0`,as.integer(NA))]

income.data <- income.data[,c("eid","household.income")]

ggplot(merge(UKBB.phenotype.data,income.data,by="eid"),aes(household.income,group=as.factor(sexPulse),fill=as.factor(sexPulse))) + 
  geom_histogram(binwidth=1,position=position_dodge(),colour="black") + 
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_continuous(name="Income Bracket") +
  ylab("# of Individuals") +
  theme.legend

## Merge with remaining phenotypes
UKBB.phenotype.data <- merge(UKBB.phenotype.data,income.data,by="eid",all.x=T)
rm(income.data)
```

## 3F. Email

```{r email data}

email.data <- UKBB.raw.phenotypes[,c("eid","20005-0.0")]

## As far as I can tell this is a purely binary value:
email.data[,has.email:=if_else(!is.na(`20005-0.0`),1,0)]

email.data <- email.data[,c("eid","has.email")]

ggplot(merge(UKBB.phenotype.data,email.data,by="eid"),aes(as.factor(has.email),group=as.factor(sexPulse),fill=as.factor(sexPulse))) +
  stat_count(position="identity",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_fill_manual(values=c(male,female),guide=guide_legend(title="Sex"),labels=c("Male","Female")) +
  scale_x_discrete(name="Has Email?",labels=c("False","True")) +
  theme.legend

## Merge with remaining phenotypes
UKBB.phenotype.data <- merge(UKBB.phenotype.data,email.data,by="eid",all.x=T)
rm(email.data)
```

## 3G. Mental Health Phenotypes

### ICD 10 Coding

The ICD-10 codes that I have used and their equivalancies to the MHQ section are listed in the perl script below. For the traits covered in [Power et al.](https://jamanetwork.com/journals/jamapsychiatry/article-abstract/1390257) I have stuck with their exact codes to enable replication, for the others I have googled a bit and tried to do my best as a non-clinician. Most seem reasonably straightforward...

This set of data needs to be processed in two steps, as I use perl to process the actual phenotypes (it's much easier than in R). Need to first print out a text file of the raw phenotypes I need, process it with Perl, and then read back in and add to the final phenotype table.

```{r print ICD10 Data}

cols.to.print <- c("eid",names(UKBB.raw.phenotypes)[grep("41202",names(UKBB.raw.phenotypes))],names(UKBB.raw.phenotypes)[grep("41204",names(UKBB.raw.phenotypes))])
icd.data <- UKBB.raw.phenotypes[,..cols.to.print]
write.table(icd.data,file="rawdata/phenofiles/ICD10.data.txt",sep="\t",row.names=F,col.names=F,quote=F)

```

```{bash Process ICD10 Data}

./scripts/process_icd.pl

```

```{r process ICD10}

icd.data <- fread("rawdata/phenofiles/ICD10.data.processed.txt")
icd.data[,eid:=as.character(eid)]

setnames(icd.data, names(icd.data), c("eid",paste("icd",names(icd.data)[2:length(names(icd.data))],sep=".")))

UKBB.phenotype.data <- merge(UKBB.phenotype.data,icd.data,by="eid",all.x=T)
```

### Mental Health Questionnaire

This [recent paper](https://doi.org/10.1192/bjo.2019.100) documents the mental health questionaire that was sent out to a subset of UKBB particpants. ~160k responded on a number of measures. On the UKBB Data Showcase, they have a [document](http://biobank.ndph.ox.ac.uk/showcase/showcase/docs/mental_health_online.pdf) about what questions were asked and where to find them in the showcase.

This section is attempting to replicate the general codings of [this](https://jamanetwork.com/journals/jamapsychiatry/article-abstract/1390257) study that looked at all Swedish individuals born from 1950-1970 that did not have any genetic data. As such, the equivalent UK Biobank fields and their codings withing the MH Questionnaire are:

* 20406 (alcohol), 20503 (prescription meds), 20456(rec. drugs) - Substance Addiction. Field 20401 indicates a 'YES' answer to ever addicted to a substance or behaviour, which is a 'gate' question to answer these three fields.
* 20544: Numbers that follow are the code for that disorder 
** Social Anxiety/Phobia (1)
** Psychotic disorders (2 & 3) - This is also encoded in ICD10 code(s) F20-29. Could get a bigger N by using ICD10 codes?
** Personality disorders (4)
** Any other diabling phobia(5)
** Panic Attacks (6)
** OCD (7)
** Bipolar disorder, manic depressive diso., etc. (10)
** Depression (11)
** Eating disorders (12,13,16)
** ASD (14)
** General Anxiety Disorder(15)
** Agorophobia (17)
** ADD/ADHD (18)
** Did not answer one or both sections (-818, -819)

Processing of MH Traits functions similarly to ICD10 above, where I have to print a file, processes with perl and then read it back in:

```{r print MHQ data}

cols.to.print <- c("eid","20401-0.0","20406-0.0","20456-0.0","20503-0.0",names(UKBB.raw.phenotypes)[grep("20544",names(UKBB.raw.phenotypes))])
mhq.data <- UKBB.raw.phenotypes[,..cols.to.print]
write.table(mhq.data,file="rawdata/phenofiles/mhq.data.txt",sep="\t",row.names=F,col.names=F,quote=F)

```

```{bash Process MH data}

./scripts/process_mhq.pl

```

```{r process MHQ}

mhq.data <- fread("rawdata/phenofiles/mhq.data.processed.txt")
mhq.data[,eid:=as.character(eid)]

setnames(mhq.data, names(mhq.data), c("eid",paste("mhq",names(mhq.data)[2:length(names(mhq.data))],sep=".")))

## Convert answered MHQ to binary:
mhq.data[,mhq.answered_mhq:=if_else(is.na(mhq.answered_mhq),0,1)]

UKBB.phenotype.data <- merge(UKBB.phenotype.data,mhq.data,by="eid",all.x=T)
```

### Comparing MH Data Sources:

```{r compare MHQ and ICD10}

## Totals MHQ:
totals.mhq <- mhq.data[,lapply(.SD, sum,na.rm=T),.SDcols=names(mhq.data)[2:length(names(mhq.data))]]
totals.mhq <- data.table(pivot_longer(totals.mhq,cols=names(totals.mhq),names_sep="\\.",names_to = c(".value","condition")))

## Totals:
totals.icd10 <- icd.data[,lapply(.SD, sum,na.rm=T),.SDcols=names(icd.data)[2:length(names(icd.data))]]
totals.icd10 <- data.table(pivot_longer(totals.icd10,cols=names(totals.icd10),names_sep="\\.",names_to = c(".value","condition")))

n.mhq <- totals.mhq[condition=="answered_mhq",mhq]
n.icd10 <- nrow(icd.data)

totals.mhq[,prop:=(mhq/n.mhq)*100]
totals.icd10[,prop:=(icd/n.icd10)*100]

setnames(totals.mhq,c("mhq","prop"),c("value.mhq","prop.mhq"))
setnames(totals.icd10,c("icd","prop"),c("value.icd10","prop.icd10"))

totals <- merge(totals.mhq,totals.icd10,by="condition")

ggplot(totals,aes(prop.mhq,prop.icd10)) + geom_point() + scale_x_log10(name = "MHQ Proportion",limits=c(1e-2,1e1)) + scale_y_log10(name="ICD-10 Proportion",limits=c(1e-2,1e1)) + geom_text(aes(label=condition)) + geom_abline(linetype = 2, colour = "red") + theme

rm(totals.mhq,totals.icd10,n.mhq,n.icd10,totals,mhq.data,icd.data)
```

# 4. Assembling Sequencing/Array Data

## 4A. Curating Gene Lists

We use several genelists as part of this project:

1. pLI information from the [gnomAD project](https://storage.googleapis.com/gnomad-public/release/2.1.1/constraint/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz).
2. s~het~ from [Weghorn et al.](https://doi.org/10.1093/molbev/msz092). The reference file is included in this repository (`raw_data/genelist/shet.weghorn.txt`).
3. HGNC to convert from varied non-ENSG IDs to ENSEMBL Gene IDs for consistancy.
4. ENSEMBL-downloaded resources from [BioMart](https://www.ensembl.org/biomart/martview/0511514c231557b5d24ace4e8f7862e0).
5. Male Infertility Genes from [this paper](https://academic.oup.com/humrep/article/34/5/932/5377831).

The purpose of the following scripts is to generate these lists if they are not available. This process is also duplicated when processing CNV data, as that has to be done as part of a separate script. See both the section on [loading CNVs](#_) in this document, and the separate RMarkdown document `CNVCalling_Filtering.R` for more information.

*Note*: These scripts assume you have `curl` installed on your system, which _should_ be true if you are using macos. Please change the scripts below if this is not the case.

### Download Resources from BioMart

```{r Generate biomart resources}

## Hg19
ensembl <- useMart("ensembl", host="http://grch37.ensembl.org", dataset = "hsapiens_gene_ensembl")
hg19.table <- data.table(getBM(attributes = c('ensembl_gene_id','chromosome_name','start_position','end_position','hgnc_id','hgnc_symbol','ensembl_transcript_id'),mart = ensembl))
hg19.table <- hg19.table[!grep("_",chromosome_name)]
write.table(hg19.table,"rawdata/genelists/hg19.genes.txt",col.names=F,row.names=F,quote=F,sep="\t")

## Hg38
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
hg38.table <- data.table(getBM(attributes = c('ensembl_gene_id','chromosome_name','start_position','end_position','hgnc_id','hgnc_symbol','strand'),mart = ensembl))
hg38.table[,hgnc_id:=str_remove(hgnc_id,"HGNC:"),by=1:nrow(hg38.table)]
hg38.table <- hg38.table[!grep("CHR_",chromosome_name)]
write.table(hg38.table,"rawdata/genelists/hg38.genes.txt",col.names=F,row.names=F,quote=F,sep="\t")

rm(hg19.table,hg38.table,ensembl)
```

### s~het~ Gene Lists

```{bash Generate sHET gene lists}

perl -ane 'chomp $_; @F = split("\t", $_); print "$F[0]\t$F[7]\n";' rawdata/genelists/shet.weghorn.txt > rawdata/genelists/shet.processed.weghorn.txt

## sHET gene lists (have to attach ENSG):
scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -col1 5 -file2 rawdata/genelists/shet.processed.weghorn.txt -r | perl -ane 'chomp $_; print "$F[2]\t$F[0]\t$F[1]\t$F[6]\n";' > rawdata/genelists/shet.hgnc.txt
```

### Hg19 Gene Lists

```{bash Generate hg19 Gene Lists}

## Download gnomAD scores:
curl -o rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz https://storage.googleapis.com/gnomad-public/release/2.1.1/constraint/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz

## Rename your files gnomAD........
mv rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt.bgz rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt.gz
gunzip -f rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt.gz

## Create a reference file of just ENSG and pLI, while removing genes w/o a pLI score:
perl -ane 'chomp $_; @F = split("\t", $_); if ($F[20] ne 'NA') {print "$F[63]\t$F[20]\n";}' rawdata/genelists/gnomad.v2.1.1.lof_metrics.by_gene.txt > rawdata/genelists/hg19.all_genes_with_pli.txt

## Add additional info from biomart that we acquired:
# pLI file:
scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -file2 rawdata/genelists/hg19.all_genes_with_pli.txt -r | perl -ne 'chomp $_;  @F = split("\t", $_); print "$F[0]\t$F[3]\t$F[4]\t$F[5]\t$F[6]\t$F[7]\t$F[8]\t$F[1]\n";' > rawdata/genelists/hg19.all_genes_with_pli.2.txt
mv rawdata/genelists/hg19.all_genes_with_pli.2.txt rawdata/genelists/hg19.all_genes_with_pli.txt

# sHET file:
scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -file2 rawdata/genelists/shet.hgnc.txt -r | perl -ne 'chomp $_;  @F = split("\t", $_); print "$F[0]\t$F[5]\t$F[6]\t$F[7]\t$F[8]\t$F[9]\t$F[10]\t$F[2]\n";' > rawdata/genelists/hg19.all_genes_with_shet.txt

# Make a list of all genes and their coordinates for WES annotation:
perl -ane 'splice(@F, -2); print join("\t", @F) . "\n";' rawdata/genelists/hg19.all_genes_with_shet.txt > rawdata/genelists/hg19.coordinates.txt
perl -ane 'splice(@F, -2); print join("\t", @F) . "\n";' rawdata/genelists/hg19.all_genes_with_pli.txt >> rawdata/genelists/hg19.coordinates.txt
sort rawdata/genelists/hg19.coordinates.txt | uniq > rawdata/genelists/hg19.coordinates.2.txt
mv rawdata/genelists/hg19.coordinates.2.txt rawdata/genelists/hg19.coordinates.txt
```

### Hg38 Gene Lists

```{bash Generate hg38 Gene lists}
# Try and match genes to Hg19 based on HGNC ID
# Generate a list of hg19 genes with HGNC IDs:
perl -ane 'chomp $_; if ($F[4] ne "NA" && $F[4] ne "") {print "$F[4]\t$F[0]\t$F[5]\n";}' rawdata/genelists/hg19.genes.txt | sort | uniq > rawdata/genelists/hg19.trans.txt

scripts/matcher.pl -file1 rawdata/genelists/hg19.trans.txt -file2 rawdata/genelists/hg38.genes.txt -col2 4 -r | perl -ane 'chomp $_; print "$F[0]\t$F[1]\t$F[2]\t$F[3]\t$F[4]\t$F[5]\t$F[8]\n";' > rawdata/genelists/hg38.hgnc.matched.txt

# Ask which genes have a pLI score:
scripts/matcher.pl -file1 rawdata/genelists/hg38.hgnc.matched.txt -col1 6 -file2 rawdata/genelists/hg19.all_genes_with_pli.txt -r | perl -ane 'chomp $_; @F = split("\t", $_); print "$F[8]\t$F[9]\t$F[10]\t$F[11]\t$F[12]\t$F[13]\t$F[0]\t$F[7]\n";' > rawdata/genelists/hg38.all_genes_with_pli.txt

# Ask which genes have a sHET score:
scripts/matcher.pl -file1 rawdata/genelists/hg38.hgnc.matched.txt -col1 6 -file2 rawdata/genelists/hg19.all_genes_with_shet.txt -r | perl -ane 'chomp $_; @F = split("\t", $_); print "$F[8]\t$F[9]\t$F[10]\t$F[11]\t$F[12]\t$F[13]\t$F[0]\t$F[7]\n";' > rawdata/genelists/hg38.all_genes_with_shet.txt

# There is a fairly large caveat here, which is that I label the genes with their Hg19 ENSG ID so that I can be consistant in my R code below!!! This does't impact too many genes, they mostly have the same IDs (~2-300)
# This gets a translatable list to hg19 ENSG###:
perl -ne 'chomp $_; @F = split("\t", $_); print "$F[0]\t$F[6]\n";' rawdata/genelists/hg38.all_genes_with_pli.txt > rawdata/genelists/hg38_to_hg19_ENSG.txt
perl -ne 'chomp $_; @F = split("\t", $_); print "$F[0]\t$F[6]\n";' rawdata/genelists/hg38.all_genes_with_shet.txt >> rawdata/genelists/hg38_to_hg19_ENSG.txt
sort rawdata/genelists/hg38_to_hg19_ENSG.txt | uniq > rawdata/genelists/hg38_to_hg19_ENSG.2.txt
mv rawdata/genelists/hg38_to_hg19_ENSG.2.txt rawdata/genelists/hg38_to_hg19_ENSG.txt 

# Make a list of all genes and their coordinates for WES annotation:
perl -ane 'splice(@F, -2); print join("\t", @F) . "\n";' rawdata/genelists/hg38.all_genes_with_shet.txt > rawdata/genelists/hg38.coordinates.txt
perl -ane 'splice(@F, -2); print join("\t", @F) . "\n";' rawdata/genelists/hg38.all_genes_with_pli.txt >> rawdata/genelists/hg38.coordinates.txt
sort rawdata/genelists/hg38.coordinates.txt | uniq > rawdata/genelists/hg38.coordinates.2.txt
mv rawdata/genelists/hg38.coordinates.2.txt rawdata/genelists/hg38.coordinates.txt
```

### Disease Genes

This section of the document is not evaluated, as we need to acquire disease gene resources from three locations. The actual acquisition of these files is trivial, but did not want to attempted to make reproduceable due to potential links breaking. If this section needs to be reproduced, download the resources at the _rough_ following locations and run the code in this section. Otherwise, move to the next section where the file produced by this section has already been generated. Locations to place necessary files and file dates used in the manuscript are listed below:

1. Clinvar - https://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh37/archive_2.0/2019/clinvar_20191003.vcf.gz
** `rawdata/genelists/clinvar.vcf.gz`
** date: October 3, 2019
2. DDG2P - http://www.ebi.ac.uk/gene2phenotype/downloads/DDG2P.csv.gz
** `rawdata/genelists/DDG2P.csv`
** date: November 12, 2019
3. OMIM - https://www.omim.org/downloads
** `rawdata/genelists/morbidmap.txt`
** date: October 8, 2019

*Note*: To download OMIM morbid map you will need to register and place a copy of this file at: `rawdata/genelists/morbidmap.txt`

```{r process disease genes, eval = F}
## Clinvar
clinvarVCFfiltered <- read_tsv("rawdata/genelists/clinvar.vcf.gz", comment = '#', col_names = F, col_types = 'cccccccccccccc') %>% 
  mutate(PHEN = str_remove(str_extract(X8, 'CLNDN=[^;]*;'), "CLNDN=")) %>% 
  mutate(PHEN = str_remove(PHEN, "not_provided")) %>% 
  mutate(PHEN = str_remove(PHEN, "|")) %>%
  mutate(PHEN = str_remove(PHEN, ";")) %>%
  filter(PHEN != '') %>% 
  mutate(GENE = str_remove(str_extract(X8, 'GENEINFO=[^;]*:'), "GENEINFO=")) %>% 
  #mutate(GENE = str_remove(GENE, ":")) %>% 
  mutate(CLNSIG = str_remove(str_extract(X8, 'CLNSIG=[^;]*;'), "CLNSIG=")) %>% 
  filter(CLNSIG %in% c("Pathogenic/Likely_pathogenic;", "Pathogenic;", "Likely_pathogenic;")) %>% 
  mutate(CLNSIG = str_remove(CLNSIG, ";")) %>% 
  mutate(ID = X3) %>% 
  select(c(X1,X2,ID, PHEN, GENE, CLNSIG)) %>% 
  drop_na(PHEN, GENE) 
clinvarGenes <- clinvarVCFfiltered %>% 
  select(GENE) %>% 
  distinct() %>% 
  transform(GENE = strsplit(GENE, "\\|")) %>%
  unnest(GENE) %>% 
  mutate(GENE = gsub(":.*", "", GENE))
clinvarGenes <- data.table(clinvarGenes)

## DDG2P
ddg2p <- fread("rawdata/genelists/DDG2P.csv") %>% 
  rename(hgnc_id = `hgnc id`)
develGenes <- ddg2p %>% 
  filter(`DDD category` %in% c("probable","confirmed","both DD and IF")) %>% 
  distinct(`hgnc_id`)
develGenes <- data.table(develGenes)

## OMIM
omimGenes <- read_tsv("rawdata/genelists/morbidmap.txt", skip = 4, comment = '#', col_types = 'ccic',
                      col_names = c("Pheno", "Gene", "MIM_Number", "Cyto_Location")) %>%
  select(Pheno, Gene) %>%
  drop_na() %>%
  mutate(Gene = gsub(",.*", "", Gene)) %>%
  mutate(omim_nondisease = ifelse(grepl("\\[", Pheno), T,F)) %>%
  mutate(omim_complex = ifelse(grepl("\\{", Pheno), T,F)) %>%
  mutate(omim_provisional = ifelse(grepl("\\?", Pheno), T,F))
omimGenes <- omimGenes %>% 
  filter(!omim_complex & !omim_nondisease)
omimGenes <- data.table(omimGenes)

hgnc.to.ENSG <- fread("rawdata/genelists/hg19.coordinates.txt",fill=T)
setnames(hgnc.to.ENSG,names(hgnc.to.ENSG),c("hg19.GENE","chr","start","end","hgnc_id","hgnc.symbol"))

clinvarGenes <- unique(merge(clinvarGenes,hgnc.to.ENSG,by.x="GENE",by.y="hgnc.symbol"))
develGenes <- unique(merge(develGenes,hgnc.to.ENSG,by="hgnc_id"))
omimGenes <- unique(merge(omimGenes[,c("Gene")],hgnc.to.ENSG,by.x="Gene",by.y="hgnc.symbol"))

diseaseGenes <- bind_rows(clinvarGenes[,c("hg19.GENE")],develGenes[,c("hg19.GENE")],omimGenes[,c("hg19.GENE")])
diseaseGenes <- unique(diseaseGenes)

write.table(diseaseGenes, "rawdata/genelists/diseaseGenes.txt",col.names = F, row.names = F, quote = F, sep ="\t")

rm(ddg2p, develGenes, omimGenes, clinvarVCFfiltered, clinvarGenes, hgnc.to.ENSG, diseaseGenes)
```

### Male Infertility Genes

This is a list of genes confirmed as playing a role in male infertility from [Manon Oud and Joris Veltman](https://academic.oup.com/humrep/article/34/5/932/5377831). We download and process the data direct from thier supplement (Table S3-S6):

*Note*: I have no idea if the link below will work for everyone. If it doesn't download the table manually from [here](https://academic.oup.com/humrep/article/34/5/932/5377831#supplementary-data) and set the name of the file to `rawdata/genelists/male_infertility_genes.xlsx`

```{bash Get Male Infertility Genes}

curl -L -o rawdata/genelists/male_infertility_genes.xlsx "https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/humrep/34/5/10.1093_humrep_dez022/2/dez022_supplementary_tables_siii_-_svi_final.xlsx?Expires=1591021841&Signature=Fs~qzUue5gM-9WRPnYlSzzQ1kQpryWdxzLqW1Yx74QHgzCVgGzeuNyf2ZhyqDRTUSmWoaPTHi-O~PXLJRsW~jsJKq8YVr-mGYlbJ9hb40YJIulotNzUiY1mIRYyS7MTvncojcWo9xwEfB~-KNeguJbfX7dv6f4RgDtHX1ne59zK9kueOK-jJRrzrW73Xb07JtMuGM3ChvbFAObx4-9cPg44U~JzEERrAoBZjkUuqt1tEQ2EM70Yy26FL-v34-P2nu3BtV3hulfWfk9dzdMP-hRupRkwfFJ3RaaWU5iboHwT9srQlRMEkJ0XHBp8MeeImXgFJAxzC3EPYhU4YgYpa7w__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA"

```

```{r Process Male Infertility Gene XLSX}

male.genes.xlsx <- data.table(read_xlsx("rawdata/genelists/male_infertility_genes.xlsx",sheet = "Supplementary Table SIV",skip=1))
male.genes.xlsx <- male.genes.xlsx[4:nrow(male.genes.xlsx)]
male.genes.xlsx <- male.genes.xlsx[,c("HGNC gene name","Inheritance pattern in human","Conclusion")]
male.genes.xlsx <- male.genes.xlsx[`HGNC gene name` != ""]
male.genes.xlsx <- male.genes.xlsx[Conclusion!="No evidence"]
male.genes.xlsx <- male.genes.xlsx[`Inheritance pattern in human`!= "XL" & `Inheritance pattern in human` != "YL"]

## Need to rename some genes as they used Hg38 gene IDs:
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="CATSPERE","C1orf101",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="CFAP43","WDR96",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="CFAP44","WDR52",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="CFAP69","C7orf63",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="DNAAF4","DYX1C1",`HGNC gene name`)]
male.genes.xlsx[,`HGNC gene name`:=if_else(`HGNC gene name`=="DNAAF5","HEATR2",`HGNC gene name`)]

write.table(male.genes.xlsx,"rawdata/genelists/male_infertility_genes.txt",row.names=F,col.names=F,sep="\t",quote=F)

rm(male.genes.xlsx)
```

```{bash Annotate Male Infertility Genes}

scripts/matcher.pl -file1 rawdata/genelists/hg19.genes.txt -file2 rawdata/genelists/male_infertility_genes.txt -col1 5 -r | perl -ne 'chomp $_; @F = split("\t", $_); splice(@F, 4, 9); print join("\t", @F) . "\n";' > rawdata/genelists/male_infertility_genes.annotated.txt

```

### Cleanup

Clean up intermediate files:

```{bash}

# Cleanup:
rm rawdata/genelists/unmatched.tsv
rm rawdata/genelists/unmatched.2.tsv
rm rawdata/genelists/hg38.genes.alt_removed.tsv
rm rawdata/genelists/ENSG.matched.tsv
rm rawdata/genelists/hgnc.matched.tsv
rm rawdata/genelists/shet.processed.weghorn.txt
rm rawdata/genelists/shet.hgnc_noENSG.txt
rm rawdata/genelists/hg19.genes.alt_removed.tsv
```

## 4B. Load Gene Lists For Phenotype Testing

### Generic Lists

This code block just loads our generic lists that we created above, namely:

1. Our hg19 -> hg38 conversion table
2. Table of all sHET values
3. Table of all pLI values

```{r Load Generic Lists}

## Load gene translation file
gene.translate <- fread("rawdata/genelists/hg38_to_hg19_ENSG.txt", header=F)
setnames(gene.translate,names(gene.translate),c("hg38.GENE","hg19.GENE"))

## Load sHET genes
shet.genes <- fread("rawdata/genelists/shet.hgnc.txt")
## Remember, we had to annotate sHET with hg38 gene IDs
setnames(shet.genes,names(shet.genes),c("hg19.GENE","GENE","sHET.val","HGNC.ID"))
shet.genes[,deciles:=cut(sHET.val,breaks=quantile(sHET.val,seq(0,1,by=0.1)),include.lowest = T)]
shet.genes[,sHET.val.binary:=cut(sHET.val,breaks=c(0,0.15,1),labels = c("lt_015","gt_015"),right = F)]

print(paste0("Total number of genes with sHET value                       : ", nrow(shet.genes)))
print(paste0("Total number of genes with sHET value in both hg19 and hg38 : ", nrow(merge(shet.genes,gene.translate))))

## Load pLI genes:
pli.genes <- fread("rawdata/genelists/hg19.all_genes_with_pli.txt")
pli.genes <- pli.genes[,c("V1","V6","V8","V5")]
setnames(pli.genes, c("hg19.GENE","GENE","pLI.val","HGNC.ID"))
pli.genes[,pLI.val.binary:=cut(pLI.val,breaks=c(0,0.9,1),labels = c("lt_09","gt_09"),right = F)]

## Generate lists for phenotype testing:
gene.lists <- list()
gene.lists["highPLI"] = list(pli.genes[pLI.val >= 0.9,hg19.GENE])
gene.lists["highsHET"] = list(shet.genes[sHET.val >= 0.15,hg19.GENE])

```

#### UKBB Unmapped Regions

It was recently identified that the UKBB data was not aligned properly and as such has several genes without any variants... Purpose of this code is to check which genes these are based on a list of "affected" baits given by the UKBB team.

**Note**: This code requires bedtools to be installed and in your PATH.

```{bash get bad genes}
## Note -- this may break if you do not have one of these files!
source ~/.bash_profile
source ~/.bashrc

## This gets a list of baits that are affected by the issues in UKBB
curl -o rawdata/ukbb_missing_baits/xgen_plus_spikein_b38_alt_affected.bed biobank.ctsu.ox.ac.uk/crystal/crystal/auxdata/xgen_plus_spikein_b38_alt_affected.bed

## Need to make a bed file of the genes that are available in Hg38
perl -ane 'chomp $_; print "$F[1]\t$F[2]\t$F[3]\t$F[0]\n";' rawdata/genelists/hg38.all_genes_with_pli.txt > rawdata/ukbb_missing_baits/hg38.genes.bed

## Count the total number of times a gene has a missing bait
/usr/bin/env bedtools intersect -c -a rawdata/ukbb_missing_baits/hg38.genes.bed -b rawdata/ukbb_missing_baits/xgen_plus_spikein_b38_alt_affected.bed > rawdata/ukbb_missing_baits/intersected.txt

## Convert gene IDs to Hg19
scripts/matcher.pl -file1 rawdata/genelists/hg38_to_hg19_ENSG.txt -file2 rawdata/ukbb_missing_baits/intersected.txt -col2 3 -r > rawdata/ukbb_missing_baits/intersected.hg19.txt
```

```{r new baits, fig.height=4, fig.width=8}

new.baits <- fread("rawdata/ukbb_missing_baits/intersected.hg19.txt")
setnames(new.baits,names(new.baits),c("chr","start","end","hg38.GENE","baits.hit","hg19.GENE","hg19.GENE.2"))
new.baits[,affected:=baits.hit>0]
new.baits[,dummy:=1]

ggplot(new.baits,aes(baits.hit)) + geom_histogram(binwidth=1) + scale_y_log10(name="# of Genes") + scale_x_continuous(name="Total Baits Affected") + theme

## This is the list of bad genes in Hg19 IDs!
bad.genes <- new.baits[baits.hit>0,hg19.GENE]

## Are some Shet gene groups enriched for bad genes?
shet.genes[,bad.gene:=hg19.GENE %in% bad.genes]

shet.genes[,dummy:=1]
counts <- shet.genes[,list(sum(bad.gene),sum(dummy)),by=deciles]
setnames(counts,c("V1","V2"),c("bad.gene","all"))
counts[,pct:=bad.gene/all]

ggplot(shet.genes,aes(deciles,sHET.val,group=interaction(bad.gene,deciles),colour=bad.gene)) + geom_boxplot() + xlab("S.het Quintile") + scale_y_log10(name="S.het") + theme

ggplot(counts,aes(deciles,pct)) + geom_col(fill="blue",colour="black") + theme

## FET
counts <- shet.genes[,list(sum(bad.gene),sum(dummy)),by=sHET.val.binary]
setnames(counts,c("V1","V2"),c("bad.gene","all"))
counts[,all:=all-bad.gene]

shet.ft <- fisher.test(counts[,c("bad.gene","all")])
prop.table <- prop.table(as.matrix(counts[,c("bad.gene","all")]),margin=1)

## Print data for paper:
print(paste0("Number of sHET genes affected : ", nrow(shet.genes[bad.gene == T])))
print(paste0("Prop of ≥ 0.15 sHET           : ", sprintf("%0.1f",prop.table[2,1]*100), "%"))
print(paste0("Prop of < 0.15 sHET           : ", sprintf("%0.1f",prop.table[1,1]*100), "%"))
print(paste0("Fisher test p                 : ", sprintf("%0.2g",shet.ft$p.value)))

rm(counts, shet.ft, new.baits, prop.table)
```

### Disease Genes

```{r Load Disease Genes}

## Get a list of genes to exclude which are known OMIM/DD/ClinVar genes
disease.genes <- fread("rawdata/genelists/diseaseGenes.txt",header=F)
setnames(disease.genes,"V1","hg19.GENE")
print(paste0("Number of disease genes: ", nrow(disease.genes)))

```

### Male Infertility Genes

```{r Load Male Infertility Genes}
male.infertility.genes <- fread("rawdata/genelists/male_infertility_genes.annotated.txt",header=F)
setnames(male.infertility.genes,names(male.infertility.genes),c("GENE","inheritance","evidence","hg19.GENE"))

print(paste0("Number of male infertility genes: ", nrow(male.infertility.genes)))
```

## 4C. Gene Expression Data

This code just quickly downloads GTEx expression data (v7) from the [GTEx Consortium](https://gtexportal.org/home/datasets) and loads it into R so we can use it later.

```{bash Download GTEx}

curl -o rawdata/genelists/GTEx_Analysis_2016-01-15_v7_RNASeQCv1.1.8_gene_median_tpm.gct.gz https://storage.googleapis.com/gtex_analysis_v7/rna_seq_data/GTEx_Analysis_2016-01-15_v7_RNASeQCv1.1.8_gene_median_tpm.gct.gz
gunzip -f rawdata/genelists/GTEx_Analysis_2016-01-15_v7_RNASeQCv1.1.8_gene_median_tpm.gct.gz

```

```{r Load Gene Expression}
## GTEX expression data:
expression <- fread("rawdata/genelists/GTEx_Analysis_2016-01-15_v7_RNASeQCv1.1.8_gene_median_tpm.gct")
expression[,c("gene","vers"):=tstrsplit(gene_id,".",fixed=T),by=1:nrow(expression)]
setnames(expression,"gene","hg19.GENE")

## GTEx testis expression
expression.testis <- expression[,c("hg19.GENE","Testis")]

rm(expression)
```

## 4D. Variant Data

### SNV Data

#### Downloading Requisite Data From UKBB

Section tbd, but need to make sure they get two files:

1. Variant calls themselves: `rawdata/snvresources/counts.ukbb_wes.revised.txt`
2. Field of 'has wes' from our derived data. I have already created a fake version at `rawdata/snvresources/has_exome.txt`

```{bash}



```

#### Annotating Rare Variants in UKBB

SNV and InDel annotation is handled by a separate repository, as the pipeline was written for more general annotation of sequencing data. Please see the following repository for how UKBB data was filtered/annotated from raw VCF files:

`https://github.com/eugenegardner/SNVCounter`

#### Build Data Files

This section does the actual loading of UKBB SNV data into R.

```{r load variant counts}

load.data <- function(counts.file, 
                      samples.file, 
                      indv.to.keep) {
  
  ## Read the counts file:
  variant.counts <- fread(counts.file)
  setnames(variant.counts,names(variant.counts),c("eid","gt","chr","pos","ref","alt","CADD","MPC","gnomadAF","VQSR","PEXT","CSQ","UKBB.AC","AN","UKBB.AF","AP","GENE","last_exon","last_intron"))
  
  ## Fix the sample IDs, which have a '_' in them. Have to do it this way otherwise it's insanely slow:
  ids <- unique(variant.counts[,c("eid")])
  ids[,eid.split:=str_split_fixed(eid,pattern = "_",n = 2)[1],by=1:nrow(ids)]
  variant.counts <- merge(variant.counts,ids,by="eid")
  variant.counts[,eid:=eid.split]
  variant.counts[,eid.split:=NULL]
  
  ## Set a variable in the table for SNV or INDEL
  variant.counts[,allele.type:=ifelse(nchar(ref)==nchar(alt),"SNV","INDEL")]
  
  ## Set gnomadAF to 0 if it was not found for a particular variant
  variant.counts[,gnomadAF:=ifelse(is.nan(gnomadAF),0,gnomadAF)]
  
  ## Need this because some samples might have 0 variants. (SYN should always have some...?)
  ## Will load a list of samples that we should expect to have and attaches the phenotype ID to them
  final.samples <- fread(samples.file)
  final.samples <- final.samples[has.exome==1]
  final.samples[,eid:=as.character(eid)]
  
  # Exclude/Include individuals/variants based on ancestry and relatedness
  variant.counts <- variant.counts[eid %in% indv.to.keep]
  final.samples <- final.samples[eid %in% indv.to.keep,c("eid")]
  
  ###!! FILTERING !!###
  ## Filter by CADD & MPC:
  variant.counts <- variant.counts[((CSQ == "LOF_HC" | (CSQ == "MIS" & MPC > 2)) & CADD > 25) | (CSQ != "LOF_HC" & CSQ != "MIS")]

  ## Get rid of last exon LoFs:
  variant.counts <- variant.counts[(CSQ == "LOF_HC" & last_exon == F & last_intron == F) | (CSQ != "LOF_HC")]
  
  ## Filter by gnomAD MAF:
  variant.counts <- variant.counts[gnomadAF < 0.001]
  
  ## Filter by PEXT:
  # Only filter by PEXT for allosomes -- hemizygous genes do not use PEXT
  variant.counts <- variant.counts[((chr == "X" | chr == "Y") & PEXT >= 0) | PEXT >= 0.1]
  
  ## Filter by allele missingness:
  variant.counts <- variant.counts[AN >= AP/2]
  ###!! FILTERING !!###

  return(list(variant.counts,final.samples))
  
}

# UKBB/Hg38
counts.file <- "rawdata/snvresources/counts.ukbb_wes.revised.txt"
samples.file <- "rawdata/snvresources/has_exome.txt"
indv.to.keep <- paste0(UKBB.phenotype.data[,eid])

## The weird paste is because of how sampleIDs are represented in the variants table
data.UKBB <- load.data(counts.file,samples.file,indv.to.keep)
variants.UKBB <- data.UKBB[[1]]
samples.UKBB <- data.UKBB[[2]]
rm(data.UKBB)

## Translate geneIDs from Hg38 to Hg19
variants.UKBB <- merge(variants.UKBB,gene.translate,by.x = "GENE",by.y = "hg38.GENE",all.x=T)
variants.UKBB[,GENE:=hg19.GENE]
variants.UKBB[,hg19.GENE:=NULL]

rm(indv.to.keep, counts.file, samples.file)
```

#### Plotting Various Counts

Just plotting some simple variant count diagrams for QC purposes. This data will be used to make supplementary figures later.

```{r Plotting Variant Totals, fig.height=4, fig.width=6}

count.variants <- function(variant.counts,samples,af.cutoff) {

  counts.AC1 <- variant.counts[UKBB.AC == 1,sum(gt),by=c("eid","CSQ")]
  counts.AC1[,AF:="AC1"]
  counts.AF0.1 <- variant.counts[UKBB.AF < af.cutoff,sum(gt),by=c("eid","CSQ")]
  counts.AF0.1[,AF:="AF0.1"]

  count.table <- bind_rows(counts.AC1,counts.AF0.1)

  samples.table <- data.table(crossing(samples=samples[,eid],CSQ=c("LOF_HC","MIS","SYN"),AF=c("AC1","AF0.1")))
  setnames(samples.table,"samples","eid")
  
  count.table <- merge(samples.table,count.table,by=c("eid","CSQ","AF"),all.x=T)
  count.table[,V1:=ifelse(is.na(V1),0,V1)]
  
  setnames(count.table,"V1","count")
  
  return(count.table)
  
}

UKBB.counts <- count.variants(variants.UKBB,samples.UKBB,0.001)
UKBB.plot <- ggplot(UKBB.counts,aes(CSQ,count,colour=AF)) + geom_boxplot() + ggtitle("UKBB") + ylim(0,100) + theme.legend
UKBB.genes <- variants.UKBB[CSQ == "SYN" & UKBB.AF<=1e-3,sum(gt),by=GENE]
setnames(UKBB.genes,"V1","UKBB")

UKBB.plot

ggplot(UKBB.counts[AF=="AC1" & CSQ=="LOF_HC"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AC = 1 LoF Variants") + theme.legend
ggplot(UKBB.counts[AF=="AC1" & CSQ=="MIS"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AC = 1 Missense Variants") + theme.legend
ggplot(UKBB.counts[AF=="AC1" & CSQ=="SYN"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AC = 1 Synonymous Variants") + theme.legend

ggplot(UKBB.counts[AF=="AF0.1" & CSQ=="LOF_HC"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AF < 0.001 LoF Variants") + theme.legend
ggplot(UKBB.counts[AF=="AF0.1" & CSQ=="MIS"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AF < 0.001 Missense Variants") + theme.legend
ggplot(UKBB.counts[AF=="AF0.1" & CSQ=="SYN"],aes(count,..density..)) + scale_alpha_discrete(range=c(1,0.5)) + geom_histogram(binwidth=1,position="identity") + ggtitle("AF < 0.001 Synonymous Variants") + theme.legend + xlim(0,200)

rm(UKBB.plot)
```

#### Variant Totals / Individual / Gene Group

This is where we make the variant count totals for each individual for the purposes of phenotype testing. This first code block is for simple gene lists (high pLI/sHET) where we just count total number of variants.

```{r Total Number of Variants Per Gene Category}

get.gene.counts.snvs <- function(data, samples, maf) {
    
    variants <- data.table(crossing(sample_id=samples[,eid],type=c("LOF_HC","SYN","MIS")))
    
    ## This handles the high pLI/sHET lists:
    for (gene.list in names(gene.lists)) {
    
      current.genes <- get(gene.list,gene.lists)
      
      ## Filter on frequency cutoff and gene list
      if (maf == 0) {
        counts <- data[UKBB.AC == 1 & GENE %in% current.genes & chr!="X" & chr!="Y",sum(gt),by=c("eid","CSQ")]
      } else {
        counts <- data[UKBB.AF <= maf & GENE %in% current.genes & chr!="X" & chr!="Y",sum(gt),by=c("eid","CSQ")]
      }
      
      variants <- merge(variants,counts,by.x=c("sample_id","type"),by.y=c("eid","CSQ"),all.x=T)
      variants[,V1:=if_else(is.na(V1),0L,V1)]
      setnames(variants,"V1",gene.list)
      
    }
    
    variants[,allele.freq:=maf]
    setcolorder(variants,c(names(variants)[-grep("type",names(variants))],c("type")))
    return(variants)
}

snv.counts <- bind_rows(get.gene.counts.snvs(variants.UKBB,samples.UKBB,0),
                        get.gene.counts.snvs(variants.UKBB,samples.UKBB,1e-3))

```

And this code block does the calculation for s~het~ listed in the manuscript:

$$s_{het[i,v]}=1-\prod_{g} (1-s_{het[i,v,g]})$$

```{r quantitative sHET SNV}

quantify.shet.snv <- function(maf, type, to.remove=c()) {
    
    ## Filter on frequency cutoff and gene list
    if (maf == 0) {
      returned <- variants.UKBB[UKBB.AC == 1 & chr!="X" & chr!="Y" & CSQ == type & !GENE %in% to.remove]
    } else {
      returned <- variants.UKBB[UKBB.AF <= maf & chr!="X" & chr!="Y" & CSQ == type & !GENE %in% to.remove]
    }
    
    returned <- merge(returned,shet.genes[,c("hg19.GENE","sHET.val")],by.x="GENE",by.y="hg19.GENE")
    returned <- returned[,list(1-prod(1-sHET.val)),by="eid"]

    setnames(returned,c("eid","V1"),c("sample_id","product_sHET"))
    returned[,allele.freq:=maf]
    returned[,type:=type]
    
    return(returned)

}

## First do regular sHET list
quants <- data.table()
shet.quant.table <- data.table(crossing(allele.freq=unique(snv.counts[,allele.freq]),type=unique(snv.counts[,type])))

for (i in c(1:nrow(shet.quant.table))) {
  
  returned <- quantify.shet.snv(shet.quant.table[i,allele.freq],
                                shet.quant.table[i,type])

  returned[,allele.freq:=shet.quant.table[i,allele.freq]]
  returned[,type:=shet.quant.table[i,type]]
  
  quants <- bind_rows(quants,returned)
  
}

snv.counts <- merge(snv.counts,quants,by=c("sample_id","allele.freq","type"),all.x=T)
snv.counts[,product_sHET:=if_else(is.na(product_sHET),0,product_sHET)]

## Then do male infertility list
quants <- data.table()
shet.quant.table <- data.table(crossing(allele.freq=unique(snv.counts[,allele.freq]),type=unique(snv.counts[,type])))

for (i in c(1:nrow(shet.quant.table))) {
  
  returned <- quantify.shet.snv(shet.quant.table[i,allele.freq],
                                shet.quant.table[i,type],
                                male.infertility.genes[,hg19.GENE])

  returned[,allele.freq:=shet.quant.table[i,allele.freq]]
  returned[,type:=shet.quant.table[i,type]]
  
  quants <- bind_rows(quants,returned)
  
}

setnames(quants,c("product_sHET"),c("product_sHET_no_male_infertility"))

snv.counts <- merge(snv.counts,quants,by=c("sample_id","allele.freq","type"),all.x=T)
snv.counts[,product_sHET_no_male_infertility:=if_else(is.na(product_sHET_no_male_infertility),0,product_sHET_no_male_infertility)]

## Then do no disease list
quants <- data.table()
shet.quant.table <- data.table(crossing(allele.freq=unique(snv.counts[,allele.freq]),type=unique(snv.counts[,type])))

for (i in c(1:nrow(shet.quant.table))) {
  
  returned <- quantify.shet.snv(shet.quant.table[i,allele.freq],
                                shet.quant.table[i,type],
                                disease.genes[,hg19.GENE])

  returned[,allele.freq:=shet.quant.table[i,allele.freq]]
  returned[,type:=shet.quant.table[i,type]]
  
  quants <- bind_rows(quants,returned)
  
}

setnames(quants,c("product_sHET"),c("product_sHET_no_disease"))

snv.counts <- merge(snv.counts,quants,by=c("sample_id","allele.freq","type"),all.x=T)
snv.counts[,product_sHET_no_disease:=if_else(is.na(product_sHET_no_disease),0,product_sHET_no_disease)]

rm(quants,shet.quant.table,returned)
```

### CNV Data

For how CNV data was prepared prior to this step, please see the document `CNVCalling_and_Filtering.RMD` which handles all of the data collation and QC of CNVs. This section only deals with getting the result of that document into R and attaching/quantifying gene data. The ultimate outputs of that document read in here are:

1. Annotations for each CNV as created with VEP and custom perl script.
2. Individuals which actually have CNV data.
3. The CNVs themselves.

```{r fix, eval = F}

get.header <- readRDS("/Users/eg15/Documents/Current Projects/INTERVAL/CNVCalling_Filtering/RawData/ukbb.batchAll.qcd.04032020.rds")
header <- names(get.header)
header <- c(header,c("locus","path.locus"))
rm(get.header)

ukbb.to.fix <- fread("rawdata/cnvresources/ukbb.unfiltered.qcdMerged.txt")
setnames(ukbb.to.fix,names(ukbb.to.fix),header)

split.files <- ukbb.to.fix[,"split.file"]
split.files <- unique(split.files)
split.files[,short.name:=sub(".sorted.bed.gz","",basename(split.file)),by=1:nrow(split.files)]

merge.key <- fread("/Users/eg15/Documents/Current Projects/INTERVAL/CNVCalling_Filtering/UKBB_Batches/Link_file_George_Eugene.dat")
merge.key <- merge.key[,c("ID","f.eid")]
setnames(merge.key,"f.eid","george")
merge.key[,george:=as.character(george)]

george_to_martin <- fread("/Users/eg15/Documents/Current Projects/INTERVAL/CNVCalling_Filtering/UKBB_Batches/George_to_Martin.txt")
george_to_martin <- george_to_martin[,c("V1","V7","V12")]
setnames(george_to_martin, names(george_to_martin),c("george","eid","array_num"))
george_to_martin[,george:=as.character(george)]
george_to_martin[,eid:=as.character(eid)]

merge.key <- merge(merge.key,george_to_martin,by="george")
merge.key <- merge(split.files, merge.key,by.x = "short.name",by.y = "ID")
merge.key <- merge.key[,c("split.file","eid")]
ukbb.to.fix <- merge(ukbb.to.fix, merge.key, by = "split.file")

cols.to.keep <- c("eid","chr","start","end","locus","Copy_Number","gt","ct","Length_bp","path.locus","Max_Log_BF","LRR_mean","LRR_median","LRR_SD","BAF_mean","BAF_median","BAF_SD","WF","BAF_drift","NumCNV","density","callrate","wes.probe.count","No_Probes","site.BAF_mean","site.BAF_SD","site.BAF_median","site.LRR_mean","site.LRR_SD","site.LRR_median","badness.score","filter.0.95.wes.support.score","wes.support.score")

ukbb.to.fix[,ct:=if_else(Copy_Number < 2, "DEL", "DUP")]
ukbb.to.fix[,ct:=as.factor(ct)]
ukbb.to.fix[,gt:=ifelse(Copy_Number == 0 | Copy_Number == 4,2,1)]

ukbb.to.fix <- ukbb.to.fix[,..cols.to.keep]

to.filter <- fread("/Users/eg15/Documents/Current Projects/Fertility/RawData/cnvs/ukbb.filtered_cnv_indvs.txt")
to.filter <- merge(to.filter,merge.key,by="split.file")

fam <- fread("../../INTERVAL/CNVCalling_Filtering/UKBB_Batches/ukb44165_cal_chr1_v2_s488288.fam")

wba <- UKBB.raw.phenotypes[,c("eid","22006-0.0")]
setnames(wba,names(wba),c("eid","wba"))
wba[,in.fam:=if_else(eid %in% fam[,V1],1,0)]
wba[,has_cnvs:=if_else(in.fam == 0, 0, if_else(eid %in% to.filter[,eid], 0, 1))]
wba[,has_called_cnvs:=if_else(in.fam == 0,NaN,if_else(eid %in% ukbb.to.fix[,eid],1,0))]
table(wba[,c("has_called_cnvs","has_cnvs")],useNA = "always")

write.table(wba[,c("eid","has_cnvs")],"rawdata/cnvresources/has_cnvs.txt",sep = "\t", col.names = T, row.names = F, quote = F)
write.table(ukbb.to.fix,"rawdata/cnvresources/ukbb.cnvs.qcd.txt",sep = "\t", col.names = T, row.names = F, quote = F)

```


#### Downloading Requisite Data From UKBB

Section tbd, but need to make sure they get two files:

1. Variant calls themselves: `rawdata/snvresources/counts.ukbb_wes.revised.txt`
2. Field of 'has CNV data' from our derived data. I have already created a fake version at `rawdata/snvresources/has_cnv_data.txt`

```{bash}



```

#### Building R Annotations from VEP:

```{r Build Annotations, fig.height=4, fig.width=10}

## Get annotation information:
annotations<-fread("rawdata/cnvresources/cnv_vep_parsed.sorted.bed")
setnames(annotations,names(annotations),c("chr","start","end","ct","genes","plis","shets","highPLI","highsHET","product_sHET","product_sHET_no_disease","product_sHET_no_male_infertility"))

# Add a matchable locus:
annotations[,locus:=paste0(chr,":",start,"-",end)]
```

#### Build Data Files

Have created a file that contains the merged loci for MAF calculation:

And using VEP annotated file as generated from `CNVCalling_Filtering.Rmd`

UKBB Samples dropped here are derived from a few different sources:

1. Those who failed CNV QC (n = 2,591 individuals)
2. They were part of a batch with no calls (currently only know of batch18 - n = 4,620)

All other individuals are included if they are white British ancestry and unrelated (as set in the above 'Setting Individuals To Use' section).

There are also 75 individuals which exist in the CNV file but do not have IDs. I'm fairly certain these are individuals with removed consent (so good they aren't included!)

```{r Build Modified annotated.cnvs}

build.omics.map <- function(cnv.file, id.name, merge.key) {

  ## Get allele frequency information from CNVCalling_Filtering.Rmd:
  annotated.cnvs.qcd <- fread(cnv.file)
  annotated.cnvs.qcd[,eid:=as.character(eid)]
  
  # Add impact information
  annotated.cnvs.qcd <- merge(annotated.cnvs.qcd,annotations[,c("ct","genes","highPLI","highsHET","product_sHET","product_sHET_no_disease","product_sHET_no_male_infertility","locus")],by=c("locus","ct"))

  for (g in names(gene.lists)) {
    annotated.cnvs.qcd[,eval(g):=get(g)*gt]
  }
  
  return(annotated.cnvs.qcd)
  
}

## UKBB - I need to translate the IDs from George to Martin application as well:
ukbb.annotated.cnvs.qcd <- build.omics.map("rawdata/cnvresources/ukbb.cnvs.qcd.txt")

## Get individuals w/o any CNV data (regardless of QC)
has.cnv.data <- fread("rawdata/cnvresources/has_cnvs.txt")
has.cnv.data[,eid:=as.character(eid)]
```

#### Variant Totals / Individual / Gene Group

Doing it this way so all of my main association testing uses the exact same numbers!

```{r CNV Variant Totals}

## Set samples with Phenotype data
samples.UKBB.cnv <- UKBB.phenotype.data[,c("eid")]

## ... And remove bad arrays/missing data:
samples.UKBB.cnv <- samples.UKBB.cnv[eid %in% has.cnv.data[has_cnvs==1,eid]]

get.gene.counts.cnvs <- function (maf, type) {
  
  samp.size <- nrow(samples.UKBB.cnv)
  test <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score == T & ct == type]
  
  allele.frq <- test[ct==type,sum(gt),by=c("locus")]
  allele.frq[,frq:=V1/(samp.size*2)]
  setnames(allele.frq,"V1","ac")
  
  test <- merge(test,allele.frq[,c("locus","frq","ac")],by=c("locus"))
  
  g.names <- names(gene.lists)
  
  if (maf == 0) {
    test.counted <- test[ac == 1,lapply(.SD, sum),by="eid", .SDcols=g.names]
    test.counted.product <- test[ac == 1, list(1-prod(1-product_sHET),1-prod(1-product_sHET_no_male_infertility),1-prod(1-product_sHET_no_disease)),by="eid"]
  } else {
    test.counted <- test[frq <= maf,lapply(.SD, sum),by="eid", .SDcols=g.names]
    test.counted.product <- test[frq <= maf, list(1-prod(1-product_sHET),1-prod(1-product_sHET_no_male_infertility),1-prod(1-product_sHET_no_disease)),by="eid"]
  }
  
  setnames(test.counted.product,c("V1","V2","V3"),c("product_sHET","product_sHET_no_male_infertility","product_sHET_no_disease"))
  final.stats <- merge(samples.UKBB.cnv,test.counted,by="eid",all.x=T)
  final.stats <- merge(final.stats,test.counted.product,by="eid",all.x=T)
  final.stats[,allele.freq:=maf]
  final.stats[,type:=type]
  final.stats[is.na(final.stats)] <- 0
  
  setnames(final.stats,"eid","sample_id")
  
  return(final.stats)
  
}

cnv.counts <- bind_rows(get.gene.counts.cnvs(1e-3,"DEL"),
                        get.gene.counts.cnvs(0,"DEL"),
                        get.gene.counts.cnvs(1e-3,"DUP"),
                        get.gene.counts.cnvs(0,"DUP"))
```

### Combining All Variant Totals

```{r Combine Variants}

## Master table of ALL variants:
# Set SNV column order the same because of the quantification magic I have to do above:
setcolorder(snv.counts,neworder=names(cnv.counts))
variant.counts <- bind_rows(cnv.counts,snv.counts)

paste0("Number of individuals with CNV data: ", length(unique(variant.counts[type == "DEL" & allele.freq == 0,sample_id])))
paste0("Number of individuals with SNV data: ", length(unique(variant.counts[type == "LOF_HC" & allele.freq == 0,sample_id])))

rm(cnv.counts, snv.counts)
```

#### Burden of variants by Sex

Just to make sure sexes aren't burdened different between variant classes among highly constrained genes.

```{r Plotting Quant sHET, fig.height=5, fig.width=4}

## Sex specific burden:
sex.burden.calc <- function(t) {

  sex.specific <- variant.counts[allele.freq == 0 & type == t,c("sample_id","product_sHET")]
  sex.specific <- merge(sex.specific,UKBB.phenotype.data[,c("eid","sexPulse")],by.x="sample_id",by.y="eid")
  print(nrow(sex.specific))

  sex.specific[,product_sHET.log:=log10(product_sHET)]
  ## Can do two tests, proportion in each sex with SOME sHET value, and actual testing burden of sHET
  print(wilcox.test(product_sHET.log ~ sexPulse, data = sex.specific))
  chi.sq <- matrix(c(nrow(sex.specific[product_sHET < 0.15 & sexPulse == 1]),
                     nrow(sex.specific[product_sHET < 0.15 & sexPulse == 2]),
                     nrow(sex.specific[product_sHET >= 0.15 & sexPulse == 1]),
                     nrow(sex.specific[product_sHET >= 0.15 & sexPulse == 2])),
                   nrow = 2,
                   dimnames = list(c("Male","Female"),c(paste0("No ",t),paste0("Has ", t))))

  prop <- prop.table(chi.sq,margin = 1)*100
  fisher <- fisher.test(chi.sq)
  
  format.text <- paste0(t, " ≥ 0.15 sHET Prop Male (", sprintf("%0.2f",prop[1,2]),"), Female (", sprintf("%0.2f",prop[2,2]),"), p = ", sprintf("%0.2f", fisher$p.value))
  print(format.text)
  return(format.text)

}

format.sex.burden.DEL <- sex.burden.calc("DEL")
format.sex.burden.PTV <- sex.burden.calc("LOF_HC")
```

# 5. Variant Burden Impact on Traits

## 5A. Function for Linear Modeling

This code blob builds a function which does linear or logistic modeling for all my variant associations of the format:

$ phenotype \sim s_{het[i,v]} + age + age^2 + PC1..PC10 $

Where

$ s_{het[i,v]}$

is the s~het~ burden in individual $i$ for variant class $v$, where $v$ can be DEL, DUP, PTV, Missense, or Synonymous. This block has a number of flags to handle the differing cases we test (i.e. logistic vs linear model, removing all individuals without children, etc.).

```{r Linear Regression Function}

run.regression <- function(maf,
                           gene.list,
                           y.var,
                           sex,
                           variant.type,
                           binary,
                           add.covars = c(),
                           return.data = F,
                           remove.zeros = F,
                           remove.sequenced = T,
                           cutoff.high = F) {
 
  phenotypes <- UKBB.phenotype.data
  id.name <- "eid"
  
  cols.to.keep <- c("sample_id",gene.list)
  final.stats <- variant.counts[type == variant.type & allele.freq == maf,..cols.to.keep]

  if (remove.sequenced == T & (variant.type == "DEL" | variant.type == "DUP")) {
    final.stats <- final.stats[!sample_id %in% samples.UKBB[,eid]]
  }
  
  if (cutoff.high == T & (variant.type == "DEL" | variant.type == "DUP" | variant.type == "LOF_HC")) {
    final.stats <- final.stats[get(gene.list) <= 3]
  }
  
  final.stats <- merge(final.stats,UKBB.phenotype.data,by.x="sample_id",by.y=id.name)
  
  ## Remove missing y.var data
  final.stats <- final.stats[!is.na(get(y.var))]
  if (remove.zeros == T) {
    final.stats <- final.stats[get(y.var)>0]
  }

  ## Do a model w/o sex
  if (sex == 1 | sex == 2) {
    final.stats <- final.stats[sexPulse == sex]
  }
  
  ## Set linear or logistic model
  if (binary == T) {
    fam <- "binomial"
    ## And force the phenotype to binary:
    final.stats[,binary.stat:=if_else(get(y.var) > 0,1,0)]
    y.var <- "binary.stat"
  } else {
    fam <- "gaussian"
  }
  
  ## Remove missing additional covar data
  for (cov in add.covars) {
    final.stats <- final.stats[!is.na(get(cov))]
  }
  
  covariates <- c(gene.list,"PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10","agePulse.squared","agePulse","sexPulse",add.covars)
  
  cov.string <- paste(covariates, collapse=" + ")
  formated.formula <- as.formula(paste(y.var, cov.string,sep=" ~ "))

  covariates <- c(covariates,add.covars)
  cov.string <- paste(covariates, collapse=" + ")
  formated.formula <- as.formula(paste(y.var, cov.string,sep=" ~ "))
  
  test.lm <- glm(formated.formula, data=final.stats, family=fam)
  coef.lm <- tidy(test.lm) %>% data.table()
  final.stats <- augment(test.lm) %>% data.table()

  total.hits <- final.stats[,sum(get(gene.list))]
  
  return(list(coef.lm[term==eval(gene.list),estimate],
    coef.lm[term==eval(gene.list),std.error],
    coef.lm[term==eval(gene.list),p.value],
    total.hits,
    nrow(final.stats)))
  
}
```

## 5B. Plotting Function

This is a plotting function for generating a nice formated plot for initial data visualization purposes. It isn't used for any main text/supplemental data or figures.

```{r Plotting Function, fig.height=7, fig.width=8}

plot.result <- function(data, binary, num.tests, ymin, ymax, y.lab) {

  plottable <- copy(data)
  ## This just makes it so the labels aren't 500 miles long:
  plottable[,gene.list.2:=factor(gene.list,
                                 levels=sort(unique(plottable[,gene.list])),
                                 labels=c(str_wrap(gsub("_"," ",gsub("\\."," ",sort(unique(plottable[,gene.list])))),width=20)))]
  
  ## Checks for significance:
  # Note: We did 140 total tests in UKBB-FI data if including both MAFs, both sexes, and all gene lists
  # I think 140 is a bit restrictive as the MAF tests are likely independent, so going with 70 tests (exclude MAF cutoffs from correction)
  sig.threshold <- 0.05/num.tests
  
  ## Confidence Intervals and significance
  if (binary == T) {
    ## Convert to OR (I don't think this should effect the original table...)
    plottable[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
    plottable[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
    plottable[,sig.pos:=if_else(var.beta<0,var.ci.lower-0.1,var.ci.upper+0.1)]
    
    plottable[,var.beta:=exp(var.beta)]
    ylab <- "Odds Ratio"
    yline <- 1

  } else {
    plottable[,var.ci.upper:=var.beta + (1.96*var.stderr)]
    plottable[,var.ci.lower:=var.beta - (1.96*var.stderr)]
    plottable[,sig.pos:=if_else(var.beta<0,var.ci.lower-0.05,var.ci.upper+0.05)]

    ylab <- "Effect Size"
    yline <- 0
  }
  
  ## Set Arrows!
  plottable[,var.ci.lower.symbol:=if_else(var.ci.lower<ymin,25,NaN)]
  plottable[,var.ci.lower:=if_else(var.ci.lower<ymin,ymin,var.ci.lower)]
  plottable[,var.ci.upper.symbol:=if_else(var.ci.upper>ymax,24,NaN)]
  plottable[,var.ci.upper:=if_else(var.ci.upper>ymax,ymax,var.ci.upper)]
  
  plottable[,sig:=if_else(var.p <= sig.threshold, "*", "")]
  
  plottable[,sex:=factor(sex,levels=c(1,2,3),labels=c("Male","Female","Both"))]
  
  betas <- ggplot(plottable,aes(x=gene.list.2,y=var.beta,group=interaction(sex,variant.type,maf),colour=variant.type,linetype=as.factor(maf),shape=as.numeric(sex)+16)) +
    geom_hline(aes(yintercept=yline),type=7,colour="red") +
    geom_point(position=position_dodge(width=1)) +
    scale_x_discrete(name="") +
    scale_y_continuous(name=ylab,limits = c(ymin,ymax)) +
    geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),position=position_dodge(width=1),width=0) +
    geom_text(aes(y=sig.pos,label=sig),position=position_dodge(width=1),size=10,hjust="middle") +
    geom_point(aes(y=var.ci.lower,shape=var.ci.lower.symbol,fill=variant.type),position=position_dodge(width=1)) +
    geom_point(aes(y=var.ci.upper,shape=var.ci.upper.symbol,fill=variant.type),position=position_dodge(width=1)) +
    ## This code which uses the 'unique' function is to keep it from breaking if Males aren't present
    scale_shape_identity(guide=guide_legend(title = "Sex"),breaks=as.numeric(unique(plottable[,sex])) + 16,labels=unique(plottable[,sex])) + 
    scale_color_discrete(guide="none") +
    scale_linetype_discrete(guide=guide_legend(title = "MAF Threshold")) +
    theme.legend + theme(axis.text.x = element_blank())
  
  counts <- ggplot(plottable,aes(gene.list.2,n.var,group=interaction(sex,variant.type,maf),fill=variant.type,linetype=as.factor(maf))) +
    geom_col(position=position_dodge(),colour="black") +
    scale_x_discrete(name="") +
    scale_y_log10(name=y.lab) +
    scale_fill_discrete(guide=guide_legend(title="Variant Type")) +
    scale_linetype_discrete(guide="none") +
    theme.legend +
    theme(axis.text.x=element_blank())
  
  plot <- (counts / betas) + plot_layout(heights=c(1,3),guides = "collect")
  
  plot
  
  return(plot)
  
}
```

## 5C. Fertility

### Main Regression

```{r fertility logistic model, fig.height=7, fig.width=8}
results.fertility <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = c("product_sHET"),
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = F),by=1:nrow(results.fertility)]

plot.result(results.fertility,T,20,0,1.4, "# of Individuals\nWith sHET\n> 0.15")
```

### Additional Analyses

#### Linear Model Instead of Logistic

This tests the relationship of s~het~ burden with actual number of children:

```{r binary children,  fig.height=7, fig.width=8}
results.fertility.linear <- data.table(crossing(maf = c(0.001,0),
                                     gene.list = "product_sHET",
                                     y.var = c("children.fathered","live.births"),
                                     variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility.linear[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.linear[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,F),by=1:nrow(results.fertility.linear)]

plot.result(results.fertility.linear,F,20,-1,0.5, "# of Individuals\nWith sHET\n> 0.15")
```

#### Using Gene Lists Instead of Quantitative sHET

```{r quantitative sHET, fig.height=7, fig.width=8}
results.fertility.genelists <- data.table(crossing(maf = c(0.001,0),
                                                   gene.list = names(gene.lists)[grep("highsHET|highPLI",names(gene.lists))],
                                                   y.var = c("children.fathered","live.births"),
                                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility.genelists[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.genelists[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,binary=T,cutoff.high = T),by=1:nrow(results.fertility.genelists)]

plot.result(results.fertility.genelists,T,70,0.5,1.2,"Total Number of\nVariants")

paste0("Number of DEL Individuals Lost, pLI ≥ 0.9  : ", results.fertility[variant.type == "DEL" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "DEL" & maf == 0 & gene.list == "highPLI",sum(n.indvs)])
paste0("Number of DEL Individuals Lost, sHET ≥ 0.9 : ", results.fertility[variant.type == "DEL" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "DEL" & maf == 0 & gene.list == "highsHET",sum(n.indvs)])

paste0("Number of PTV Individuals Lost, pLI ≥ 0.9  : ", results.fertility[variant.type == "LOF_HC" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "LOF_HC" & maf == 0 & gene.list == "highPLI",sum(n.indvs)])
paste0("Number of PTV Individuals Lost, sHET ≥ 0.9 : ", results.fertility[variant.type == "LOF_HC" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "LOF_HC" & maf == 0 & gene.list == "highsHET",sum(n.indvs)])

```

#### Only Individuals With >0 Children

```{r Only gt 0 Children, fig.height=7, fig.width=8}
results.fertility.zero <- data.table(crossing(maf = c(0.001,0), 
                                   gene.list = "product_sHET",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility.zero[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.zero[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,F,remove.zeros = T),by=1:nrow(results.fertility.zero)]

plot.result(results.fertility.zero,F,20,-1,0.5,"# of Individuals\nWith sHET\n> 0.15")
```

#### Excluding Various Genes/Individuals

##### Male Infertility Genes

```{r Exclude Male Infertility Genes, fig.height=7, fig.width=8}

results.excl.male <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET_no_male_infertility",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS"),
                                   quant = 0.15))
results.excl.male[,sex:=if_else(y.var=="children.fathered",1,2)]

results.excl.male[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.excl.male)]

plot.result(results.excl.male,T,70,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

##### Known Disease Genes

```{r Exclude Disease, fig.height=7, fig.width=8}

results.excl.disease <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET_no_disease",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.excl.disease[,sex:=if_else(y.var=="children.fathered",1,2)]

results.excl.disease[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.excl.disease)]

plot.result(results.excl.disease,T,70,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

##### Pathogenic CNV Carriers

```{r fertility no pathogenic, fig.height=7, fig.width=8}

## Get individuals that carry a known pathogenic CNV
ukbb.path.carriers <- unique(ukbb.annotated.cnvs.qcd[path.locus != "null" & filter.0.95.wes.support.score == T, eid])

## Kind of have to do this in a weird way so that I don't have to change my function massively
variant.counts.backup <- copy(variant.counts)
variant.counts <- variant.counts[!sample_id %in% ukbb.path.carriers]

results.fertility.no.path <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.fertility.no.path[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.no.path[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T,return.data = T),by=1:nrow(results.fertility.no.path)]

plot.result(results.fertility.no.path,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")

## Restore the original file and delete the backup:
variant.counts <- copy(variant.counts.backup)
rm(variant.counts.backup)

## Total number of individuals with path CNVs:
path.cnv.counts <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score == T & path.locus != "null"]

paste0("CNV Carriers account for ",sprintf("%0.1f",(length(unique(path.cnv.counts[,eid]))/nrow(samples.UKBB.cnv)*100)),"% (", length(unique(path.cnv.counts[,eid])),") of individuals.)")
```

#### Gene Expression in Testis

```{r Testis Expression, fig.height=5, fig.width=5}

dels.male <- ukbb.annotated.cnvs.qcd[ct == "DEL" & eid %in% samples.UKBB.cnv[,eid] & !eid %in% samples.UKBB[,eid] & filter.0.95.wes.support.score == T,c("eid","genes","locus","wes.support.score","gt")]

af <- dels.male[,sum(gt),by="locus"]
setnames(af,"V1","ac")
tot.samps <- nrow(samples.UKBB.cnv)
af[,af:=ac/(tot.samps*2)]

dels.male <- merge(dels.male,af,by="locus")
dels.male <- dels.male[ac == 1]

counts.dels <- data.table(table(dels.male[,unlist(genes)]))
setnames(counts.dels,c("V1","N"),c("hg19.GENE","N.del"))

counts.ptvs <- data.table(table(variants.UKBB[UKBB.AC==1 & CSQ == "LOF_HC" & eid %in% samples.UKBB[,eid],GENE]))
setnames(counts.ptvs,c("V1","N"),c("hg19.GENE","N.ptv"))

shet.genes.expr <- merge(shet.genes[,c("hg19.GENE","sHET.val","GENE")],expression.testis[,c("hg19.GENE","Testis")],by="hg19.GENE")
shet.genes.expr[,male.infertility:=hg19.GENE %in% male.infertility.genes[,hg19.GENE]]

shet.genes.expr <- merge(shet.genes.expr,counts.dels,by="hg19.GENE", all.x = T)
shet.genes.expr <- merge(shet.genes.expr,counts.ptvs,by="hg19.GENE", all.x = T)
shet.genes.expr[,N.del:=if_else(is.na(N.del),0L,N.del)]
shet.genes.expr[,N.ptv:=if_else(is.na(N.ptv),0L,N.ptv)]

shet.genes.expr[,has.del:=N.del>0]
shet.genes.expr[,has.ptv:=N.ptv>0]
shet.genes.expr[,log.mean:=log(Testis)]

## Has a Private DEL
ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(has.del), log.mean, group = as.factor(has.del))) + geom_boxplot() + scale_x_discrete(name = "Has a private DEL") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle(expression(s[HET]~`>`~0.15~Genes~Only)) + theme
wilcox.test(log.mean ~ has.del, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))

ggplot(shet.genes.expr, aes(as.factor(has.del), log.mean, group = as.factor(has.del))) + geom_boxplot() + scale_x_discrete(name = "Has a private DEL") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle("All Genes") + theme
wilcox.test(log.mean ~ has.del, data = shet.genes.expr,alternative=c("less"))

## Has a Private PTV
ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(has.ptv), log.mean, group = as.factor(has.ptv))) + geom_boxplot() + scale_x_discrete(name = "Has a private PTV") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle(expression(s[HET]~`>`~0.15~Genes~Only)) + theme
wilcox.test(log.mean ~ has.ptv, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))

ggplot(shet.genes.expr, aes(as.factor(has.ptv), log.mean, group = as.factor(has.ptv))) + geom_boxplot() + scale_x_discrete(name = "Has a private PTV") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle("All Genes") + theme
wilcox.test(log.mean ~ has.ptv, data = shet.genes.expr,alternative=c("less"))

## Is a male infertility gene
ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(male.infertility), log.mean, group = as.factor(male.infertility))) + geom_boxplot() + scale_x_discrete(name = "Is a male infertility gene") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle(expression(s[HET]~`>`~0.15~Genes~Only)) + theme
wilcox.test(log.mean ~ male.infertility, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))

ggplot(shet.genes.expr, aes(as.factor(male.infertility), log.mean, group = as.factor(male.infertility))) + geom_boxplot() + scale_x_discrete(name = "Is a male infertility gene") + scale_y_continuous(name = "Mean Expr. Testis") + ggtitle("All Genes") + theme
wilcox.test(log.mean ~ male.infertility, data = shet.genes.expr,alternative=c("less"))
```

#### Effect In Varying Age Groups

```{r Age Groupings, fig.height=4, fig.width=10}

res.age <- data.table()

for (i in c(40,50,60)) {

  age.remove <- UKBB.phenotype.data[agePulse < i | agePulse >= (i + 10),eid]
  
  ## Kind of have to do this in a weird way so that I don't have to change my function massively
  variant.counts.backup <- copy(variant.counts)
  variant.counts <- variant.counts[!sample_id %in% age.remove]
  
  results.fertility.age <- data.table(crossing(maf = c(0),
                                     gene.list = "product_sHET",
                                     y.var = c("children.fathered","live.births"),
                                     variant.type = c("DEL","LOF_HC"),
                                     age = i))
  
  results.fertility.age[,sex:=if_else(y.var=="children.fathered",1,2)]
  
  results.fertility.age[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.fertility.age)]
  
  res.age <- bind_rows(res.age,results.fertility.age[,c("var.beta","var.stderr","y.var","variant.type","age","n.indvs","var.p")])
  
  ## Restore the original file and delete the backup:
  variant.counts <- copy(variant.counts.backup)
  rm(variant.counts.backup)
  
}

for (i in c(40,50,60)) {
  
  for (a in c("children.fathered","live.births")) {
    
    meta.table <- res.age[age == i & y.var == a]
    
    meta.analy <- metagen(var.beta,
                          var.stderr,
                          studlab = variant.type,
                          method.tau = "SJ",
                          sm = "OR",
                          data = meta.table)

    res.age <- bind_rows(res.age,data.table(var.beta = meta.analy$TE.fixed,var.stderr = meta.analy$seTE.fixed,y.var = a,variant.type = "META",age = i, n.indvs=meta.table[,sum(n.indvs)],var.p=meta.analy$pval.fixed))
    
  }
  
}
  
res.age[,age:=as.character(age)]
## Actual results to compare against:
male <- results.fertility[sex == 1 & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC"),c("var.beta","var.stderr","y.var","variant.type","n.indvs","var.p")]
male[,age:="ALL"]
meta.analy.male <- metagen(var.beta,
                          var.stderr,
                          studlab = variant.type,
                          method.tau = "SJ",
                          sm = "OR",
                          data = male)

male <- bind_rows(male,data.table(var.beta = meta.analy.male$TE.fixed,var.stderr = meta.analy.male$seTE.fixed,y.var = "children.fathered",variant.type = "META",age = "ALL", n.indvs=male[,sum(n.indvs)],var.p=meta.analy.male$pval.fixed))

female <- results.fertility[sex == 2 & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC"),c("var.beta","var.stderr","y.var","variant.type","n.indvs","var.p")]
female[,age:="ALL"]
meta.analy.female <- metagen(var.beta,
                          var.stderr,
                          studlab = variant.type,
                          method.tau = "SJ",
                          sm = "OR",
                          data = female)

female <- bind_rows(female,data.table(var.beta = meta.analy.female$TE.fixed,var.stderr = meta.analy.female$seTE.fixed,y.var = "live.births",variant.type = "META",age = "ALL",n.indvs=female[,sum(n.indvs)],var.p=meta.analy.female$pval.fixed))

res.age <- bind_rows(res.age,female,male)

res.age[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
res.age[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
res.age[,var.beta:=exp(var.beta)]

ggplot(res.age, aes(age, var.beta, colour=variant.type, shape = y.var, group = interaction(variant.type,y.var))) + geom_point(position = position_dodge(0.5)) + geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),width=0.5,position = position_dodge(0.5)) + coord_flip() + xlab("Age") + ylab("Odds Ratio") + theme.legend

rm(male, female, meta.analy.female, meta.analy.male, age.remove)
```

## 5D. Partner at Home

### Main Regression

```{r Partner LM, fig.height=7, fig.width=8}
results.partner <- data.table(crossing(maf = c(0.001,0), 
                                   gene.list = "product_sHET",
                                   y.var = "partner.in.house",
                                   sex = c(1,2),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.partner[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.partner)]

plot.result(results.partner,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

## 5E. Cognition

### Main Regression

This code actually tests just overall effect on cognition if using my filter.

```{r Cognition Linear Regression, fig.height=7, fig.width=8}
## 0 is just my way of saying I only want singleton variants. I have code in the above function which handles it
results.cog <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = "fluid.intel",
                                   sex = c(1,2,3),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.cog[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,F),by=1:nrow(results.cog)]

plot.result(results.cog,F,20,-1.4,0.5,"# of Individuals\nWith sHET\n> 0.15")
```

## 5F. Educational Attainment

### Main Regression

```{r Educational Attainment, fig.height=7, fig.width=8}
results.ea <- data.table(crossing(maf = c(0.001,0), 
                                  gene.list = "product_sHET",
                                  y.var = "completed.college",
                                  sex = c(1,2),
                                  variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.ea[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.ea)]

plot.result(results.ea,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

## 5G. Mental Health and ICD10

### Fertility Ratios

Here attempting to replicate the result from [Power et al](https://jamanetwork.com/journals/jamapsychiatry/article-abstract/1390257) which identified differential fertility rates among carriers/non carriers.

```{r Fertility Ratios, fig.height=8, fig.width=10}

fertility.ratios <- data.table(crossing(phenotype=gsub("icd.","",names(UKBB.phenotype.data)[grep("icd",names(UKBB.phenotype.data))]),
                                        sex=c(1,2),
                                        data.source=c("mhq","icd")))

calc.mean.fertility <- function(sex, phenotype, data.source) {
  
  if (phenotype == "infertility" & (sex == 2 | data.source == "mhq")) {
    return(list(1.0,1.0,1L,1.0,1.0,1L,1.0,0.0,0.0,1.0))
  } else {
    col <- paste(data.source,phenotype,sep=".") 
    if (sex == 1) {
      relevant.fertility <- "children.fathered"
    } else {
      relevant.fertility <- "live.births"
    }
    
    cols <- c(relevant.fertility,col,"agePulse","agePulse.squared","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")
    table.to.use <- UKBB.phenotype.data[sexPulse == sex &!is.na(get(col)) & !is.na(get(relevant.fertility)),..cols]
    
    covariates <- c("PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10","agePulse.squared","agePulse")
    
    cov.string <- paste(covariates, collapse=" + ")
    formated.formula <- as.formula(paste(relevant.fertility, cov.string,sep=" ~ "))
  
    test.lm <- glm(formated.formula, data=table.to.use, family="gaussian")
    resid.test <- augment(test.lm) %>% data.table()
    resid.test[,eval(col):=table.to.use[,get(col)]]
    setnames(resid.test,".fitted","fitted")
    resid.test[,corrected:=`.resid` - min(resid.test[,`.resid`])]
    formated.formula <- as.formula(paste("corrected",paste0("as.factor(",col,")"),sep=" ~ "))
    ratio.test <- ttestratio(formated.formula,data=resid.test,base=1)
  
    res <- table.to.use[,list(mean(get(relevant.fertility),na.rm=T),sd(get(relevant.fertility),na.rm=T)),by=col]
    return(list(res[get(col)==0,V1],
                res[get(col)==0,V2],
                nrow(UKBB.phenotype.data[sexPulse==sex & get(col) == 0]),
                res[get(col)==1,V1],
                res[get(col)==1,V1],
                nrow(UKBB.phenotype.data[sexPulse==sex & get(col) == 1]),
                ratio.test$estimate[3],
                ratio.test$conf.int[1],
                ratio.test$conf.int[2],
                ratio.test$p.value))
  }
}

fertility.ratios[,c("mean.children.unaffected","sd.children.unaffected","n.unaffected","mean.children.affected","sd.children.affected","n.affected","ratio","ci.lower","ci.upper","p.val"):=calc.mean.fertility(sex,phenotype,data.source),by=1:nrow(fertility.ratios)]

fertility.ratios[,sex:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]
test <- copy(fertility.ratios)
## Set Arrows!
test[,ci.lower.symbol:=if_else(ci.lower<0,25,NaN)]
test[,ci.lower:=if_else(ci.lower<0,0,ci.lower)]
test[,ci.upper.symbol:=if_else(ci.upper>1.4,24,NaN)]
test[,ci.upper:=if_else(ci.upper>1.4,1.4,ci.upper)]

test[,sig:=if_else(p.val <= 0.05/28, "*", "")]
test[,sig.pos:=if_else(ratio<1,ci.lower-0.03,ci.upper+0.03)]

test[,ratio:=if_else(phenotype == "infertility" & (sex == "Female" | data.source == "mhq"), NaN, ratio)]

mhq <- ggplot(test[data.source=="mhq"],aes(phenotype,ratio,group=sex,colour=sex)) +
  geom_point(position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymin=ci.lower,ymax=ci.upper),position=position_dodge(width=0.5),width=0.1) +    
  geom_text(aes(y=sig.pos,label=sig),position=position_dodge(width=0.8),size=5) +
  ylim(0,1.4) +
  geom_point(aes(y=ci.lower,shape=ci.lower.symbol,fill=sex),position=position_dodge(width=0.5)) +
  geom_point(aes(y=ci.upper,shape=ci.upper.symbol,fill=sex),position=position_dodge(width=0.5)) +
  scale_shape_identity() +
  theme.legend +
  ggtitle("MHQ") +
  coord_flip()

icd <- ggplot(test[data.source=="icd" & (phenotype == "scizo" | phenotype == "asd" | phenotype == "bipolar" | phenotype == "depression" | phenotype == "eating_disorders" | phenotype == "substance")],aes(phenotype,ratio,group=sex, colour=sex)) +
  geom_point(position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymin=ci.lower,ymax=ci.upper),position=position_dodge(width=0.5),width=0.1) +
  ylim(0,1.4) +
  geom_text(aes(y=sig.pos,label=sig),position=position_dodge(width=0.8),size=5) +
  theme.legend +
  geom_point(aes(y=ci.lower,shape=ci.lower.symbol,fill=sex),position=position_dodge(width=0.5)) +
  geom_point(aes(y=ci.upper,shape=ci.upper.symbol,fill=sex),position=position_dodge(width=0.5)) +
  scale_shape_identity() +
  ggtitle("ICD10") +
  # coord_flip() +
  scale_x_discrete(name = "")
  # theme(axis.text.y=element_blank())

mhq + icd + plot_layout(guides = "collect")

rm(mhq,icd)
```

### Main Regressions

Conclusions from above are that the ICD-10 data is too sparse for us to be able to use it truly effectively. Also confirmed is that, in general, it also looks like the UKBB is healthier than the population as a whole (at least when comparing to Power et al.), which is a fairly obvious conclusion. With that in mind, we think we can only really do two different regressions:

* Binary of do you have a disability that has been previously shown to be associated with [rare variant burden](https://www.sciencedirect.com/science/article/pii/S0002929718301630)?:
** Schizophrenia, Autism, ADHD, Bipolar
** Also have ID/DD, but we don't have that here...
* Binary of do you have a disability that Power et al has shown to have <0.8 drop in fertility for either gender?:
** Schizophrenia, Autism, bipolar disorder, eating disorders

For the purposes of this manuscript, we have gone for the former, although both have similar results. This code block adds a binary value for having any of those phenotypes ('ganna.binary') to our primary phenotype table.

```{r MHQ regression, fig.height=7, fig.width=8}

## Calculate the two binaries listed above:
UKBB.phenotype.data[,ganna.binary:=if_else(icd.scizo == 1 | icd.bipolar == 1 | icd.asd == 1 | icd.add == 1, 1, 0)]

results.mhq <- data.table(crossing(maf = c(0.001,0),
                                  gene.list = "product_sHET",
                                  y.var = c("ganna.binary"),
                                  sex = c(1,2),
                                  variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.mhq[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.mhq)]

plot.result(results.mhq,T,20,0,10,"# of Individuals\nWith sHET\n> 0.15")
```

### Additional Analyses

### Exploring Issues with MHQ Data

#### Only test non-carriers

See if we just remove MH patients from our model, do we still have an effect?

```{r Remove MH Patients, fig.height=7, fig.width=8}

mht.remove <- UKBB.phenotype.data[mhq.scizo == 1 | mhq.bipolar == 1 | mhq.asd == 1 | mhq.add == 1 | icd.scizo == 1 | icd.bipolar == 1 | icd.asd == 1 | icd.add == 1,eid]

## Kind of have to do this in a weird way so that I don't have to change my function massively
variant.counts.backup <- copy(variant.counts)
variant.counts <- variant.counts[!sample_id %in% mht.remove]


results.fertility.no.mhq <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = c("children.fathered","live.births"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))
results.fertility.no.mhq[,sex:=if_else(y.var=="children.fathered",1,2)]

results.fertility.no.mhq[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.fertility.no.mhq)]

plot.result(results.fertility.no.mhq,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")

## Restore the original file and delete the backup:
variant.counts <- copy(variant.counts.backup)
rm(variant.counts.backup)
```

#### Did Or Did Not Answer the MHQ

```{r fig.height=7, fig.width=8}

results.answered.mhq <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = c("mhq.answered_mhq"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS"),
                                   sex = c(1,2)))

results.answered.mhq[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.answered.mhq)]

plot.result(results.answered.mhq,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

#### Has an email

```{r fig.height=8, fig.width=7}

results.email <- data.table(crossing(maf = c(0.001,0),
                                   gene.list = "product_sHET",
                                   y.var = c("has.email"),
                                   variant.type = c("DEL","DUP","LOF_HC","SYN","MIS"),
                                   sex = c(1,2)))

results.email[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.email)]

plot.result(results.email,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

## 5H. Household Income

### Main Regression

```{r household income, fig.height=7, fig.width=8}

## First do our standard linear model:
results.household.income <- data.table(crossing(maf = c(0.001,0),
                                        gene.list = "product_sHET",
                                        y.var = c("household.income"),
                                        sex = c(1,2),
                                        variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.household.income[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,F,add.covars = c("partner.in.house")),by=1:nrow(results.household.income)]

plot.result(results.household.income,F,20,-1.5,0.5,"# of Individuals\nWith sHET\n> 0.15")
```


## 5I. Same Sex Sexual Behaviour

### Main Regression

```{r same sex, fig.height=7, fig.width=8}

## First do our standard linear model:
results.same.sex <- data.table(crossing(maf = c(0.001,0),
                                        gene.list = "product_sHET",
                                        y.var = c("same.sex"),
                                        sex = c(1,2),
                                        variant.type = c("DEL","DUP","LOF_HC","SYN","MIS")))

results.same.sex[,c("var.beta","var.stderr","var.p","n.var","n.indvs"):=run.regression(maf,gene.list,y.var,sex,variant.type,T),by=1:nrow(results.same.sex)]

plot.result(results.same.sex,T,20,0,1.4,"# of Individuals\nWith sHET\n> 0.15")
```

# 6. Modulation of Traits by Variant Burden

This section of code is what was used to estimate the contribution of each of our measured traits to overall childlessness and fitness. We first determine the contribution of [Fertility Alone](#6c._fertility_alone) and then do the same for other traits except for household income (due to issues with how the trait was recorded).

Each section other than the first 4 include a subheading:

1. For estimating the effect of a trait on childlessness alone through a general linear model.
2. For estimating the effect of a trait on childlessness and overall fitness

*Note*: All plotting of estimated fitness is done when actually generating [Figures](#7._figures).

## 6A. Function for Testing Simple Regressions Via GLM

This section is used for all traits to address the simple regression of:

$ childlessness \sim phenotype+age+age^2+PC1..PC10 $

There is a flag in the function for excluding PCs. This is so that we can use the models generated by the function to estimate the contribution of phenotype to childlessness when we cannot simulate PCs due to too much complexity. All ORs/Effect sizes reported on the manuscript for the effect of a trait on childlessness include PCs and are calculated when creating the Supplementary Figure in which they are reported.

This will also return a 'fit model' for the expected trait that we can then feed into our simulations.

```{r simple lm}

run.lm <- function(sex, x.var, add.covars=c(), inc.PCs = F) {

  if (sex == 1) {
    y.var <- "children.fathered"
  } else {
    y.var <- "live.births"
  }
  
  phenotypes <- UKBB.phenotype.data[sexPulse == sex & !is.na(get(y.var)) & !is.na(get(x.var))]
  
  ## Make sure none of our additional covariates are NA
  for (cov in add.covars) {
    if(grepl("\\*",cov) == F) {
      phenotypes <- phenotypes[!is.na(get(cov))]
    }
  }
  
  phenotypes[,binary.stat:=if_else(get(y.var) > 0,1,0)]
  
  covariates <- c(x.var,"agePulse.squared","agePulse",add.covars)
  if (inc.PCs == T) {
    covariates <- c(covariates,"PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")
  }
  cov.string <- paste(covariates, collapse=" + ")
  form <- as.formula(paste("binary.stat", cov.string,sep=" ~ "))

  test.lm <- glm(form, data=phenotypes[sexPulse == sex], family = "binomial")
  coef.lm <- tidy(test.lm) %>% data.table()
  resid.table <- augment(test.lm) %>% data.table()
  resid.table[,sexPulse:=sex]
  
  cols <- c(".resid",x.var,"sexPulse",add.covars[-grep("\\*",add.covars)])
  
  return(list(coef.lm[term==eval(x.var),estimate],
              coef.lm[term==eval(x.var),std.error],
              coef.lm[term==eval(x.var),p.value],
              list(resid.table[,..cols]),
              list(test.lm)))
  
}

```

## 6B. Calculating Base Fertility Statistics for UKBB Participants

This code just generates base-level statistics for individuals in the UK Biobank. It also includes some functions for calculating the expected number of individuals with a given trait at a specified odd ratio.

```{r Base Stats}

## Build an object of all base fertilities for Male and Female:
# 1. Base fertility only for individuals with children:
base.fertilities <- data.table(fertility = UKBB.phenotype.data[sexPulse == 1 & eid %in% variant.counts[,sample_id] & children.fathered > 0,mean(children.fathered)],inc.zero = F, sex = 1)
base.fertilities <- bind_rows(base.fertilities, data.table(fertility = UKBB.phenotype.data[sexPulse == 2 & eid %in% variant.counts[,sample_id] & live.births > 0,mean(live.births)],inc.zero = F, sex = 2))

# 2. Base fertility including all individuals:
base.fertilities <- bind_rows(base.fertilities, data.table(fertility = UKBB.phenotype.data[sexPulse == 1 & eid %in% variant.counts[,sample_id] & children.fathered >= 0,mean(children.fathered)], inc.zero = T, sex = 1))
base.fertilities <- bind_rows(base.fertilities, data.table(fertility = UKBB.phenotype.data[sexPulse == 2 & eid %in% variant.counts[,sample_id] & live.births >= 0,mean(live.births)], inc.zero = T, sex = 2))

## Base childlessness for all UKBB Participants
base.childlessness.male <- nrow(UKBB.phenotype.data[sexPulse == 1 & eid %in% variant.counts[,sample_id] & children.fathered == 0])/nrow(UKBB.phenotype.data[sexPulse == 1 & eid %in% variant.counts[,sample_id] & children.fathered >= 0])
base.childlessness.female <- nrow(UKBB.phenotype.data[sexPulse == 2 & eid %in% variant.counts[,sample_id] & live.births == 0])/nrow(UKBB.phenotype.data[sexPulse == 2 & eid %in% variant.counts[,sample_id] & live.births >= 0])

paste0("Base Childlessness Male             : ", sprintf("%0.1f",base.childlessness.male*100))
paste0("Base Childlessness Female           : ", sprintf("%0.1f",base.childlessness.female*100))

paste0("Base Children Among Males w/Child   : ", sprintf("%0.2f",base.fertilities[sex == 1 & inc.zero == F,fertility]))
paste0("Base Children Among Females w/Child : ", sprintf("%0.2f",base.fertilities[sex == 2 & inc.zero == F,fertility]))

paste0("Base Children Among Males          : ", sprintf("%0.2f",base.fertilities[sex == 1 & inc.zero == T,fertility]))
paste0("Base Children Among Females        : ", sprintf("%0.2f",base.fertilities[sex == 2 & inc.zero == T,fertility]))


## Array of ages to sample from:
ages <- UKBB.phenotype.data[eid %in% variant.counts[,sample_id], agePulse]

## Helper Functions:
calc.prop.indvs <- function(odds.ratio, healthy.ratio) {
  
  healthy.ratio / (odds.ratio + healthy.ratio)
  
}

simulate.proportion <- function(expected) {
  if (expected>=1) {
    return(0L)
  } else {
    return(rbinom(1,1,1-expected))
  }
}

```

## 6C. Fertility Alone

Here we estimate just the effect of s~het~ on childlessness and, through that estimate, overall fitness.

```{r Fertility Alone, fig.height=4, fig.width=12}

model.fertility <- data.table()

for (s in c(1,2)) {
  
  ## Get meta-anlysis OR from the original fertility LM that was calculated above in section 5C.
  meta.analy <- metagen(var.beta,
                        var.stderr,
                        studlab = variant.type,
                        method.tau = "SJ",
                        sm = "OR",
                        data = results.fertility[sex == s & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC")])
  
  ## Get actual proportion of individuals without a partner from 
  ## our data generated above
  if (s == 1) {
    stat <- "children.fathered"
    prop.affected <- base.childlessness.male
  } else {
    stat <- "live.births"
    prop.affected <- base.childlessness.female
  }
  
  ## This is just a constant denominator when calculating expected 
  ## childlessness via the function calc.prop.indvs()
  aff <- prop.affected/(1-prop.affected)
  
  ## Determine expected proportions of childlessness at various shet 
  ## values based on meta-analysis OR
  for (modifier in seq(0,1,by=0.1)) {
  
    ## Calculate value for the actual OR, as well as upper and lower confidence intervals
    for (place in c("mid","lower","upper")) {
      
      ## Just modifies the actual OR (actual or upper/lower CI) that 
      ## will be used to get expected proportion of childlessness
      if (place == "mid") {
        or <- exp(meta.analy$TE.fixed*modifier)
      } else if (place == "upper") {
        or <- exp((meta.analy$TE.fixed + (1.96*(meta.analy$seTE.fixed))) * modifier)
      } else if (place == "lower") {
        or <- exp((meta.analy$TE.fixed - (1.96*(meta.analy$seTE.fixed))) * modifier)
      }
      
      ## Get proportion of individuals that are childless based off the OR
      prop.shet <- calc.prop.indvs(or, aff)
      
      ## Simulate 100k 'individuals' with childlessness randomized by our calculated proportion above
      sim.indv <- data.table(id = c(1:100000),shet=modifier, sex = s)
      sim.indv[,children.binary:=simulate.proportion(prop.shet),by=1:nrow(sim.indv)]
      
      ## Assign number of children based off of expected base fertilities
      ## We know that individuals w/o children are 0 and individuals with children do
      ## not deviate from the population mean (see subsection in Fertility - Only Individuals With >0 Children)
      sim.indv[,num.children:=if_else(children.binary==1,
                                if_else(sex == 1,
                                        base.fertilities[sex == 1 & inc.zero == F, fertility],
                                        base.fertilities[sex == 2 & inc.zero == F, fertility]),0)]
      
      ## Grab a mean fertility value to calculate a fertility ratio from
      if (s == 1) {
        to.use.ratio <- base.fertilities[sex == 1 & inc.zero == T, fertility]
      } else {
        to.use.ratio <- base.fertilities[sex == 2 & inc.zero == T, fertility]
      }
      
      model.fertility <- bind_rows(model.fertility,
                                   data.table(shet = modifier, 
                                              sex = s, 
                                              error = place, 
                                              mean.childlessness = sim.indv[,mean(children.binary)],
                                              mean.children = sim.indv[,mean(num.children)], 
                                              ratio = sim.indv[,mean(num.children)] / to.use.ratio))
    
    }
  
  }
    
}

model.fertility[,mean.childlessness:=1-mean.childlessness]

model.fertility <- data.table(pivot_wider(model.fertility, names_from = error, values_from = c(mean.childlessness,mean.children,ratio)))

model.fertility[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

paste0("Contribution of sHET to Fitness (sex averaged): ",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_mid)])*100)),
       " (",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_upper)])*100)),
       " - ",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_lower)])*100)),
       ")")
```

## 6D. Function to Calculate Increased Childlessness Due to Partner at Home/EA

Partner at Home and Educational Attainment use a similar methodology to get estimates of fitness. As such, I wrote a single function to handle the calculation.

```{r Increased Childlessness}

## Helper function to generate a given trait and age for a 'simulated' 
## individual given a probability of having that trait. 

simulate.scores <- function(prob) {
        
  age <- sample(ages, 1)
  
  ## I do the inverse here because that's what the simulate.proportion function expects
  has.trait <- simulate.proportion(prob)
  
  return(list(age, has.trait))
  
}

calc.childlessness <- function(glm.result, y.var.result, y.var) {
  
  ## Datatable for return:
  model <- data.table()

  for (s in c(1,2)) {
  
    ## Get meta-anlysis OR from the original fertility LM that was calculated above section.
    meta.analy <- metagen(var.beta,
                          var.stderr,
                          studlab = variant.type,
                          method.tau = "SJ",
                          sm = "OR",
                          data = glm.result[sex == s & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC")])
    
    ## Get actual proportion of individuals without a partner from our data generated above
    if (s == 1) {
      stat <- "children.fathered"
      prop.affected <- base.childlessness.male
    } else {
      stat <- "live.births"
      prop.affected <- base.childlessness.female
    }
    
    ## This is just a constant denominator when calculating expected 
    ## childlessness via the function calc.prop.indvs()
    aff <- prop.affected/(1-prop.affected)
    
    ## Determine expected proportions of childlessness at various shet
    ## values based on meta-analysis OR
    for (modifier in seq(0,1,by=0.1)) {
      
      ## Calculate value for the actual OR, as well as upper and 
      ## lower confidence intervals
      for (place in c("mid","lower","upper")) {
    
        ## Just modifies the actual OR (actual or upper/lower CI) that will
        ## be used to get expected proportion of childlessness
        if (place == "mid") {
          or <- exp(meta.analy$TE.fixed*modifier)
        } else if (place == "upper") {
          or <- exp((meta.analy$TE.fixed + (1.96*(meta.analy$seTE.fixed))) * modifier)
        } else if (place == "lower") {
          or <- exp((meta.analy$TE.fixed - (1.96*(meta.analy$seTE.fixed))) * modifier)
        }
      
        ## Determine expected proportions at various shet values based on meta-analysis OR
        prop.shet <- calc.prop.indvs(or, aff)
        model.sim <- data.table(val = prop.shet, shet = modifier, sex = s, error = place)
      
        ## Determine the increased proportion of individuals without children due to shet
        sim.indv <- data.table(id = c(1:100000),shet=modifier, sex = s)
        
        ## Note to self -- I HAVE NO IDEA why I have to use as.character here. Something broken in data.table
        sim.indv[,c("agePulse",eval(y.var)):=simulate.scores(prop.shet),by=1:nrow(sim.indv)]
        sim.indv[,agePulse.squared:=agePulse^2]
        
        ## This pulls in the model from the "Linear Model" section for each trait and uses
        ## it to predict childlessness given our simulations.
        var.model <- y.var.result[sex == s, model][[1]]
        sim.indv[,prob.child:=predict(var.model, sim.indv,type="response")]
        
        ## Simulate an individuals 'childlessness' from our expected probability
        sim.indv[,children.binary:=simulate.proportion(1-prob.child),by=1:nrow(sim.indv)]
        
        ## Assign number of children based off of expected base fertilities
        ## We know that individuals w/o children are 0 and individuals with children do
        ## not deviate from the population mean (see subsection in Fertility - Only Individuals With >0 Children)
        sim.indv[,num.children:=if_else(children.binary==1,
                                        if_else(sex == 1,
                                                base.fertilities[sex == 1 & inc.zero == F, fertility],
                                                base.fertilities[sex == 2 & inc.zero == F, fertility]),0)]
        
        model.sim[,mean.childlessness:=1-sim.indv[,mean(children.binary)]]
        model.sim[,mean.children:=sim.indv[,mean(num.children)]]
        model.sim[,ratio:=mean.children/base.fertilities[sex == s & inc.zero == T, fertility]]
        model <- bind_rows(model, model.sim)
      }
      
    }
  
  }

  return(model)
  
}

```

## 6E. Fertility + Partner at Home

### Linear Model

```{r Partner Linear Model, fig.height=4, fig.width=7}

## Actual LM
sex.diff.partner <- data.table(sex=c(1,2))
sex.diff.partner[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"partner.in.house"),by=1:nrow(sex.diff.partner)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.partner[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.partner[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.partner[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.partner[,beta:=exp(beta)]
sex.diff.partner[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.partner, aes(sexPulse,beta,colour=sexPulse)) + 
  geom_point() + 
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(name="OR", limits=c(0.9,6)) + 
  sex.colours.colour + 
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- bind_rows(sex.diff.partner[1,data][[1]],sex.diff.partner[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("partner.in.house","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(partner.in.house),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Partner In Home",labels=c("False","True")) +
  sex.colours.colour +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
```

### Effect on Childlessness

This code uses the function from [above](#6d._function_to_calculate_increased_childlessness_due_to_partner_at_home/ea). See that code for how this section works.

```{r Partner Childlessness}

model.partner <- calc.childlessness(results.partner, sex.diff.partner, "partner.in.house")
model.partner[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]
setnames(model.partner, "val", "expected.without.partner")

model.partner <- data.table(pivot_wider(model.partner, 
                                        names_from = error, 
                                        values_from = c(expected.without.partner, 
                                                        ratio, 
                                                        mean.childlessness, 
                                                        mean.children)))

paste0("Contribution of Partner at Home to Fitness: ",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       " (",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       ")")
```

## 6F. Fertility + Educational Attainment

### Linear Model

```{r EA Linear Model}

## Actual LM
sex.diff.ea <- data.table(sex=c(1,2))
sex.diff.ea[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"completed.college"),by=1:nrow(sex.diff.ea)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.ea[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.ea[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.ea[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.ea[,beta:=exp(beta)]
sex.diff.ea[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.ea, aes(sexPulse,beta,colour=sexPulse)) + 
  geom_point() + 
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(limits=c(-0.1,1)) + 
  scale_y_continuous(name="OR") + 
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- bind_rows(sex.diff.ea[1,data][[1]],sex.diff.ea[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("completed.college","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(completed.college),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Completed College",labels=c("False","True")) +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
```

### Effect on Childlessness

This code uses the function from [above](#6d._function_to_calculate_increased_childlessness_due_to_partner_at_home/ea). See that code for how this section works.

```{r EA Childlessness}

model.ea <- calc.childlessness(results.ea, sex.diff.ea, "completed.college")
model.ea[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]
setnames(model.ea, "val", "expected.did.not.complete.college")
model.ea[,expected.completed.college:=1-expected.did.not.complete.college]

model.ea <- data.table(pivot_wider(model.ea, 
                                   names_from = error, 
                                   values_from = c(expected.completed.college, ratio, mean.childlessness, mean.children,expected.did.not.complete.college)))
```

## 6G. Fertility + Fluid Intelligence

### Linear Model

Testing the interaction of cognition and fertility via a glm of $Fertility \sim Fluid.Intel + control.covars$

```{r FI Linear Model, fig.height=4, fig.width=10}

## Actual LM
sex.diff.fluidintel <- data.table(sex=c(1,2))
sex.diff.fluidintel[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"fluid.intel"),by=1:nrow(sex.diff.fluidintel)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.fluidintel[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.fluidintel[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.fluidintel[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.fluidintel[,beta:=exp(beta)]
sex.diff.fluidintel[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.fluidintel, aes(sexPulse,beta,colour=sexPulse)) +
  geom_point() + 
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- bind_rows(sex.diff.fluidintel[1,data][[1]],sex.diff.fluidintel[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,fluid.intel.binned:=cut(fluid.intel,breaks=14)]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("fluid.intel.binned","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(fluid.intel.binned,mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Fluid Intel Score",labels = c(0:29)) +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
```

### Effect on Childlessness

This section uses paired IQ and fertility data from the Swedish birth cohort presented in the study.

#### Load Data and Fit Expected Models

We first load data for both:

1. IQ vs Mean Children: `rawdata/cognitive_data/cognitive_data_raw.txt`
2. IQ vs Increased Childlessness: `rawdata/cognitive_data/cognitive_childlessness_data_raw.txt`

The data that is loaded is identical to that which is presented in the Supplementary Materials of the manuscript. I have simply provided raw data files at the above locations.

##### IQ and Mean Children

```{r Fit Mean Children Data}

## Need to generate a fit for the model -- first load data and correct some errors
cog.raw <- fread("rawdata/cognitive_data/cognitive_data_raw.txt")
cog.raw[,Obs:=as.integer(str_replace(Obs,",",""))]
cog.raw[,SD:=as.numeric(SD)]

## This basically takes a set of input "estimated" parameters that are reasonably close by eye and generates a set of optimized parameters for a sigmoid curve
fit.log <- nls(Mean ~ a/(1 + exp(-b * (newiq - c))), start = list(a = 1.6, b = 0.15, c = 70), data = cog.raw[newiq <= 120])

## Generate a table to predict on that also contains actual data:
cog.raw <- bind_rows(data.table(newiq = c(1:62),Obs=NA,Mean=NA,SD=NA,Min=NA,Max=NA),cog.raw,data.table(newiq = c(140:200),Obs=NA,Mean=NA,SD=NA,Min=NA,Max=NA))
cog.raw[,pred.log:=predict(fit.log,cog.raw)]
cog.raw[,ci:=(SD/sqrt(Obs))*1.96]

## Generate quick plots of actual data:
ggplot(cog.raw,aes(newiq, Mean), colour="blue") +
  geom_line(colour="blue") +
  geom_ribbon(aes(ymin=Mean-ci,ymax=Mean+ci),colour="grey",alpha=0.5) +
  scale_alpha_continuous(range=c(0,1)) +
  scale_x_continuous(name = "IQ", limits=c(0,140)) +
  scale_y_continuous(name = "Average Children", limits=c(-0.1,2)) +
  theme

## The fitted model
ggplot(cog.raw) + 
  geom_line(data = cog.raw[newiq<120],aes(x=newiq, y=Mean),colour="blue") +
  geom_line(aes(x = newiq, y=pred.log),colour="green") +
  scale_x_continuous(name = "IQ", limits=c(0,140)) +
  scale_y_continuous(name = "Average Children", limits=c(-0.1,2)) +
  theme

## The IQ Distribution
ggplot(cog.raw,aes(newiq, Obs)) +
  geom_col() +
  theme

## Generate mean/sd from the actual distributions of Swedish IQ data and UKBB Fluid Intel for Males
iq.table <- data.table(iq = cog.raw[!is.na(newiq) & !is.na(Obs),rep(newiq, Obs)])
mean.cog <- iq.table[,mean(iq)]
sd.cog <- iq.table[,sd(iq)]

mean.fi <- UKBB.phenotype.data[sexPulse == 1 & !is.na(fluid.intel), mean(fluid.intel)]
sd.fi <- UKBB.phenotype.data[sexPulse == 1 & !is.na(fluid.intel), sd(fluid.intel)]

## Plot the FI/IQ distribution
fi.table <- UKBB.phenotype.data[sexPulse == 1 & !is.na(fluid.intel),c("fluid.intel")]
fi.table[,fi.cut:=cut(fluid.intel,breaks = c(seq(mean.fi-(sd.fi*4),mean.fi-(sd.fi*1),by=sd.fi),seq(mean.fi+(sd.fi*1),mean.fi+(sd.fi*4),by=sd.fi)))]
fi.table[,dummy:=1]
means <- fi.table[,sum(dummy)/nrow(fi.table),by=fi.cut]

ggplot(means, aes(fi.cut,V1)) + 
  geom_col() + 
  xlab("Fluid Intel Bin") + 
  ylab("Proportion of Individuals") + 
  theme

iq.table[,iq.cut:=cut(iq,breaks = c(seq(mean.cog-(sd.cog*4),mean.cog-(sd.cog*1),by=sd.cog),seq(mean.cog+(sd.cog*1),mean.cog+(sd.cog*4),by=sd.cog)))]
iq.table[,dummy:=1]
means <- iq.table[,sum(dummy)/nrow(iq.table),by=iq.cut]

ggplot(means, aes(iq.cut,V1)) + 
  geom_col() + 
  xlab("IQ Bin") + 
  ylab("Proportion of Individuals") + 
  theme

paste0("Mean IQ, Swedish Data: ", sprintf("%0.0f", mean.cog))
paste0("SD   IQ, Swedish Data: ", sprintf("%0.0f", sd.cog))
```

##### IQ and Childlessness

*Note*: The data provided in this section indicate _increased_ childlessness, where the baseline is at IQ = 100. All values are thus ± from the childlessness at IQ 100, and we adjust for that when doing our estimates.

```{r Fit Childlessness Data}

## Read in initial data:
childless.raw <- fread("rawdata/cognitive_data/cognitive_childlessness_data_raw.txt")

## Plot actual distribution
ggplot(childless.raw,aes(iq,inc.childlessness)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=ci.lower,ymax=ci.upper),alpha = 0.5) + 
  theme

## What is actual childlessness?
childless.raw[,pred.childlessness:=inc.childlessness+base.childlessness.male]

## This basically takes a set of input "estimated" parameters that are reasonably close by eye and generates a set of optimized parameters for a sigmoid curve
## We have to invert the data so that it scales to 0 properly...
childless.raw[,inv.pred.childless:=(1 - (pred.childlessness))]
fit.log <- nls(inv.pred.childless ~ a/(1 + exp(-b * (iq - c))), start = list(a = 1.6, b = 0.15, c = 70), data = childless.raw[iq <= 120])
summary(fit.log)

## Generate a table to predict on that also contains actual data:
childless.raw <- bind_rows(data.table(iq = c(1:62),inc.childlessness=NA,`std. err.`=NA,t=NA,p.val=NA,ci.lower=NA,ci.upper=NA,inv.childless=NA,inv.pred.childless=NA,pred.childlessness=NA),childless.raw,data.table(iq = c(140:200),inc.childlessness=NA,`std. err.`=NA,t=NA,p.val=NA,ci.lower=NA,ci.upper=NA,inv.childless=NA,inv.pred.childless=NA,pred.childlessness=NA))

## Flip it back the same way again:
childless.raw[,pred.log:=predict(fit.log,childless.raw)]
childless.raw[,pred.log.inv:=(1-(pred.log))-base.childlessness.male]

## Plot fitted data
ggplot(childless.raw,aes(iq,inc.childlessness)) + 
  geom_line() + 
  geom_ribbon(aes(ymin=ci.lower,ymax=ci.upper),alpha = 0.5) + 
  geom_line(aes(iq,pred.log.inv),colour="blue") + 
  theme
```

#### Simulations

##### Helper Functions

First code block is just a set of helper functions to assist with simulating.

```{r FI Helper Functions}

## Simulate a set of individuals with reduced IQ and match their fertility scores
sim.cog <- function(effect.iq) {
  
  ## number to include in sample
  num.random<-100000 
  ## Use the mean and sd from our IQ distributions calculated above to simulate "healthy" individuals 
  IQ.sim <- data.table(norm.iq=round(rnorm(num.random, mean=mean.cog, sd=sd.cog)))
  
  ## Get 'drop' on IQ given effect.iq, where effect.iq 
  ## is the expected decrease in IQ given an sHET score.
  IQ.sim[,changed.iq:=round(norm.iq-effect.iq),by=1:nrow(IQ.sim)]
  
  ## This grabs the expected fertility at each IQ for both the healthy cohort and simulated sHET cohort
  IQ.sim <- merge(IQ.sim,cog.raw[,c("newiq","pred.log")],by.x="norm.iq",by.y="newiq")
  setnames(IQ.sim,"pred.log","norm.fertility")
  IQ.sim <- merge(IQ.sim,cog.raw[,c("newiq","pred.log")],by.x="changed.iq",by.y="newiq")
  setnames(IQ.sim,"pred.log","changed.fertility")
  
  ## And then just return the fertility ratio:
  return(IQ.sim[,mean(changed.fertility)/mean(norm.fertility)])

}

## Simulate a set of individuals with reduced IQ and decide if they are childless or not with random selection
## Function is very similar to above, but just for childlessness instead
sim.childlessness <- function(effect.iq, base.childlessness) {
  
  ## number to include in sample
  num.random<-100000
  ## Use the mean and sd from our IQ distributions calculated above to simulate "healthy" individuals 
  IQ.sim <- data.table(norm.iq=round(rnorm(num.random, mean=mean.cog, sd=sd.cog)))
  
  ## Get 'drop' on IQ given effect.iq, where effect.iq 
  ## is the expected decrease in IQ given an sHET score.  
  IQ.sim[,changed.iq:=round(norm.iq-effect.iq),by=1:nrow(IQ.sim)]
  IQ.sim <- merge(IQ.sim,childless.raw[,c("iq","pred.log.inv")],by.x="changed.iq",by.y="iq")
  setnames(IQ.sim,"pred.log.inv","changed.childlessness")
  
  ## This converts from an increase in childlessness to actual childlessness
  IQ.sim[,changed.childlessness:=changed.childlessness+base.childlessness]
  
  ## This removes VERY high IQ values that sometimes appear due to simulations
  IQ.sim <- na.omit(IQ.sim)
  
  ## Now simulate childlessness for each individual given changed childlessness
  IQ.sim[,has.child:=simulate.proportion(changed.childlessness),by=1:nrow(IQ.sim)]

  ## Return proportion of simulated childless individuals
  return(nrow(IQ.sim[has.child==0])/nrow(IQ.sim))

}

```

##### Actual Calculation

This section then does the actual simulations. This uses the formula: $\Delta_{IQ}= \beta_{fluid.intel} * \sigma_{IQ}$ to determine the expected change in IQ given an individuals expected drop in fluid intelligence as a function of s~het~.

```{r FI Childlessness}

## Datatable for return:
model.cog <- data.table()

for (s in c(1,2)) {

  ## Get meta-anlysis OR from the original fertility LM that was calculated above section.
  meta.analy <- metagen(var.beta,
                        var.stderr,
                        studlab = variant.type,
                        sm = "SMD",
                        prediction=T,
                        data = results.cog[sex == s & maf == 0 & (variant.type == "DEL" | variant.type == "LOF_HC")])
  
  ## Get actual proportion of individuals without a partner from our data generated above
  if (s == 1) {
    stat <- "children.fathered"
    prop.affected <- base.childlessness.male
  } else {
    stat <- "live.births"
    prop.affected <- base.childlessness.female
  }
  
  ## Determine expected proportions of childlessness at various shet
  ## values based on meta-analysis OR
  for (modifier in seq(0,1,by=0.1)) {
  
    ## Calculate value for the actual OR, as well as upper and 
    ## lower confidence intervals
    for (place in c("mid","lower","upper")) {
    
      ## Just modifies the actual OR (actual or upper/lower CI) that will
      ## be used to get expected proportion of childlessness
      if (place == "mid") {
        effect.fi <- meta.analy$TE.fixed*modifier
      } else if (place == "upper") {
        effect.fi <- (meta.analy$TE.fixed + (1.96 * meta.analy$seTE.fixed))*modifier
      } else if (place == "lower") {
        effect.fi <- (meta.analy$TE.fixed - (1.96 * meta.analy$seTE.fixed))*modifier
      }
    
      ## Uses the above function to determine a drop in IQ
      effect.iq <- abs(effect.fi * sd.cog)
      
      ## Uses above helper functions to determine simulated fertility/childlessness
      actual.effect.fert <- sim.cog(effect.iq)
      actual.effect.child <- sim.childlessness(effect.iq, prop.affected)
      
      ## Make a returnable data.table:
      model.cog <- bind_rows(model.cog,
                             data.table(val = effect.iq, 
                                        ratio = actual.effect.fert[[1]], 
                                        mean.childlessness = actual.effect.child, 
                                        shet = modifier, 
                                        sex = s, 
                                        error = place))
  
    }
      
  }

}

model.cog[,expected.iq:=mean.cog-val]
model.cog[,val:=NULL]

model.cog <- data.table(pivot_wider(model.cog, names_from = error, values_from = c(expected.iq, ratio, mean.childlessness)))

model.cog[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

paste0("Contribution of Cognition to Fitness: ",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       " (",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       ")")

paste0("Predicted drop in IQ for sHET = 1 male: " ,sprintf("%0.2f", model.cog[shet == 1 & sex == 1,100 - expected.iq_mid]))
```

## 6G. Fertility + Mental Health

### Linear Model

```{r MH Linear Model}

## Actual LM
sex.diff.mhq <- data.table(sex=c(1,2))
sex.diff.mhq[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"ganna.binary"),by=1:nrow(sex.diff.mhq)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.mhq[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.mhq[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.mhq[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.mhq[,beta:=exp(beta)]
sex.diff.mhq[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.mhq, aes(sexPulse,beta,colour=sexPulse)) + 
  geom_point() + 
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(name="Beta",limits=c(-0.1,1)) + 
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- bind_rows(sex.diff.mhq[1,data][[1]],sex.diff.mhq[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("ganna.binary","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(ganna.binary),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Has Power et al. Disorder",labels=c("False","True")) +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
```

### Effect on Childlessness

As described in the methods, we are using ORs extracted from [Ganna et al.](https://doi.org/10.1016/j.ajhg.2018.05.002) for three MH traits that have an association with rare variant burden, and fertility statistics for those same MH traits from [Power et al.](https://doi.org/10.1001/jamapsychiatry.2013.268). We provide tabulated forms of this data with the Supplementary Materials of the manuscript.

This calculation uses the function $OR_{s_{het}[x,t]}=\frac{log(OR_{ganna}) *s_{het}[x]} {0.1618034}$ to convert from an OR of one additional high pLI (≥ 0.9) gene. The calculation for a 'high pLI' gene is given below.

```{r MH Childlessness}

## Get mean high pLI
mean.highpLI <- merge(pli.genes,shet.genes)[pLI.val>=0.9,mean(sHET.val)]
print(paste0("high pLI genes (≥ 0.9) have a mean sHET value of : ",sprintf("%0.3f",mean.highpLI)))

## These are tabulated values that were extracted from either Ganna et al or Power et al.
modeling <- data.table(or = rep(c(1.4,1.3,1.25),2),
                       or.upper = rep(c(1.5,1.4,1.35),2),
                       n.indv = rep(c(2947,18890,14439),2),
                       sex.ratio = c(2/(2+1),1.5/(1.5+1),1/(1+1.5),1/(2+1),1/(1.5+1),1.5/(1+1.5)),
                       ratio = c(0.25,0.23,0.75,0.48,0.47,0.85),
                       trait = rep(c("asd","scizo","bipolar"),2),
                       sex = c(rep(1,3),rep(2,3)))

## Power et al. lists 1.76 as the mean number of children per person, 
## for which we can extrapolate the mean number of children for each trait
modeling[,mean.children:=1.76*ratio]
modeling[,incidence:=(sex.ratio*n.indv)/1178299]
modeling[,healthy.ratio:=(incidence/(1-incidence))]

## This is to make arbitrarily even CIs (why don't they provide their point estimates!!!)
modeling[,or.lower:=exp((-1*log(or.upper/or)) + log(or))]

## Use this function to calculate the expected number of individuals with 
## a MH trait at a given sHET value
calc.prop.indvs.mhq <- function(odds.ratio, healthy.ratio) {
  
  x <- odds.ratio * healthy.ratio
  y <- x + 1
  x / y

}

## Datatable for return:
simulated.data <- data.table()

for (s in c(1,2)) {

  ## Determine expected proportions of childlessness at various shet
  ## values based on meta-analysis OR
  for (shet in seq(0,1,by=0.1)) {
  
    ## Just modifies the actual OR (actual or upper/lower CI) that will
    ## be used to get expected proportion of childlessness
    for (place in c("mid","lower","upper")) {
    
      sim <- data.table(indv=c(1:100000))
      
      for (disorder in unique(modeling[,trait])) {
        
        ## Median pLI shet value of a high pLI gene (0.144829) is hardcoded
        if (place == "mid") {
          or <- modeling[trait == disorder & sex == s,or]
        } else if (place == "upper") {
          or <- modeling[trait == disorder & sex == s,or.upper]
        } else if (place == "lower") {
          or <- modeling[trait == disorder & sex == s,or.lower]
        }
      
        ## This is the function that we use to convert from Ganna et al. ORs to sHET ORs.
        or <- (log(or) * shet)/mean.highpLI
        or <- exp(or)
        
        healthy.ratio <- modeling[trait == disorder & sex == s,healthy.ratio]
        children.affected <- modeling[trait == disorder & sex == s,ratio] * base.fertilities[sex == s & inc.zero == T, fertility]
        children.unaffected <- base.fertilities[sex == s & inc.zero == T, fertility]
        
        prop.shet <- calc.prop.indvs.mhq(or,healthy.ratio)
      
        val <- paste0("has.",disorder)
        sim[,eval(val):=simulate.proportion(1-prop.shet),by=1:nrow(sim)]
        
        sim[,eval(val):=if_else(get(val)==0,children.unaffected,children.affected)]
        
      }
      
      sim[,children:=min(has.asd,has.scizo,has.bipolar),by=1:nrow(sim)]
      sim[,shet:=shet]
      sim[,sex:=s]
      sim[,error:=place]
      
      simulated.data <- bind_rows(simulated.data, sim)
      
    }
  }
}

## This is a hack to convert the fertility for each trait (which is always below 1.7) into a binary does/does nothave trait
simulated.data[,has.disorder:=if_else(has.asd < 1.7 | has.scizo < 1.7 | has.bipolar < 1.7, 1, 0)]

## And then tabulate the actual proportion of individuals with _any_ disorder
means <- simulated.data[,list(mean(children),mean(has.disorder)),by=c("shet","sex","error")]
setnames(means, c("V1","V2"),c("mean.children","mean.has.disorder"))

## And then calculate a fertility ratio for each trait.
means[,ratio:=if_else(sex == 1,
                      mean.children/base.fertilities[sex==1 & inc.zero == T, fertility],
                      mean.children/base.fertilities[sex==2 & inc.zero == T, fertility])]

## And generate the final model data.table like for other traits
model.mhq <- data.table(pivot_wider(means, names_from = error, values_from = c(mean.children,ratio,mean.has.disorder)))
model.mhq[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## Adjust base fertility to 0 shet
base.fertility <- simulated.data[shet == 0,mean(children)]
simulated.data[,dummy:=1]

## The following data tables are used to plot incidence of each of the 
## MH traits we measure in the study
scizo.inc <- simulated.data[,sum(dummy),by=c("has.scizo","shet","error","sex")]
scizo.inc[,type:="scizo"]
scizo.inc[,has.disorder:=if_else(has.scizo<1.7,TRUE,FALSE)]
scizo.inc[,has.scizo:=NULL]

asd.inc <- simulated.data[,sum(dummy),by=c("has.asd","shet","error","sex")]
asd.inc[,type:="asd"]
asd.inc[,has.disorder:=if_else(has.asd<1.7,TRUE,FALSE)]
asd.inc[,has.asd:=NULL]

bipolar.inc <- simulated.data[,sum(dummy),by=c("has.bipolar","shet","error","sex")]
bipolar.inc[,type:="bipolar"]
bipolar.inc[,has.disorder:=if_else(has.bipolar<1.7,TRUE,FALSE)]
bipolar.inc[,has.bipolar:=NULL]

# And bind them all together...
inc.mht <- bind_rows(scizo.inc,asd.inc,bipolar.inc)
inc.mht <- inc.mht[has.disorder==TRUE]
inc.mht[,prop.affected:=V1/100000]
inc.mht[,V1:=NULL]
inc.mht[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]
inc.mht <- data.table(pivot_wider(inc.mht, names_from = error, values_from = prop.affected))

rm(scizo.inc, asd.inc, bipolar.inc)

paste0("Contribution of MHTs to Fitness: ",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       " (",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       ")")
```

## 6H. Fertility + Household Income

Remember, we don't fit HHI to expectations of childlessness/fitness, so no 'Effect on Childlessness' section.

### Linear Model

```{r HHI Linear Model, fig.height=5, fig.width=12}

## Actual LM
sex.diff.hhi <- data.table(sex=c(1,2))
sex.diff.hhi[,c("beta","std.error","p.val","data","model"):=run.lm(sex,"household.income",add.covars=c("partner.in.house","partner.in.house*household.income")),by=1:nrow(sex.diff.hhi)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.hhi[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.hhi[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.hhi[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.hhi[,beta:=exp(beta)]
sex.diff.hhi[,sexPulse:=factor(sex,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.hhi, aes(sexPulse,beta,colour=sexPulse)) +
  geom_point() +
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) +
  scale_y_continuous(limits=c(-0.1,1)) +
  scale_y_continuous(name="OR") +
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- bind_rows(sex.diff.hhi[1,data][[1]],sex.diff.hhi[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,household.income.binned:=cut(household.income,breaks=c(seq(0,5,by=1)))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("household.income.binned","sexPulse","partner.in.house")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(household.income.binned,mean,group=interaction(sexPulse,partner.in.house),colour=sexPulse,shape=as.factor(partner.in.house))) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Household Income Bin",labels = c(0:29)) +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
rm(mean.plot, beta.plot)
```

## 6I. Fertility + Same Sex Sexual Behaviour

We also don't estimate increased/decreased childlessness for same sex sexual behaviour as there is no effect due to s~het~ burden.

### Linear Model

```{r Fertility + Same.Sex}

## Actual LM
sex.diff.same.sex <- data.table(sexPulse=c(1,2))
sex.diff.same.sex[,c("beta","std.error","p.val","data","model"):=run.lm(sexPulse,"same.sex"),by=1:nrow(sex.diff.same.sex)]

## Add CIs, factorize sex, get OR (from log odds ratio)
sex.diff.same.sex[,var.ci.upper:=exp(beta + (1.96*std.error))]
sex.diff.same.sex[,var.ci.lower:=exp(beta - (1.96*std.error))]
sex.diff.same.sex[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
sex.diff.same.sex[,beta:=exp(beta)]
sex.diff.same.sex[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]

## This is just a plot of the betas from the LM
beta.plot <- ggplot(sex.diff.same.sex, aes(sexPulse,beta,colour=sexPulse)) +
  geom_point() +
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper)) + 
  scale_y_continuous(limits=c(-0.1,1)) + 
  scale_y_continuous(name="OR") + 
  theme.legend

## This grabs the actual fit values from the LM to plot
post.lm.dt <- bind_rows(sex.diff.same.sex[1,data][[1]],sex.diff.same.sex[2,data][[1]])
post.lm.dt[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
post.lm.dt[,dummy:=1]

## Tabulate the means by sex
means <- post.lm.dt[,list(mean(`.resid`),sd(`.resid`),sum(dummy)),by=c("same.sex","sexPulse")]
setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
means[,ci:=(sd/sqrt(n))*1.96]

## Now plot the means by sex
mean.plot <- ggplot(means,aes(as.factor(same.sex),mean,group=sexPulse,colour=sexPulse)) +
  geom_point(position=position_dodge(0.5)) +
  geom_errorbar(aes(ymin=mean-ci,ymax=mean+ci),width=0,position=position_dodge(0.5)) +
  scale_y_continuous(name="Births Corrected For\nAge & PC1..10") +
  scale_x_discrete(name = "Has Had Same Sex Behaviour",labels=c("False","True")) +
  theme.legend

## Use patchwork to mash them together
(mean.plot | beta.plot) + plot_layout(widths=c(3,1),guides = "collect")
rm(mean.plot, beta.plot)
```

# 7. Figures

Create a directory to drop all figures and supplementary data into

```{bash Make Figure Dirs}

mkdir -p figures/supplement/

```

## 7A. Universal function to make forest plots

```{r Meta analysis calc and plotting}

## Helper functions for the main function:

get.meta.val.logistic <- function(study, m, s, g) {
  
  meta.table <- study[maf == m & (variant.type == "DEL" | variant.type == "LOF_HC") & sex == s & gene.list == g]
  meta.analy <- metagen(var.beta,
                        var.stderr,
                        studlab = variant.type,
                        method.tau = "SJ",
                        sm = "OR",
                        data = meta.table)
  
    return(list(meta.analy$TE.fixed,
                meta.analy$seTE.fixed,
                meta.analy$pval.fixed))
  
}

get.meta.val.linear <- function(study, m, s, g) {

  meta.table <- study[maf == m & (variant.type == "DEL" | variant.type == "LOF_HC") & sex == s & gene.list == g]
  meta.analy <- metagen(var.beta,
                        var.stderr,
                        studlab = variant.type,
                        sm = "SMD",
                        prediction=T,
                        data = meta.table)

    return(list(meta.analy$TE.fixed,
                meta.analy$seTE.fixed,
                meta.analy$pval.fixed))
    
}

make.meta.table <- function(data, is.linear, 
                            gene.list = "product_sHET",
                            allele.freq = 0,
                            ymin = -0.15, 
                            ymax = 1.25, 
                            b = 0.2, 
                            block = 0, 
                            p.pos = 0.05,
                            title = "",
                            show.x = T,
                            alt.y.axis = NA) {

  meta.result <- data.table(crossing(maf = allele.freq,
                                  sex = c(1,2),
                                  gene.list = gene.list,
                                  variant.type = "META"))

  if (is.linear == T) {
    meta.result[,c("var.beta","var.stderr","var.p"):=get.meta.val.linear(data,maf,sex,gene.list),by=1:nrow(meta.result)]
    y.axis <- expression(bold(Effect~Size~`for`~1~Unit~of~Quantified~s[het]))
    plot.breaks <- c(seq(0,ymin,by=-1 * b),seq(0,ymax,by=b))
    plot.breaks <- plot.breaks[plot.breaks != block]

    meta.table <- bind_rows(data[maf == allele.freq & (variant.type == "DEL" | variant.type == "LOF_HC"),c("variant.type","sex","var.beta","var.stderr","var.p","n.var","n.indvs")],
                          meta.result[maf == allele.freq,c("variant.type","sex","var.beta","var.stderr","var.p")])
    
    meta.table[,var.ci.upper:=var.beta + (1.96*var.stderr)]
    meta.table[,var.ci.lower:=var.beta - (1.96*var.stderr)]
    
  } else {
    meta.result[,c("var.beta","var.stderr","var.p"):=get.meta.val.logistic(data,maf,sex,gene.list),by=1:nrow(meta.result)]

    y.axis <- expression(bold(Odds~Ratio~`for`~1~Unit~of~Quantified~s[het]))
    plot.breaks <- c(seq(1,ymin,by=-1 * b),seq(1,ymax,by=b))
    plot.breaks <- plot.breaks[plot.breaks != block]
    
    meta.table <- bind_rows(data[maf == allele.freq & (variant.type == "DEL" | variant.type == "LOF_HC"),c("variant.type","sex","var.beta","var.stderr","var.p","n.var","n.indvs")],
                          meta.result[maf == allele.freq ,c("variant.type","sex","var.beta","var.stderr","var.p")])
    
    meta.table[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
    meta.table[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
    meta.table[,var.beta:=exp(var.beta)]
    
  }

  if (!is.na(alt.y.axis)) {
    y.axis <- alt.y.axis
  }
  
  n.male <- data[sex == 1 & maf == allele.freq & (variant.type == "DEL" | variant.type == "LOF_HC"), sum(n.indvs)]
  n.female <- data[sex == 2 & maf == allele.freq & (variant.type == "DEL" | variant.type == "LOF_HC"), sum(n.indvs)]
  
  meta.table[,n.indvs:=if_else(variant.type=="META",if_else(sex == 1, n.male, n.female),n.indvs)]
  meta.table[,Sex:=factor(sex,levels=c("1","2"),labels = c("Male","Female"))]
  meta.table[,sex:=NULL]
  meta.table[,variant.type:=factor(variant.type,levels=c("META","LOF_HC","DEL"))]
  meta.table[,variant.shape:=if_else(variant.type=="META",18,15)]
  meta.table[,p.nudge:=if_else(variant.type=="LOF_HC",-0.2,-0.3)]
  
  if (show.x == T) {
    add.theme <- theme(panel.grid.major.y = element_blank())
  } else {
    add.theme <- theme(axis.title.x=element_blank(),axis.text.x=element_blank(), panel.grid.major.y = element_blank())
  }
  
  
  
  plot <- ggplot(meta.table,aes(variant.type,var.beta,group=Sex,colour=Sex)) +
    geom_hline(aes(yintercept=if_else(is.linear==T,0, 1)),colour="red",linetype=2,size=1) +
    geom_point(aes(size=n.indvs,shape=variant.shape),position=position_dodge(0.5)) +
    geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),width=0.1,position=position_dodge(0.5)) +
    geom_text(aes(y = p.pos, label=paste0("p = ", sprintf("%0.2g",var.p))),position=position_dodge(0.5),size=4,hjust=1,show.legend = F) +
    scale_x_discrete(name = title, position = "top",labels=c("Meta","PTVs","Dels")) +
    scale_y_continuous(name=y.axis,limits = c(ymin,ymax), breaks=plot.breaks) +
    scale_shape_identity() +
    scale_size_area(breaks=c(50000,100000,150000),guide=guide_legend(title="# of Indivs.")) +
    sex.colours.colour.rev +
    coord_flip() +
    theme.figures.legend + add.theme

  return(list(meta.table,plot))
  
}
```

## 7B. Main Text

Please note -- a very light amount of editing was used to make better figure legends for main text figures 1 and 2.

### Figure 1.

```{r fig.height=5, fig.width=7}

## This just gets a forest plot for our primary childlessness logistic regression
plot.a <- make.meta.table(results.fertility, F, b = 0.25)

## the 'tab' data.frame is relevant only for plot b and c, using old regressions for plot. 
## This is to just tabulate vitality statistics for each individual
tab <- UKBB.phenotype.data[,c("eid","sexPulse","agePulse","agePulse.squared","children.fathered","live.births","partner.in.house","PC1","PC2","PC3","PC4","PC5","PC6","PC7","PC8","PC9","PC10")]

tab[,children:=if_else(sexPulse==1,children.fathered,live.births)]
tab <- tab[!is.na(children)]

## Function to generate plots for Dels and PTVs
plot.dist.mean <- function (v) {
  
  ## Attach sHET burden to each individual
  quants <- merge(tab,variant.counts[type==v & allele.freq==0,c("sample_id","product_sHET")],by.x="eid",by.y="sample_id",all.x=T)
  quants[,sexPulse:=factor(sexPulse,levels=c("1","2"),labels = c("Male","Female"))]
  
  ## Only include individuals for which we have CNV or PTV data
  quants <- quants[eid %in% samples.UKBB.cnv[,eid] | eid %in% samples.UKBB[,eid]]
  
  ## Get whether individuals have children or not:
  quants[,children.binary:=if_else(children>0,1,0)]
  quants[,dummy:=1]
  
  ## Remove individuals without an sHET score
  quants <- quants[!is.na(product_sHET)]
  
  ## The following code is to set axis limits and labels -- purely graphical
  # Bin sizes
  if (v == "DEL") {
    b <- c(-1,((0:4)*0.15),100)
  } else {
    b <- c(-1,((0:3)*0.15),100)
  }
  quants[,product_sHET.cut:=cut(product_sHET,breaks=b)]
  quants[,dummy:=1]
  
  # Quantify proportion of individuals in each sHET bin we create above
  totals <- quants[,sum(dummy),by=c("product_sHET.cut","sexPulse")]
  sums <- quants[,sum(dummy),by=c("sexPulse")]
  setnames(sums,c("sexPulse"),c("s"))
  totals[,prop:=V1/sums[s==sexPulse,V1],by=1:nrow(totals)]
  totals[,prop.2:=prop*100000]
  totals[,ci:=1.96*sqrt((prop.2*(100000-prop.2))/sums[s==sexPulse,V1]),by=1:nrow(totals)]
  
  ## Change the ugly formating that is the direct output of 'cut()' to something better for a plot label
  x.axis.labels <- str_replace(str_replace(str_replace(str_replace(totals[,levels(product_sHET.cut)],"\\[",""),"\\]",""),",","-"),"\\(","")
  x.axis.labels.2 <- c()
  for (l in x.axis.labels) {
    if (grepl("-100",l)) {
      l <- str_replace(l,"\\-100","")
      l <- paste0(">",l)
      x.axis.labels.2 <- c(x.axis.labels.2,l)
    } else if (grepl("-1-",l)) {
      l <- str_replace(l,"\\-1-","")
      x.axis.labels.2 <- c(x.axis.labels.2,l)
    } else {
      x.axis.labels.2 <- c(x.axis.labels.2,l)
    }
  }
  
  ## Cumulative Density Plot of joint.product_sHET by sex
  plot.dist <- ggplot(totals,aes(product_sHET.cut,prop.2,group=sexPulse,fill=sexPulse)) +
    geom_col(position=position_dodge(1),colour="black") +
    scale_x_discrete(name = expression(bold(Quantified~s[het]~Range)),labels=x.axis.labels.2) +
    scale_y_log10(name = "Proportion of Individuals",breaks=c(1,10,100,1000,10000,100000),labels=paste0(c(0.001,0.01,0.1,1,10,100),"%")) +
    geom_errorbar(aes(ymin=prop.2-ci,ymax=prop.2+ci),position=position_dodge(1),width=0) +
    sex.colours.fill +
    theme.figures

  ## Percentage of Individuals With Children By Sex and Variant Type
  means <- quants[,list(mean(children.binary),sd(children.binary),sum(dummy)),by=c("sexPulse","product_sHET.cut")]
  setnames(means,c("V1","V2","V3"),c("mean","sd","n"))
  
  means[,mean:=mean*100]
  means[,sd:=sd*100]
  means[,ci:=(sd/sqrt(n))*1.96]
  means[,ci.lower:=mean-ci]
  means[,ci.upper:=mean+ci]
  
  means[,ci.lower.symbol:=if_else(ci.lower<0,25,NaN)]
  means[,ci.lower:=if_else(ci.lower<0,0,ci.lower)]
  means[,ci.upper.symbol:=if_else(ci.upper>100,24,NaN)]
  means[,ci.upper:=if_else(ci.upper>100,100,ci.upper)]
  
  means[,sex:=factor(sexPulse,levels=c(1,2,3),labels=c("Male","Female","Both"))]
  
  means[,mean.adj:=if_else(sexPulse=="Male",mean+2.47741,mean)]
  means[,sd.adj:=if_else(sexPulse=="Male",sd+2.47741,sd)]
  means[,ci.adj:=(sd.adj/sqrt(n))*1.96]
  means[,ci.lower.adj:=mean.adj-ci.adj]
  means[,ci.upper.adj:=mean.adj+ci.adj]
  
  lines <- means[product_sHET.cut=="(-1,0]"]
  
  plot.means <- ggplot(means,aes(product_sHET.cut,mean,group=sexPulse,colour=as.factor(sexPulse))) +
    geom_hline(data=lines,aes(yintercept=mean,colour=as.factor(sexPulse)),linetype=2) +
    geom_point(position=position_dodge(0.5),shape=16,size=3) +
    geom_errorbar(aes(ymin=ci.lower,ymax=ci.upper),width=0,position=position_dodge(0.5),size=1) +
    scale_x_discrete(name = expression(bold(Quantified~s[het]~Range)),labels=x.axis.labels.2) +
    scale_y_continuous(name="Percentage of Individuals\nWith Children",limits=c(0,100)) +
    sex.colours.colour +
    theme.figures
  
  return(list(plot.dist,plot.means))
  
}

del.plots <- plot.dist.mean("DEL")
lof.plots <- plot.dist.mean("LOF_HC")
```

```{r Figure 1, fig.height=9, fig.width=8}

top <- (plot.a[[2]] + plot_spacer()) + plot_layout(widths=c(1,0.05))  

middle <- (del.plots[[1]] + lof.plots[[1]]) + plot_layout(widths=c(1,0.8))  

bottom <- (del.plots[[2]] + lof.plots[[2]]) + plot_layout(widths=c(1,0.8))

figure.1 <- top / middle / bottom  + plot_layout(guides="keep",nrow=3,heights = c(2.5,3,4)) + plot_annotation(tag_levels = "A")

figure.1

ggsave("figures/Figure1.eps",figure.1,width=8,height=9)

plot.a[[1]][ variant.type == "META",paste0(Sex, " OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

```

### Figure 2.

Effect of rare variants on various metrics:

```{r fig.height=8.5, fig.width=7}

fig.partner <- make.meta.table(results.partner, F, title = "Partner at Home",show.x=F,b=0.25)
fig.ea <- make.meta.table(results.ea, F, title = "Edu. Attainment",b=0.25)
fig.hhi <- make.meta.table(results.household.income, T, title = "Household Income",show.x=F, ymin = -2.3, ymax= 0.5, block = -2, p.pos = -1.9, b = 0.5)
fig.cog <- make.meta.table(results.cog[sex==1 | sex == 2], T, ymin = -2.3, ymax= 0.5, block = -2, p.pos = -1.9, b = 0.5, title = "Fluid Intelligence")

figure.2 <- fig.partner[[2]] + fig.ea[[2]] + fig.hhi[[2]] + fig.cog[[2]] + plot_layout(nrow=4, guides = "collect") + plot_annotation(tag_levels = "A")

figure.2

ggsave("figures/Figure2.eps",figure.2,width=7,height=8.5)

fig.partner[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Partner OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

paste0("Number of Fluid Intel Indv: ", sum(fig.cog[[1]][variant.type == "META",n.indvs]), " (Male: ",fig.cog[[1]][Sex == "Male" & variant.type == "META",n.indvs],"; Female: ", fig.cog[[1]][Sex == "Female" & variant.type == "META",n.indvs], ")")
```

### Figure 3.

```{r Figure 3, fig.height=3, fig.width=4}

figure.3 <- ggplot(model.fertility, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Reduction in Fitness", limits = c(0,1.05)) + theme.figures.legend

figure.3

ggsave("figures/Figure3.svg",figure.3,width=4,height=3,units = "in")

```

### Text-based ORs

```{r fig.height=3.5, fig.width=7}

## no male fertility genes
no.male.fertility.plot <- make.meta.table(results.excl.male, F, gene.list = "product_sHET_no_male_infertility")

no.male.fertility.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Fertility Gene OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

## no pathogenic CNV carriers
no.path.cnvs.plot <- make.meta.table(results.fertility.no.path, F)

no.path.cnvs.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," No Path CNVs OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

## Exclude MH patients
no.mh.patients.plot <- make.meta.table(results.fertility.no.mhq, F)

no.mh.patients.plot[[1]][variant.type == "META",paste0(Sex," No MH Patients OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

## Exclude Disease Genes
no.disease.plot <- make.meta.table(results.excl.disease, F, gene.list = "product_sHET_no_disease", ymax = 1.6)

no.disease.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," Disease Gene OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
```

## 7C. Supplement

### Figures

#### Figure 1.

CNVs Per Individual Figures

```{r fig.height=5, fig.width=8}

ukbb.annotated.cnvs.qcd[,dummy:=1]

totals.delhom <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number==0 & filter.0.95.wes.support.score == T,.(num.del.hom=sum(dummy)),by=c("eid")]
totals.delhet <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number==1 & filter.0.95.wes.support.score == T,.(num.del.het=sum(dummy)),by=c("eid")]
totals.duphet <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number==3 & filter.0.95.wes.support.score == T,.(num.dup.het=sum(dummy)),by=c("eid")]
totals.duphom <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number==4 & filter.0.95.wes.support.score == T,.(num.dup.hom=sum(dummy)),by=c("eid")]
totals.len.del <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number<2 & filter.0.95.wes.support.score == T,.(len.del=sum(Length_bp* abs(Copy_Number - 2))),by=c("eid")]
totals.len.dup <- ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & Copy_Number>2 & filter.0.95.wes.support.score == T,.(len.dup=sum(Length_bp * abs(Copy_Number - 2))),by=c("eid")]
  
totals.filtered <- merge(totals.delhom,totals.delhet,by="eid",all=T)
totals.filtered <- merge(totals.filtered,totals.duphet,by="eid",all=T)
totals.filtered <- merge(totals.filtered,totals.duphom,by="eid",all=T)
totals.filtered <- merge(totals.filtered,totals.len.del,by="eid",all=T)
totals.filtered <- merge(totals.filtered,totals.len.dup,by="eid",all=T)

totals.filtered <- merge(samples.UKBB.cnv,totals.filtered,by="eid",all.x=T)

totals.filtered[is.na(totals.filtered)] <- 0

totals.filtered[,num.del.sites:=num.del.het+num.del.hom]
totals.filtered[,num.dup.sites:=num.dup.het+num.dup.hom]
totals.filtered[,total:=num.del.sites+num.dup.sites]

## Plot to just do histogram of total sites:
print(paste0("Total Sites    : ", sum(totals.filtered[,total])))
print(paste0("Mean Total     : ", sprintf("%0.02f",mean(totals.filtered[,total])), "±", sprintf("%0.02f",sd(totals.filtered[,total]))))
print(paste0("Median Total   : ", median(totals.filtered[,total])))
print("")
print(paste0("Total DEL Sites : ", sum(totals.filtered[,num.del.sites])))
print(paste0("Mean DEL        : ", sprintf("%0.02f",mean(totals.filtered[,num.del.sites])), "±", sprintf("%0.02f",sd(totals.filtered[,num.del.sites]))))
print(paste0("Median DEL      : ", median(totals.filtered[,num.del.sites])))
print(paste0("Mean DEL Len    : ", sprintf("%0.01f",mean(totals.filtered[,len.del])/1000), "±", sprintf("%0.01f",sd(totals.filtered[,len.del])/1000)))
print("")
print(paste0("Total DUP Sites : ", sum(totals.filtered[,num.dup.sites])))
print(paste0("Mean DUP        : ", sprintf("%0.02f",mean(totals.filtered[,num.dup.sites])), "±", sprintf("%0.02f",sd(totals.filtered[,num.dup.sites]))))
print(paste0("Median DUP      : ", median(totals.filtered[,num.dup.sites])))
print(paste0("Mean DUP Len    : ", sprintf("%0.01f",mean(totals.filtered[,len.dup])/1000), "±", sprintf("%0.01f",sd(totals.filtered[,len.dup])/1000)))

ggplot(totals.filtered, aes(total)) + geom_histogram(binwidth=1,fill="grey",colour="black",size=2) + geom_vline(aes(xintercept=mean(totals.filtered[,total])),colour="red",size=2) + xlab("Sites Per Individual") + ylab("# of Individuals") + theme

## DELs
x.lim<-max(totals.filtered[,num.del.sites])
y.lim<-3.0e6
plot1 <- ggplot(totals.filtered,aes(num.del.sites,len.del)) + geom_point(colour=del.line,size=0.5) + xlim(-1,x.lim) + ylim(-100000,y.lim) + xlab("Total Deletion Sites") + ylab("Cumulative Deletion Length") + theme.figures
x.hist <- ggplot(totals.filtered,aes(num.del.sites)) + geom_histogram(binwidth=1, colour=del.line, fill=del.fill) + xlim(-1,x.lim) + ylab("Count") + theme.figures + theme(axis.title.x=element_blank(),axis.text.x=element_blank())
y.hist <- ggplot(totals.filtered,aes(len.del)) + geom_histogram(binwidth=100000, colour=del.line, fill=del.fill) + xlim(-100000,y.lim) + ylab("Count") + coord_flip() + theme.figures + theme(axis.title.y=element_blank(),axis.text.y=element_blank())

## All the "empty" plots here are just used to push the graphs together.
del.plot <- x.hist + plot_spacer() + plot1 + y.hist + plot_layout(ncol = 2, nrow = 2, widths = c(2,1), heights = c(1,2))
del.plot

## DUPs
x.lim<-max(totals.filtered[,num.dup.sites])
y.lim<- 1e7
plot1 <- ggplot(totals.filtered,aes(num.dup.sites,len.dup)) + geom_point(colour=dup.line,size=0.5) + xlim(-1,x.lim) + ylim(-500000,y.lim) + xlab("Total Duplication Sites") + ylab("Cumulative Duplication Length") + theme.figures
x.hist <- ggplot(totals.filtered,aes(num.dup.sites)) + geom_histogram(binwidth=1,colour=dup.line,fill=dup.fill) + xlim(-1,x.lim) + ylab("Count") + theme.figures + theme(axis.title.x=element_blank(),axis.text.x=element_blank())
y.hist <- ggplot(totals.filtered,aes(len.dup)) + geom_histogram(binwidth=500000,colour=dup.line,fill=dup.fill) + xlim(-500000,y.lim) + ylab("Count") + coord_flip() + theme.figures + theme(axis.title.y=element_blank(),axis.text.y=element_blank())

dup.plot <- x.hist + plot_spacer() + plot1 + y.hist + plot_layout(ncol = 2, nrow = 2, widths = c(2,1), heights = c(1,2))
dup.plot

total.plot <- (del.plot | dup.plot)

total.plot

ggsave("figures/supplement/SuppFig1.png",total.plot,dpi = 300,height = 5, width = 8, units = c("in"))

quant.table <- data.table(table(ukbb.annotated.cnvs.qcd[filter.0.95.wes.support.score==T,ct]))
paste0("Number of CNVs (Unfiltered Indiv)  : ",quant.table[,sum(N)], " (DEL: ", quant.table[V1 == "DEL",N], "; DUP: ", quant.table[V1 == "DUP",N],")")
quant.table <- data.table(table(ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score==T,ct]))
paste0("Number of CNVs (Filtered Indiv)    : ",quant.table[,sum(N)], " (DEL: ", quant.table[V1 == "DEL",N], "; DUP: ", quant.table[V1 == "DUP",N],")")
paste0("Number of CNV Loci                 : ",nrow(data.table(table(ukbb.annotated.cnvs.qcd[,locus]))))
rm(quant.table)
```

#### Figure 2.

SNV Counts Per Individual

```{r fig.height=5, fig.width=8.5}

UKBB.counts <- count.variants(variants.UKBB,samples.UKBB,0.001)
UKBB.counts[,CSQ:=if_else(CSQ == "LOF_HC","PTVs",if_else(CSQ == "MIS","Missense",if_else(CSQ == "SYN","Synonymous",as.character(NA))))]
UKBB.counts[,AF:=if_else(AF=="AC1","Singleton Vars.","MAF ≤ 1e-3 Vars.")]
UKBB.counts[,AF:=factor(AF,levels=c("Singleton Vars.","MAF ≤ 1e-3 Vars."))]

all.plot <- ggplot(UKBB.counts,aes(CSQ,count,colour=AF)) + geom_boxplot() + scale_x_discrete(name = "Variant Class") + scale_y_log10(name = "# of Variants") + scale_colour_discrete(guide=guide_legend(title="")) + theme.figures
all.plot

missense.plot <- ggplot(UKBB.counts[CSQ == "Missense"],aes(count,fill=AF)) + geom_histogram(binwidth=1, position = "identity", alpha = 0.5) + scale_y_continuous(name = "Number of Individuals") + scale_x_continuous(name = "# of Missense Vars.") + scale_alpha_continuous(range=c(0,1)) + scale_fill_discrete(guide=guide_legend(title="")) + theme.figures.legend
missense.plot

ptv.plot <- ggplot(UKBB.counts[CSQ == "PTVs"],aes(count,fill=AF)) + geom_histogram(binwidth=1, position = "identity", alpha = 0.5) + scale_y_continuous(name = "") + scale_x_continuous(name = "# of PTVs") + scale_alpha_continuous(range=c(0,1)) + scale_fill_discrete(guide=guide_legend(title="")) + theme.figures.legend
ptv.plot

syn.plot <- ggplot(UKBB.counts[CSQ == "Synonymous"],aes(count,fill=AF)) + geom_histogram(binwidth=1, position = "identity", alpha = 0.5) + scale_y_continuous(name = "") + scale_x_continuous(name = "# of Synonymous Vars.") + scale_alpha_continuous(range=c(0,1)) + scale_fill_discrete(guide=guide_legend(title="")) + theme.figures.legend
syn.plot

snv.count.plot <- ((missense.plot | ptv.plot | syn.plot | all.plot) / (guide_area())) + plot_layout(guides = "collect", nrow = 2,heights = c(4,1)) + plot_annotation(tag_levels = 'A')
snv.count.plot

ggsave("figures/supplement/SuppFig2.png",snv.count.plot, dpi = 600, height = 5, width = 8.5, units = "in")

paste0("Number of SNV/INDel Variants: ", nrow(variants.UKBB[,]))
```

#### Figure 3.

```{r fig.height=3, fig.width=8.5}

linear.data <- make.meta.table(results.fertility.linear, T, ymin = -1.15, ymax= 0.25, block = -1, p.pos = -1)
linear.data

ggsave("figures/supplement/SuppFig3.png",linear.data[[2]], dpi = 600, height = 3, width = 8.5, units = "in")

linear.data[[1]][variant.type == "META",paste0(Sex, "s have ",sprintf("%0.2f",abs(var.beta))," fewer children", " [95% CI ",sprintf("%0.2f",abs(var.beta+(1.96*var.stderr))), "-",sprintf("%0.2f",abs(var.beta-(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

```

#### Figure 4.

```{r fig.height=3, fig.width=8.5}

remove.zero <- make.meta.table(results.fertility.zero, T, ymin = -1.15, ymax= 0.25, block = -1, p.pos = -1)
remove.zero

ggsave("figures/supplement/SuppFig4.png",remove.zero[[2]], dpi = 600, height = 3, width = 8.5, units = "in")

```

#### Figure 5.

```{r fig.height=6, fig.width=8.5}

gene.data.pli <- make.meta.table(results.fertility.genelists[gene.list == "highPLI"], F, gene.list = "highPLI", alt.y.axis = "Odds Ratio for loss of 1 high (>0.9) pLI gene",ymin=0.4,ymax=1.25,p.pos = 0.5,block = 0.4)
gene.data.pli[[2]] <- gene.data.pli[[2]] + theme(legend.position="blank")

alt.y <- expression(bold(Odds~Ratio~`for`~loss~of~"1"~high~"(" >= 0.15~")"~s[het]~gene))
gene.data.shet <- make.meta.table(results.fertility.genelists[gene.list == "highsHET"], F, gene.list = "highsHET", alt.y.axis = alt.y,ymin=0.4,ymax=1.25,p.pos = 0.5,block = 0.4)
gene.data.shet

combined.gene <- gene.data.pli[[2]] + gene.data.shet[[2]] + plot_layout(nrow = 2, guides = "collect") + plot_annotation(tag_levels = 'A')
combined.gene

ggsave("figures/supplement/SuppFig5.png",combined.gene, dpi = 600, height = 5, width = 8.5, units = "in")
```

#### Figure 6.

```{r fig.height=3, fig.width=8.5}

high.maf.data <- make.meta.table(results.fertility, F, allele.freq = 1e-3, b=0.25)
high.maf.data

ggsave("figures/supplement/SuppFig6.png",high.maf.data[[2]], dpi = 600, height = 3, width = 8.5, units = "in")

```

#### Figure 7.

```{r fig.height=6, fig.width=8.5}

res.age[,Sex:=factor(y.var,levels=c("children.fathered","live.births"),labels=c("Male","Female"))]
res.age[,agePulse:=factor(age,levels=c("ALL","60","50","40"),labels=c("All Ages","60-70","50-60","40-50"))]
res.age[,variantPulse:=factor(variant.type,levels=c("META","LOF_HC","DEL"),labels=c("Meta","PTVs","Dels"))]

ylab <- "Odds Ratio"
yline <- 1
y.axis <- expression(bold(Odds~Ratio~`for`~1~Unit~of~Quantified~s[het]))

plot.breaks <- c(seq(1,-0.75,by=-1 * 0.5),seq(1,2.75,by=0.5))
plot.breaks <- plot.breaks[plot.breaks != -0.5]

plot.ages <- ggplot(res.age,aes(agePulse,var.beta,group=interaction(Sex,variantPulse),colour=Sex,linetype=variantPulse)) +
  geom_hline(aes(yintercept=1),colour="red",linetype=2,size=1) +
  geom_point(aes(size=n.indvs,shape=18),position=position_dodge(0.65)) +
  geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),width=0.1,position=position_dodge(0.65)) +
  geom_text(aes(y = -0.15, label=paste0("p = ", sprintf("%0.2g",var.p))),position=position_dodge(0.65),size=4,hjust=1,show.legend = F) +
  scale_x_discrete(name = "", position = "top") +
  scale_y_continuous(name=y.axis,limits = c(-0.5,2.75), breaks=plot.breaks) +
  scale_shape_identity() +
  scale_size_area(breaks=c(50000,100000,150000),guide=guide_legend(title="# of Indivs.")) +
  scale_linetype_discrete(guide=guide_legend(reverse = T, title = "Variant Class")) +
  sex.colours.colour.rev +
  coord_flip() +
  theme.figures.legend + theme(panel.grid.major.y = element_blank(), legend.background=element_rect(fill="white"))
plot.ages

ggsave("figures/supplement/SuppFig7.png",plot.ages, dpi = 600, height = 6, width = 8.5, units = "in")
```


#### Figure 8.

```{r fig.height=4, fig.width=8.5}

plottable <- copy(results.fertility)

plottable[,var.ci.upper:=exp(var.beta + (1.96*var.stderr))]
plottable[,var.ci.lower:=exp(var.beta - (1.96*var.stderr))]
plottable[,sig.pos:=if_else(var.beta<0,var.ci.lower-0.1,var.ci.upper+0.1)]

plottable[,var.beta:=exp(var.beta)]
plottable[,Sex:=factor(sex,levels=c("1","2"),labels = c("Male","Female"))]
ylab <- "Odds Ratio"
yline <- 1
y.axis <- expression(bold(Odds~Ratio~`for`~1~Unit~of~Quantified~s[het]))

plot.breaks <- c(seq(1,-0.15,by=-1 * 0.25),seq(1,1.25,by=0.25))
plot.breaks <- plot.breaks[plot.breaks != 0]

plot.all.variants <- ggplot(plottable[maf == 0],aes(variant.type,var.beta,group=Sex,colour=Sex)) +
    geom_hline(aes(yintercept=1),colour="red",linetype=2,size=1) +
    geom_point(aes(size=n.indvs,shape=18),position=position_dodge(0.5)) +
    geom_errorbar(aes(ymin=var.ci.lower,ymax=var.ci.upper),width=0.1,position=position_dodge(0.5)) +
    geom_text(aes(y = 0.05, label=paste0("p = ", sprintf("%0.2g",var.p))),position=position_dodge(0.5),size=4,hjust=1,show.legend = F) +
    scale_x_discrete(name = "", position = "top",labels=c("Dels","Dups","PTVs","Missense\n(CADD > 25, MPC > 2)","Synonymous")) +
    scale_y_continuous(name=y.axis,limits = c(-0.15,1.3), breaks=plot.breaks) +
    scale_shape_identity() +
    scale_size_area(breaks=c(50000,100000,150000),guide=guide_legend(title="# of Indivs.")) +
    sex.colours.colour.rev +
    coord_flip() +
    theme.figures.legend + theme(panel.grid.major.y = element_blank())

plot.all.variants

ggsave("figures/supplement/SuppFig8.png",plot.all.variants, dpi = 600, height = 4, width = 8.5, units = "in")

```

#### Figure 9.

```{r fig.height=10, fig.width=8}

## Has a Private DEL
plot.testis.del.shet.wilcox <- wilcox.test(log.mean ~ has.del, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))
plot.testis.del.shet <- ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(has.del), log.mean, group = as.factor(has.del))) +
  geom_boxplot() +
  scale_x_discrete(name = "Has a private DEL") +
  scale_y_continuous(name = "") +
  annotate("text", x = 1.5, y = 6, size = 4, label = if_else(plot.testis.del.shet.wilcox$p.value < 0.05, paste0("p = ", sprintf("%0.1e", plot.testis.del.shet.wilcox$p.value)),"p > 0.05")) +
  ggtitle(expression(bold(s[HET] >= 0.15~Genes))) +
  coord_flip() +
  theme

plot.testis.del.wilcox <- wilcox.test(log.mean ~ has.del, data = shet.genes.expr,alternative=c("less"))
plot.testis.del <- ggplot(shet.genes.expr, aes(as.factor(has.del), log.mean, group = as.factor(has.del))) +
  geom_boxplot() +
  scale_x_discrete(name = "") +
  scale_y_continuous(name = "") +
  annotate("text", x = 1.5, y = 6, size = 4, label = if_else(plot.testis.del.wilcox$p.value < 0.05, paste0("p = ", sprintf("%0.1e", plot.testis.del.wilcox$p.value)),"p > 0.05")) +
  ggtitle("All Genes") +
  coord_flip() +
  theme

## Has a Private PTV
plot.testis.ptv.shet.wilcox <- wilcox.test(log.mean ~ has.ptv, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))
plot.testis.ptv.shet <- ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(has.ptv), log.mean, group = as.factor(has.ptv))) +
  geom_boxplot() +
  scale_x_discrete(name = "Has a private PTV") +
  scale_y_continuous(name = "") +
  annotate("text", x = 1.5, y = 6, size = 4, label = if_else(plot.testis.ptv.shet.wilcox$p.value < 0.05, paste0("p = ", sprintf("%0.1e", plot.testis.ptv.shet.wilcox$p.value)),"p > 0.05")) +
  coord_flip() +
  theme

plot.testis.ptv.wilcox <- wilcox.test(log.mean ~ has.ptv, data = shet.genes.expr,alternative=c("less"))
plot.testis.ptv <- ggplot(shet.genes.expr, aes(as.factor(has.ptv), log.mean, group = as.factor(has.ptv))) +
  geom_boxplot() +
  scale_x_discrete(name = "") +
  scale_y_continuous(name = "") +
  annotate("text", x = 1.5, y = 6, size = 4, label = if_else(plot.testis.ptv.wilcox$p.value < 0.05, paste0("p = ", sprintf("%0.1e", plot.testis.ptv.wilcox$p.value)),"p > 0.05")) +
  coord_flip() +
  theme

## Is a male infertility gene
plot.male.shet.wilcox <- wilcox.test(log.mean ~ male.infertility, data = shet.genes.expr[sHET.val > 0.15],alternative=c("less"))
plot.male.shet <- ggplot(shet.genes.expr[sHET.val > 0.15], aes(as.factor(male.infertility), log.mean, group = as.factor(male.infertility))) +
  geom_boxplot(name = "") +
  scale_x_discrete(name = "Is male infertility gene?") + 
  scale_y_continuous(name = expression(bold(Median~log[e](Expr.~Testis)))) + 
  annotate("text", x = 1.5, y = 6, size = 4, label = if_else(plot.male.shet.wilcox$p.value < 0.05, paste0("p = ", sprintf("%0.1e", plot.male.shet.wilcox$p.value)),"p > 0.05")) +
  coord_flip() +
  theme

plot.male.wilcox <- wilcox.test(log.mean ~ male.infertility, data = shet.genes.expr,alternative=c("less"))
plot.male <- ggplot(shet.genes.expr, aes(as.factor(male.infertility), log.mean, group = as.factor(male.infertility))) + 
  geom_boxplot() +
  scale_x_discrete(name = "") +
  scale_y_continuous(name = expression(bold(Median~log[e](Expr.~Testis)))) + 
  annotate("text", x = 1.5, y = 6, size = 4, label = if_else(plot.male.wilcox$p.value < 0.05, paste0("p = ", sprintf("%0.1e", plot.male.wilcox$p.value)),"p > 0.05")) +
  coord_flip() +
  theme

plot.testis <- plot.testis.del.shet + plot.testis.del + plot.testis.ptv.shet + plot.testis.ptv  + plot.male.shet + plot.male + plot_layout(nrow=3, guides = "collect") + plot_annotation(tag_levels='A')
plot.testis

ggsave("figures/supplement/SuppFig9.png",plot.testis, dpi = 300, height = 10, width = 8, units = "in")

```


#### Figure 10.

```{r fig.height=6, fig.width=8}

plot.betas <- function(x.var, type, add.covars = c(), ymin = 0, ymax = 2) {
  
  data <- data.table(sexPulse=c(1,2))
  data[,c("beta","std.error","p.val","tab","model"):=run.lm(sexPulse,x.var,add.covars = add.covars, inc.PCs = T),by=1:nrow(data)]
  
  data <- copy(data)
  data[,var.ci.upper:=exp(beta + (1.96*std.error))]
  data[,var.ci.lower:=exp(beta - (1.96*std.error))]
  data[,sig.pos:=if_else(beta<1,var.ci.lower-0.1,var.ci.upper+0.1)]
  data[,beta:=exp(beta)]
  data[,sexPulse:=factor(sexPulse,levels=c(1,2),labels=c("Male","Female"))]
  data[,N:=nrow(tab[[1]]),by=1:nrow(data)]

  ylab <- "Effect on having children (Odds Ratio)"
  
  plot <- ggplot(data,aes(sexPulse,beta,colour=sexPulse)) +
    geom_hline(aes(yintercept=1),colour="red",linetype=2) +
    geom_point() +
    geom_errorbar(aes(ymin=var.ci.lower, ymax=var.ci.upper,colour=sexPulse),width=0) +
    scale_x_discrete(name = "") +
    scale_y_continuous(name = ylab, limits = c(ymin,ymax)) +
    sex.colours.colour.rev +
    coord_flip() +
    theme.figures.legend + 
    ggtitle(type) + 
    theme(panel.grid.major.y=element_blank())
    
  return(list(data,plot))
  
}

partner.beta.plot <- plot.betas("partner.in.house", "Having a Partner at Home",ymax=6)
cog.beta.plot <- plot.betas("fluid.intel", "Fluid Intelligence")
ea.beta.plot <- plot.betas("completed.college", "Completing University")
mhq.beta.plot <- plot.betas("ganna.binary", "Having a Severe MH Trait")
hhi.beta.plot <- plot.betas("household.income", "Household Income", c("partner.in.house","partner.in.house*household.income"))
same.sex.beta.plot <- plot.betas("same.sex", "Engaging in Same Sex Sexual Behaviour")

plot.betas <- partner.beta.plot[[2]] +
  cog.beta.plot[[2]] +
  ea.beta.plot[[2]] +
  mhq.beta.plot[[2]] +
  hhi.beta.plot[[2]] +
  same.sex.beta.plot[[2]] + 
  plot_layout(ncol = 2, guides="collect") + plot_annotation(tag_levels = 'A')

plot.betas

ggsave("figures/supplement/SuppFig10.png",plot.betas, dpi = 600, height = 6, width = 8, units = "in")

same.sex.beta.plot[[1]][,paste0(sexPulse, " Same Sex OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]

mhq.beta.plot[[1]][,paste0(sexPulse, " MH OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]
```

#### Figure 11.

```{r fig.height=3, fig.width=8.5}

same.sex <- make.meta.table(results.same.sex, F, b=0.5, ymin=-0.8, ymax = 4.5, p.pos = -0.2, block = -0.5)
same.sex

ggsave("figures/supplement/SuppFig11.png",same.sex[[2]], dpi = 600, height = 3, width = 8.5, units = "in")

same.sex[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Same Sex OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
```

#### Figure 12.

```{r fig.height=15, fig.width=14}

## Fertility

plot.fert.fert <- ggplot(model.fertility, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Fitness", limits = c(0,1.05)) + theme.figures.legend

plot.child.fert <- ggplot(model.fertility, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.childlessness_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.childlessness_lower, ymax = mean.childlessness_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Childlessness", limits = c(0.1,0.6)) + theme.figures.legend

## Partner at home

plot.partner <- ggplot(model.partner, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = expected.without.partner_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= expected.without.partner_lower, ymax = expected.without.partner_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Without A Partner") + theme.figures.legend

plot.fert.partner <- ggplot(model.partner, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Fitness", limits = c(0,1.05)) + theme.figures.legend

plot.child.partner <- ggplot(model.partner, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.childlessness_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.childlessness_lower, ymax = mean.childlessness_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Childlessness", limits = c(0.1,0.6)) + theme.figures.legend

## Educational Attainment

plot.college <- ggplot(model.ea, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = expected.completed.college_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= expected.completed.college_lower, ymax = expected.completed.college_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted College Completion") + theme.figures.legend

plot.fert.ea <- ggplot(model.ea, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Fitness", limits = c(0,1.05)) + theme.figures.legend

plot.child.ea <- ggplot(model.ea, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.childlessness_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.childlessness_lower, ymax = mean.childlessness_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Childlessness", limits = c(0.1,0.6)) + theme.figures.legend

## Cognition

plot.iq <- ggplot(model.cog, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = expected.iq_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= expected.iq_lower, ymax = expected.iq_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted IQ") + theme.figures.legend

plot.fert.iq <- ggplot(model.cog, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Fitness", limits = c(0.9,1.05)) + theme.figures.legend

plot.child.iq <- ggplot(model.cog, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.childlessness_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.childlessness_lower, ymax = mean.childlessness_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Childlessness", limits = c(0.1,0.3)) + theme.figures.legend

## Mental Health

plot.mh <- ggplot(model.mhq, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mean.has.disorder_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= mean.has.disorder_lower, ymax = mean.has.disorder_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted MH Disorder Inc.") + theme.figures.legend

plot.fert.mh <- ggplot(model.mhq, aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = ratio_mid, colour = sexPulse), size=2) + geom_ribbon(aes(ymin= ratio_lower, ymax = ratio_upper), alpha = 0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + geom_abline(intercept=1,slope=-1,linetype=2) + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Fitness", limits = c(0.8,1.05)) + theme.figures.legend

inc.plot.scizo <- ggplot(inc.mht[type == "scizo"], aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mid, colour = sexPulse), size=2, position=position_dodge()) + geom_ribbon(aes(ymin= lower, ymax = upper),alpha=0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Incidence Schizo.", limits = c(0,0.1)) + theme.figures.legend

inc.plot.asd <- ggplot(inc.mht[type == "asd"], aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mid, colour = sexPulse), size=2, position=position_dodge()) + geom_ribbon(aes(ymin= lower, ymax = upper),alpha=0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Incidence ASD", limits = c(0,0.1)) + theme.figures.legend

inc.plot.bipolar <- ggplot(inc.mht[type == "bipolar"], aes(x = shet, group = sexPulse, fill = sexPulse)) + geom_line(aes(y = mid, colour = sexPulse), size=2, position=position_dodge()) + geom_ribbon(aes(ymin= lower, ymax = upper),alpha=0.5) + scale_alpha_continuous(range = c(0,1)) + sex.colours.colour + sex.colours.fill + scale_x_continuous(name=expression(bold(s[het])), limits = c(0,1), expand = c(0,0)) + scale_y_continuous(name = "Predicted Incidence Bipolar Dis.", limits = c(0,0.1)) + theme.figures.legend

blank <- ggplot() + geom_text(label='N/A',aes(x=0.4,y=0.5),size=5) + scale_x_continuous(name = "", limits=c(0,1)) + scale_y_continuous(name = "", limits=c(0,1)) + theme.figures.legend + theme(axis.line=element_blank(), panel.grid.major=element_blank(), axis.text.x=element_blank(), axis.text.y=element_blank(), axis.ticks=element_blank())

plot.predictions <- blank + plot.child.fert + plot.fert.fert + ## Base Fertility
  plot.partner + plot.child.partner + plot.fert.partner + ## Partner at home
  plot.college + plot.child.ea + plot.fert.ea + ## EA
  plot.iq + plot.child.iq + plot.fert.iq + ## Cognition
  plot.mh + grid::textGrob('N/A') + plot.fert.mh + ## MH
  inc.plot.scizo + inc.plot.asd + inc.plot.bipolar + ## MH Incidence
  plot_layout(nrow = 6, ncol = 3, guides = "collect") + plot_annotation(tag_levels = 'A')

plot.predictions

ggsave("figures/supplement/SuppFig12.png",plot.predictions, dpi = 300, height = 15, width = 14, units = "in")

```

#### Figure 13.

```{r fig.height=4, fig.width=8}

cog.fit.plot <- ggplot(cog.raw) + geom_ribbon(data = cog.raw[newiq<120],aes(x=newiq, ymin=Mean-ci,ymax=Mean+ci),colour="grey",alpha=0.3) + geom_line(data = cog.raw[newiq<120],aes(x=newiq, y=Mean),colour="black", size = 1) + geom_line(aes(x = newiq, y=pred.log),colour="red", size = 0.8, linetype = 2) + scale_x_continuous(name = "IQ", limits=c(0,140)) + scale_y_continuous(name = "Average Children", limits=c(-0.1,2)) + scale_alpha_continuous(range=c(0,1)) + theme.figures.legend

child.fit.plot <- ggplot(childless.raw) + geom_ribbon(data = childless.raw[iq<120],aes(x= iq,ymin=ci.lower,ymax=ci.upper),colour="grey",alpha=0.3) + geom_line(data = childless.raw[iq<120],aes(x=iq, y=inc.childlessness),colour="black", size = 1) + geom_line(aes(x = iq, y=pred.log.inv),colour="red", size = 0.8, linetype = 2) + scale_x_continuous(name = "IQ", limits=c(0,140)) + scale_y_continuous(name = "Increased Childlessness from Baseline", limits=c(-0.1,1)) + scale_alpha_continuous(range=c(0,1)) + theme.figures.legend

cog.fit.plots <- cog.fit.plot + child.fit.plot + plot_layout(nrow=1, guides = "collect") + plot_annotation(tag_levels = 'A')

cog.fit.plots

ggsave("figures/supplement/SuppFig13.png",cog.fit.plots, dpi = 600, height = 5, width = 8, units = "in")
```


#### Figure 14.

```{r fig.height=6, fig.width=8.5}

email.data <- make.meta.table(results.email, F, b=0.25, ymax = 1.3,title = "Has Email?")
email.data

answered.mhq.data <- make.meta.table(results.answered.mhq, F, b=0.25, ymax = 1.3, title = "Answered MH Questionnaire?")
answered.mhq.data

bias.plots <- email.data[[2]] + answered.mhq.data[[2]] + plot_layout(guides = "collect", nrow = 2) + plot_annotation(tag_levels = 'A')
bias.plots

ggsave("figures/supplement/SuppFig14.png",bias.plots, dpi = 600, height = 6, width = 8.5, units = "in")

email.data[[1]][ variant.type == "META",paste0(Sex, " Email OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]

answered.mhq.data[[1]][ variant.type == "META",paste0(Sex, " MHQ OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
```

#### Figure 15.

```{r fig.height=5, fig.width=8}

## Grab relevant columns from phenotype data
birth.stats <- UKBB.phenotype.data[,c("eid","children.fathered","live.births","sexPulse","agePulse")]
birth.stats[,dummy:=1]

## Tabualte if individuals had children dependent on their sex
birth.stats <- birth.stats[!is.na(children.fathered) | !is.na(live.births)]
birth.stats[,has.children:=if_else(sexPulse == 1, if_else(children.fathered>0,1,0), if_else(live.births>0,1,0))]

## Calulcate birth stats for...
# men
men <- birth.stats[(children.fathered >= 0 & sexPulse == 1),list(mean(children.fathered),sd(children.fathered),mean(has.children),sd(has.children),sum(dummy)),by="agePulse"]
men[,y.var:="children.fathered"]

# women
women <- birth.stats[(live.births >= 0 & sexPulse == 2),list(mean(live.births),sd(live.births),mean(has.children),sd(has.children),sum(dummy)),by="agePulse"]
women[,y.var:="live.births"]

agePlot <- bind_rows(men,women)
setnames(agePlot,c("V1","V2","V3","V4","V5"),c("mean.births","sd.births","mean.childlessness","sd.childlessness","n"))
agePlot[,ci.births:=1.96*(sd.births/sqrt(n))]
agePlot[,ci.childlessness:=1.96*(sd.childlessness/sqrt(n))]

## Get rid of categories with < 10 individuals
agePlot <- agePlot[n >= 10]

## Invert childlessness for plotting purposes
agePlot[,mean.childlessness:=1-mean.childlessness]

## Factorize sex
agePlot[,sexPulse:=factor(y.var,levels=c("children.fathered","live.births"),labels=c("Male","Female"))]

## Plot of mean number of children
plot.children <- ggplot(agePlot,aes(agePulse,mean.births,group=y.var,colour=sexPulse)) + geom_point(position=position_dodge(0.5)) + geom_errorbar(aes(ymin=mean.births-ci.births,ymax=mean.births+ci.births),width=0.1,position=position_dodge(0.5)) + xlab("") + ylab("Average Births") + sex.colours.colour + theme.figures.legend + theme(axis.text.x=element_blank())

## Plot of mean childlessness
plot.childlessness <- ggplot(agePlot,aes(agePulse,mean.childlessness*100,group=y.var,colour=sexPulse)) + geom_point(position=position_dodge(0.5)) + geom_errorbar(aes(ymin=(mean.childlessness-ci.childlessness)*100,ymax=(mean.childlessness+ci.childlessness)*100),width=0.1,position=position_dodge(0.5)) + xlab("Age") + ylab("% Childless") + sex.colours.colour + theme.figures.legend

## Use pathwork to mash them together
children.plots <- plot.children / plot.childlessness + plot_layout(guides="collect") + plot_annotation(tag_levels = 'A')
children.plots

ggsave("figures/supplement/SuppFig15.png",children.plots, dpi = 600, height = 5, width = 8, units = "in")
```

### Tables

#### Table 1

This table was manually created. Not necessary to automate the process.

#### Table 2

This table was manually created. Not necessary to automate the process.

#### Table 3

Tabulate ORs and Effect Sizes estimated in this manuscript:

```{r}

format.table <- function(t, var, is.OR, rel.fig) {
  
  t <- copy(t)
  t <- t[,c("variant.type","var.beta","var.stderr","var.p","n.indvs","Sex")]
  t[,variant.type:=if_else(variant.type=="LOF_HC","PTV",
                           if_else(variant.type=="DEL","Deletion",
                                   if_else(variant.type=="DUP","Duplication",
                                           if_else(variant.type=="MIS","Missense",
                                                   if_else(variant.type=="SYN","Synonymous",
                                                           if_else(variant.type=="META","Meta-analysis (PTV+Deletion)","ERR"))))))]
  setnames(t,names(t),c("Variant Type","Effect (OR/Beta)","std. err.","p. value","N","Sex"))
  t[,`Effect Type`:=if_else(is.OR==T,"OR","beta")]
  t[,Phenotype:=var]
  t[,`Relevant Figure`:=rel.fig]
  return(t)
  
}

# shet on phenotype
## Figure 1
supptable3a <- format.table(plot.a[[1]],"Childlessness",T,"Figure1A") ## Main fertility

## Figure 2
supptable3a <- bind_rows(supptable3a,format.table(fig.partner[[1]],"Partner At Home",T,"Figure2A")) ## Partner at home
supptable3a <- bind_rows(supptable3a,format.table(fig.ea[[1]],"Educational Attainment",T,"Figure2B")) ## EA
supptable3a <- bind_rows(supptable3a,format.table(fig.hhi[[1]],"Household Income",F,"Figure2C")) ## HHI
supptable3a <- bind_rows(supptable3a,format.table(fig.cog[[1]],"Fluid Intel.",F,"Figure2D")) ## Cognition

## Supp Fig 3
supptable3a <- bind_rows(supptable3a,format.table(linear.data[[1]],"Num. Children",F,"SupFig3")) ## Linear rather than logistic fertility

## Sup Fig 4
supptable3a <- bind_rows(supptable3a,format.table(remove.zero[[1]],"Indv. w/children only",F,"SupFig4")) ## no childless individuals

## Supp Fig 5
supptable3a <- bind_rows(supptable3a,format.table(gene.data.pli[[1]],"high pLI",T,"SupFig5A")) ## pli on childlessness
supptable3a <- bind_rows(supptable3a,format.table(gene.data.shet[[1]],"high sHET",T,"SupFig5B")) ## shet on childlessness

## Supp Fig 6
supptable3a <- bind_rows(supptable3a,format.table(high.maf.data[[1]],"MAF ≤1e-3",T,"SupFig6")) ## maf ≤1e-3 variants

## Sup Fig 7
supptable3a <- bind_rows(supptable3a,format.table(res.age[age==40],"Age Group 40-50",T,"SupFig7")) ## age 40-50
supptable3a <- bind_rows(supptable3a,format.table(res.age[age==50],"Age Group 50-60",T,"SupFig7")) ## age 50-60
supptable3a <- bind_rows(supptable3a,format.table(res.age[age==60],"Age Group 60-70",T,"SupFig7")) ## age 60-70

## Sup Fig 7
supptable3a <- bind_rows(supptable3a,format.table(plottable[maf == 0],"All Variant Classes",T,"SupFig8")) ## All variant classes

## Sup Fig 11
supptable3a <- bind_rows(supptable3a,format.table(same.sex[[1]],"Same Sex Sexual Behaviour",T,"SupFig11")) ## Same sex sexual behaviour

## Sup Fig 14
supptable3a <- bind_rows(supptable3a,format.table(email.data[[1]],"Has Email",T,"SupFig14A")) ## email
supptable3a <- bind_rows(supptable3a,format.table(answered.mhq.data[[1]],"Answered MHQ",T,"SupFig14B")) ## answered MHQ

## Text-based
supptable3a <- bind_rows(supptable3a,format.table(no.male.fertility.plot[[1]],"No Male Infertility Genes",T,"TextOnly")) ## result w/o male infertility genes
supptable3a <- bind_rows(supptable3a,format.table(no.path.cnvs.plot[[1]],"No Pathogenic CNV carriers",T,"TextOnly")) ## no pathogenic CNV carriers
supptable3a <- bind_rows(supptable3a,format.table(no.mh.patients.plot[[1]],"No MH Patients",T,"TextOnly")) ## no MH patients
supptable3a <- bind_rows(supptable3a,format.table(no.disease.plot[[1]],"No Disease Genes",T,"TextOnly")) ## no Disease genes

format.table <- function(t, var, rel.fig) {
  
  t <- copy(t)
  t <- t[,c("beta","std.error","p.val","N","sexPulse")]
  setnames(t,names(t),c("Effect (OR/Beta)","std. err.","p. value","N","Sex"))
  t[,`Variant Type`:='NA']
  setcolorder(t,c("Variant Type","Effect (OR/Beta)","std. err.","p. value","N","Sex"))
  t[,`Effect Type`:="OR"]
  t[,Phenotype:=var]
  t[,`Relevant Figure`:=rel.fig]
  
  return(t)
  
}

supptable3b <- format.table(partner.beta.plot[[1]], "Partner  At Home","SupFig10A")
supptable3b <- bind_rows(supptable3b,format.table(cog.beta.plot[[1]], "Fluid Intel.","SupFig10B"))
supptable3b <- bind_rows(supptable3b,format.table(ea.beta.plot[[1]], "Educational Attainment","SupFig10C"))
supptable3b <- bind_rows(supptable3b,format.table(mhq.beta.plot[[1]], "Mental Health Traits","SupFig10D"))
supptable3b <- bind_rows(supptable3b,format.table(hhi.beta.plot[[1]], "Household Income","SupFig10E"))
supptable3b <- bind_rows(supptable3b,format.table(same.sex.beta.plot[[1]], "Same Sex Sexual Behaviour","SupFig10F"))

write.table(supptable3a,"figures/supplement/SuppTable3a.tsv",col.names=T,row.names=F,sep="\t",quote=F)
write.table(supptable3b,"figures/supplement/SuppTable3b.tsv",col.names=T,row.names=F,sep="\t",quote=F)

supptable3a[,formated:=if_else(`Effect Type`=="OR",
                     paste0("OR=",sprintf("%0.2f",`Effect (OR/Beta)`), " [95% CI ",sprintf("%0.2f",exp(log(`Effect (OR/Beta)`)-(1.96*`std. err.`))), "-",sprintf("%0.2f",exp(log(`Effect (OR/Beta)`)+(1.96*`std. err.`))),"]", " p=",if_else(`p. value`<=1e-2,sprintf("%0.1e",`p. value`),sprintf("%0.2f",`p. value`))),
                     paste0("Beta=",sprintf("%0.2f",`Effect (OR/Beta)`), " [95% CI ",sprintf("%0.2f",`Effect (OR/Beta)`-(1.96*`std. err.`)), "-",sprintf("%0.2f",`Effect (OR/Beta)`+(1.96*`std. err.`)),"]", " p=",if_else(`p. value`<=1e-2,sprintf("%0.1e",`p. value`),sprintf("%0.2f",`p. value`))))]

supptable3b[,formated:=paste0("OR=",sprintf("%0.2f",`Effect (OR/Beta)`), " [95% CI ",sprintf("%0.2f",exp(log(`Effect (OR/Beta)`)-(1.96*`std. err.`))), "-",sprintf("%0.2f",exp(log(`Effect (OR/Beta)`)+(1.96*`std. err.`))),"]", " p=",if_else(`p. value`<=1e-2,sprintf("%0.1e",`p. value`),sprintf("%0.2f",`p. value`)))]


```

#### Table 4

```{r}

supptable4 <- merge(cog.raw[,c("newiq","Obs","Mean","SD","pred.log")],childless.raw[,c("iq","inc.childlessness","std. err.","pred.log.inv")],by.x="newiq",by.y="iq")
supptable4[,sd_childlessness:=`std. err.`*sqrt(Obs)]
supptable4[,`std. err.`:=NULL]

setnames(supptable4,names(supptable4),c("IQ","n_individuals","observed_fertility_mean","observed_fertility_sd","predicted_fertility","observed_increased_childlessness","predicted_increased_childlessness","observed_increased_childlessness_sd"))
setcolorder(supptable4,c("IQ","n_individuals","observed_fertility_mean","observed_fertility_sd","predicted_fertility","observed_increased_childlessness","observed_increased_childlessness_sd","predicted_increased_childlessness"))

write.table(supptable4,"figures/supplement/SuppTable4.tsv",col.names=T,row.names=F,sep="\t",quote=F)

```

#### Table 5

```{r}

supptable5 <- modeling[,c("or","or.upper","n.indv","sex.ratio","ratio","trait","sex","mean.children","incidence","or.lower")]
setnames(supptable5,names(supptable5),c("OR.ganna","OR.upper.ganna","N.power","sex.ratio.power","fertility.ratio.power","trait","sex","mean.children.power","incidence.power","OR.lower.ganna"))
setcolorder(supptable5,c("sex","trait","OR.ganna","OR.lower.ganna","OR.upper.ganna","N.power","sex.ratio.power","incidence.power","fertility.ratio.power","mean.children.power"))
write.table(supptable5,"figures/supplement/SuppTable5.tsv",col.names=T,row.names=F,quote=F,sep="\t")

```

## 7D. Numbers Catalogue

This documents all numbers in the manuscript printed in rough order. These are just replicated from above.

```{r Numbers Catalogue}

## Median age and range
paste0("Median age                                     : ", UKBB.phenotype.data[,median(agePulse)], " (range ", UKBB.phenotype.data[,min(agePulse)], "-", UKBB.phenotype.data[,max(agePulse)],")")
paste0("")

## Number of Individuals per datatype:
paste0("Number of individuals with CNV data            : ", length(unique(variant.counts[type == "DEL" & allele.freq == 0,sample_id])))
paste0("Number of individuals with SNV data            : ", length(unique(variant.counts[type == "LOF_HC" & allele.freq == 0,sample_id])))
paste0("")

## Sex Burden of sHET:
format.sex.burden.DEL
format.sex.burden.PTV
paste0("")

## Linear Fertility Model (# Children ~ sHET Burden):
linear.data[[1]][variant.type == "META",paste0(Sex, "s have ",sprintf("%0.2f",abs(var.beta))," fewer children", " [95% CI ",sprintf("%0.2f",abs(var.beta+(1.96*var.stderr))), "-",sprintf("%0.2f",abs(var.beta-(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## Logistic Fertility Model (Childless ~ sHET Burden):
plot.a[[1]][ variant.type == "META",paste0(Sex, " OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## Sex of participants:
paste0("Percentage of females                          : ", sprintf("%0.0f", (nrow(UKBB.phenotype.data[sexPulse == 2]) / nrow(UKBB.phenotype.data))*100), "%")
paste0("")

## No Disease Genes:
no.disease.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," Disease Gene OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## No Male Infertility Genes:
print(paste0("Number of male infertility genes: ", nrow(male.infertility.genes)))
no.male.fertility.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Fertility Gene OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## Living with a Partner and having children:
partner.beta.plot[[1]][sexPulse == "Male",paste0(sexPulse, " MH OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]
paste0("")

## Same Sex
same.sex[[1]][Sex == "Male" & variant.type == "META",paste0(Sex, " Same Sex sHET OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
same.sex.beta.plot[[1]][,paste0(sexPulse, " Same Sex Phenotype OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]
paste0("")

##Fluid Intel Contrib to Fitness:
paste0("Number of Fluid Intel Indv: ", sum(fig.cog[[1]][variant.type == "META",n.indvs]), " (Male: ",fig.cog[[1]][Sex == "Male" & variant.type == "META",n.indvs],"; Female: ", fig.cog[[1]][Sex == "Female" & variant.type == "META",n.indvs], ")")
paste0("Contribution of Cognition to Fitness: ",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       " (",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.cog[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       ")")
paste0("")

## UKBB Biases
email.data[[1]][ variant.type == "META",paste0(Sex, " Email OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
answered.mhq.data[[1]][ variant.type == "META",paste0(Sex, " MHQ OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## MH Childlessness:
mhq.beta.plot[[1]][,paste0(sexPulse, " MH OR=",sprintf("%0.2f",beta), " [95% CI ",sprintf("%0.2f",exp(log(beta)-(1.96*std.error))), "-",sprintf("%0.2f",exp(log(beta)+(1.96*std.error))),"]", " p=",if_else(p.val<=1e-2,if_else(p.val <= 1e-100,"p ≤ 1e-100",sprintf("%0.1e",p.val)),sprintf("%0.2f",p.val)))]
paste0("")

## Path CNV Counts/Tests:
paste0("CNV Carriers account for ",sprintf("%0.1f",(length(unique(path.cnv.counts[,eid]))/nrow(samples.UKBB.cnv)*100)),"% (", length(unique(path.cnv.counts[,eid])),") of individuals.)")
no.path.cnvs.plot[[1]][Sex == "Male" & variant.type == "META",paste0(Sex," No Path CNVs OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("")

## MH Contribution to Fitness:
no.mh.patients.plot[[1]][variant.type == "META",paste0(Sex," No MH Patients OR=",sprintf("%0.2f",var.beta), " [95% CI ",sprintf("%0.2f",exp(log(var.beta)-(1.96*var.stderr))), "-",sprintf("%0.2f",exp(log(var.beta)+(1.96*var.stderr))),"]", " p=",if_else(var.p<=1e-2,sprintf("%0.1e",var.p),sprintf("%0.2f",var.p)))]
paste0("Contribution of MHTs to Fitness: ",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       " (",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.mhq[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       ")")
paste0("")

## Partner at Home Contribution to Fitness:
paste0("Contribution of Partner at Home to Fitness: ",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_mid]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_mid]))*100)),
       " (",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_upper]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_upper]))*100)),
       " - ",
       sprintf("%0.1f",(((1 - model.partner[shet == 1 & sex == 1,ratio_lower]) / (1 - model.fertility[shet == 1 & sex == 1,ratio_lower]))*100)),
       ")")
paste0("")

## Overall contribution to Fitness:
paste0("Contribution of sHET to Fitness (sex averaged): ",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_mid)])*100)),
       " (",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_upper)])*100)),
       " - ",
       sprintf("%0.1f",((1-model.fertility[shet == 1,mean(ratio_lower)])*100)),
       ")")
paste0("")

## Number of Individuals
paste0("Number of Broadly Euro Indiv                   : ", table(UKBB.raw.phenotypes[,`22006-0.0`]))
paste0("Number of Individuals after filtering relateds : ", nrow(UKBB.phenotype.data))
paste0("")

## Total CNVs:
paste0("Number of raw CNVs: ",nrow(ukbb.annotated.cnvs.qcd[eid %in% has.cnv.data[has_cnvs==1,eid]]))
quant.table <- data.table(table(ukbb.annotated.cnvs.qcd[filter.0.95.wes.support.score==T,ct]))
paste0("Number of CNVs (Unfiltered Indiv)  : ",quant.table[,sum(N)], " (DEL: ", quant.table[V1 == "DEL",N], "; DUP: ", quant.table[V1 == "DUP",N],")")
quant.table <- data.table(table(ukbb.annotated.cnvs.qcd[eid %in% samples.UKBB.cnv[,eid] & filter.0.95.wes.support.score==T,ct]))
paste0("Number of CNVs (Filtered Indiv)    : ",quant.table[,sum(N)], " (DEL: ", quant.table[V1 == "DEL",N], "; DUP: ", quant.table[V1 == "DUP",N],")")
paste0("Number of CNV Loci                 : ",nrow(data.table(table(ukbb.annotated.cnvs.qcd[,locus]))))
paste0("")
rm(quant.table)

## Total SNVs:
paste0("Number of SNV/INDel Variants: ", nrow(variants.UKBB[,]))
paste0("")

## UKBB Unmapped Regions:
paste0("Number of genes affected by UKBB Issue : XXX")
paste0("Go to the UKBB Unmapped Regions section for these numbers!!!")
paste0("")

## Total sHET Genes:
paste0("Total number of genes with sHET value                       : ", nrow(shet.genes))
paste0("Total number of genes with sHET value in both hg19 and hg38 : ", nrow(merge(shet.genes,gene.translate)))
paste0("")

## Total Disease Genes:
print(paste0("Number of male infertility genes: ", nrow(male.infertility.genes)))
paste0("")

## Total Indiv Lost with >3 filter:
paste0("Number of DEL Individuals Lost, pLI ≥ 0.9  : ", results.fertility[variant.type == "DEL" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "DEL" & maf == 0 & gene.list == "highPLI",sum(n.indvs)])
paste0("Number of DEL Individuals Lost, sHET ≥ 0.9 : ", results.fertility[variant.type == "DEL" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "DEL" & maf == 0 & gene.list == "highsHET",sum(n.indvs)])

paste0("Number of PTV Individuals Lost, pLI ≥ 0.9  : ", results.fertility[variant.type == "LOF_HC" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "LOF_HC" & maf == 0 & gene.list == "highPLI",sum(n.indvs)])
paste0("Number of PTV Individuals Lost, sHET ≥ 0.9 : ", results.fertility[variant.type == "LOF_HC" & maf == 0,sum(n.indvs)] - results.fertility.genelists[variant.type == "LOF_HC" & maf == 0 & gene.list == "highsHET",sum(n.indvs)])
paste0("")

## Base Fertility Stats:
paste0("Base Childlessness Male             : ", sprintf("%0.1f",base.childlessness.male*100))
paste0("Base Childlessness Female           : ", sprintf("%0.1f",base.childlessness.female*100))

paste0("Base Children Among Males w/Child   : ", sprintf("%0.2f",base.fertilities[sex == 1 & inc.zero == F,fertility]))
paste0("Base Children Among Females w/Child : ", sprintf("%0.2f",base.fertilities[sex == 2 & inc.zero == F,fertility]))

paste0("Base Children Among Males          : ", sprintf("%0.2f",base.fertilities[sex == 1 & inc.zero == T,fertility]))
paste0("Base Children Among Females        : ", sprintf("%0.2f",base.fertilities[sex == 2 & inc.zero == T,fertility]))
paste0("")

## Change in cognition:
paste0("Predicted drop in IQ for sHET = 1 male: " ,sprintf("%0.2f", model.cog[shet == 1 & sex == 1,100 - expected.iq_mid]))
paste0("")

## Median high pLI Gene:
paste0("high pLI genes (≥ 0.9) have a mean sHET value of : ",sprintf("%0.3f",mean.highpLI))
paste0("")
```


```





